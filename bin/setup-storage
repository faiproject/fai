#!/usr/bin/env perl 
# $Id$
#*********************************************************************
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# A copy of the GNU General Public License is available as
# `/usr/share/common-licences/GPL' in the Debian GNU/Linux distribution
# or on the World Wide Web at http://www.gnu.org/copyleft/gpl.html. You
# can also obtain it by writing to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
#*********************************************************************

use strict;

# treat all warnings about uninitialised values as errors
use warnings FATAL => qw(uninitialized);

################################################################################
#
# @file setup-storage
#
# @brief The main function of setup-storage - the tool to configure the
# partitioning from within FAI.
#
# This is an implementation from scratch to properly support LVM and RAID. The
# input format is documented in @ref parser.pm
#
# Some (developer) documentation may be found on
# http://wiki.fai-project.org/index.php/Setup-storage
#
# Some coding conventions:
# - no whitespace after ( and before )
# - keyword<whitespace>(...)
# - do not start a new line for {
# - } goes on a line on its own
# - one blank line after sub ...
#
# $Id$
#
# @author Christian Kern, Michael Tautschnig
# @date Sun Jul 23 16:09:36 CEST 2006
#
################################################################################

# include all subparts, which are part of the FAI perl package
use lib "/usr/share/fai/setup-storage/";
use FAI;
use Getopt::Std;
# for debugging purposes to print the hash structures
use Data::Dumper;


sub HELP_MESSAGE {

    print <<EOF;
$0 version $VERSION

USAGE: [-X]                     no test, your harddisks will be formated
                                default: only test, no real formating
       [-f<config-filename>]    default: parse classes
       [-d]                     enable debug output (equivalent to debug=1)
       [-s]                     perform syntax check only and exit
       [-D<disks>]              override disklist variable by space-separated <disks>
       [-L<logdir>]             use <logdir> instead of LOGDIR variable
       [-h]                     print this help message
EOF
    die;
}

# command line parameter handling

$Getopt::Std::STANDARD_HELP_VERSION = 1;
our ($opt_X, $opt_f, $opt_h, $opt_d, $opt_s, $opt_D, $opt_L); # the variables for getopt
getopts('Xf:hdsD:L:') or HELP_MESSAGE;
HELP_MESSAGE if $opt_h;

# enable debug mode, if requested using -d
$opt_d and $debug = 1;

# Really write any changes to disk
$opt_X and $no_dry_run = 1;
warn "setup-storage is running in test-only mode\n" unless ($no_dry_run);

# syntactic checks only
$opt_s and $check_only = 1;

# Find out whether $LOGDIR is usable or default to /tmp/fai
$opt_L and $DATADIR = $opt_L;
if (! -d $DATADIR) {
  !defined($opt_L) and defined ($ENV{LOGDIR}) and die
    "Environment variable LOGDIR is set, but $DATADIR is not a directory\n";
  mkdir $DATADIR or die
    "Failed to create directory $DATADIR\n";
  warn "Created data directory $DATADIR\n";
}

# $disklist may be provided by the environment
my $disklist = $ENV{disklist};
$opt_D and $disklist = $opt_D;
if (! defined($disklist)) {
  in_path("/usr/lib/fai/fai-disk-info") or die "/usr/lib/fai/fai-disk-info not found\n";
  $disklist = `/usr/lib/fai/fai-disk-info | sort`;
}

@disks = split( /[\n ]/, $disklist);
if ($debug) {
  print "disklist: ";
  print "$_\n" foreach(@disks);
}

# the config source file
my $config_file = undef;
# use the config file, if given
open($config_file, $opt_f) or die "Failed to open config file $opt_f\n" if ($opt_f);
unless ($opt_f) {
  defined ($ENV{classes}) or
    die "Environment variable classes is not set and -f was not given\n";
  # see which class file to use
  foreach my $classfile (reverse split(/\s+/, $ENV{classes})) {
    next unless (-r "$ENV{FAI}/disk_config/$classfile");
    open($config_file, "$ENV{FAI}/disk_config/$classfile") 
      or die "Failed to open $ENV{FAI}/disk_config/$classfile\n";
    $opt_f = "$ENV{FAI}/disk_config/$classfile";
    last;
  }
}

# if we could not find any matching class file, bail out
defined ($config_file) or die "No matching disk_config found\n";

# start the parsing - thereby $configs is filled
warn "Starting setup-storage $VERSION\n";
print "Using config file: $opt_f\n";
run_parser($config_file);

# make sure there are no empty disk_config stanzas
check_config;

if ($check_only)
{
  print "Syntax ok\n";
  exit 0;
}

# first find the proper way to tell udev to settle
$udev_settle = "udevadm settle --timeout=10" if (in_path("udevadm"));
$udev_settle = "udevsettle --timeout=10" if (in_path("udevsettle"));
defined($udev_settle) or die "Failed to find determine a proper way to tell udev to settle; is udev installed?";

# start all RAID arrays in case some of the aren't running yet
in_path("mdadm-startall") and `mdadm-startall`;
`$udev_settle`;

# read the sizes and partition tables of all disks listed in $disks
get_current_disks;

# see whether there are any existing LVMs
get_current_lvm;

# see whether there are any existing RAID devices
get_current_raid;

# mark devices as preserve, where not all already done so and check that only
# defined devices are marked preserve
propagate_and_check_preserve;

# debugging only: print the current configuration
if ($debug) {

  print "Current disk layout\n";

  # make sure perl doesn't warn about it being used only once, same below
  print Dumper \%current_config;

  print "Current LVM layout\n";

  print Dumper \%current_lvm_config;

  print "Current RAID layout\n";

  print Dumper \%current_raid_config;

  print "Current device tree\n";

  print Dumper \%current_dev_children;
}

# compute the new LVM and partition sizes; do the partition sizes first to have
# them available for the the volume group size estimation
compute_partition_sizes;
compute_lv_sizes;

# print the current contents of $configs
$debug and print "Desired disk layout\n";
$debug and print Dumper \%configs;
$debug and print "Desired device tree\n";
$debug and print Dumper \%dev_children;

# generate the command script
build_disk_commands;
build_raid_commands;
build_lvm_commands;
build_cryptsetup_commands;
order_commands;

# run all commands
# debugging only: print the command script
if ($debug) {
  foreach (&numsort(keys %commands)) {
    defined($commands{$_}{cmd}) or internal_error("Missing command entry for $_");
    print "$_:" . $commands{$_}{cmd} . "\n";
    defined($commands{$_}{pre}) and print "\tpre: " . $commands{$_}{pre} . "\n";
    defined($commands{$_}{post}) and print "\tpost: " . $commands{$_}{post} . "\n";
  }
}

# run the commands (if $no_dry_run is set)
foreach (&numsort(keys %commands)) {
  `$udev_settle`;
  next if ($commands{$_}{cmd} eq "true");
  execute_command($commands{$_}{cmd});
}

# generate the proposed fstab contents
# wait for udev to set up all devices
`$udev_settle`;
my @fstab = generate_fstab(\%configs);

# print fstab
$debug and print "$_\n" foreach (@fstab);

# write the proposed contents of fstab to $DATADIR/fstab
if ($no_dry_run) {
    my $output_filename =  "$DATADIR/fstab";
    open my $output_fh, ">", $output_filename
	or die "Could not open '$output_filename' - $!"; 
    print $output_fh "$_\n" foreach (@fstab);
    close $output_fh;
}

# write variables to $DATADIR/disk_var.sh
# debugging
$debug and print "$_=\${$_:-$disk_var{$_}}\n"
  foreach (keys %disk_var);

if ($no_dry_run) {
    my $output_filename =  "$DATADIR/disk_var.sh";
    open my $output_fh, ">", $output_filename
	or die "Could not open '$output_filename' - $!"; 
    print $output_fh "$_=\${$_:-$disk_var{$_}}\n" foreach (keys %disk_var);
    close $output_fh;
}

# print crypttab
$debug and print "$_\n" foreach (@crypttab);

# write the proposed contents of fstab to $DATADIR/fstab
if ($no_dry_run && scalar(@crypttab)) {
    my $output_filename =  "$DATADIR/crypttab";
    open my $output_fh, ">", $output_filename
	or die "Could not open '$output_filename' - $!"; 
    print $output_fh "$_\n" foreach (@crypttab);
    close $output_fh;
}


# 20:25 <rindolf> stockholm: please consider using Getopt::Long instead of Getopt::Std
# 20:27 <rindolf> stockholm: well, the script is too long. I prefer doing something like App::MyScript->run();
# 20:53 <rindolf> stockholm: I would suggest against exporting so much stuff from the module. Maybe create an OO interface.
# 20:54 <rindolf> stockholm: the module has too many variables declared with "our".
# 20:55 <mst> rindolf: I think he has a Parse::RecDescent problem there
# 20:56 <mst> make sure the globals were -only- used by the RecDescent stuff and otherwise hide from it
# 20:57 <mst> hence, encapsulate it and concentrate on the rest

