<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 10.2.1" />
<title>FAI Guide (Fully Automatic Installation)</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

pre {
  padding: 0;
  margin: 0;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #777777;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }


/*
 * xhtml11 specific
 *
 * */

tt {
  font-family: monospace;
  font-size: inherit;
  color: navy;
}

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overridden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

.monospaced {
  font-family: monospace;
  font-size: inherit;
  color: navy;
}

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}


/*
 * Theme specific overrides of the preceding (asciidoc.css) CSS.
 *
 */
body {
  font-family: Garamond, Georgia, serif;
  font-size: 17px;
  color: #3E4349;
  line-height: 1.3em;
}
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Garmond, Georgia, serif;
  font-weight: normal;
  border-bottom-width: 0;
  color: #3E4349;
}
div.title, caption.title { color: #596673; font-weight: bold; }
h1 { font-size: 240%; }
h2 { font-size: 180%; }
h3 { font-size: 150%; }
h4 { font-size: 130%; }
h5 { font-size: 115%; }
h6 { font-size: 100%; }
#header h1 { margin-top: 0; }
#toc {
  color: #444444;
  line-height: 1.5;
  padding-top: 1.5em;
}
#toctitle {
  font-size: 20px;
}
#toc a {
    border-bottom: 1px dotted #999999;
    color: #444444 !important;
    text-decoration: none !important;
}
#toc a:hover {
    border-bottom: 1px solid #6D4100;
    color: #6D4100 !important;
    text-decoration: none !important;
}
div.toclevel1 { margin-top: 0.2em; font-size: 16px; }
div.toclevel2 { margin-top: 0.15em; font-size: 14px; }
em, dt, td.hdlist1 { color: black; }
strong { color: #3E4349; }
a { color: #004B6B; text-decoration: none; border-bottom: 1px dotted #004B6B; }
a:visited { color: #615FA0; border-bottom: 1px dotted #615FA0; }
a:hover { color: #6D4100; border-bottom: 1px solid #6D4100; }
div.tableblock > table, table.tableblock { border: 3px solid #E8E8E8; }
th.tableblock, td.tableblock { border: 1px solid #E8E8E8; }
ul > li > * { color: #3E4349; }
pre, tt, .monospaced { font-family: Consolas,Menlo,'Deja Vu Sans Mono','Bitstream Vera Sans Mono',monospace; }
tt, .monospaced { font-size: 0.9em; color: black;
}
div.exampleblock > div.content, div.sidebarblock > div.content, div.listingblock > div.content { border-width: 0 0 0 3px; border-color: #E8E8E8; }
div.verseblock { border-left-width: 0; margin-left: 3em; }
div.quoteblock { border-left-width: 3px; margin-left: 0; margin-right: 0;}
div.admonitionblock td.content { border-left: 3px solid #E8E8E8; }


@media screen {
  body {
    max-width: 50em; /* approximately 80 characters wide */
    margin-left: 16em;
  }

  #toc {
    position: fixed;
    top: 0;
    left: 0;
    bottom: 0;
    width: 13em;
    padding: 0.5em;
    padding-bottom: 1.5em;
    margin: 0;
    overflow: auto;
    border-right: 3px solid #f8f8f8;
    background-color: white;
  }

  #toc .toclevel1 {
    margin-top: 0.5em;
  }

  #toc .toclevel2 {
    margin-top: 0.25em;
    display: list-item;
    color: #aaaaaa;
  }

  #toctitle {
    margin-top: 0.5em;
  }
}
</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install(3);
/*]]>*/
</script>
</head>
<body class="article">
<div id="header">
<h1>FAI Guide (Fully Automatic Installation)</h1>
<span id="author">Thomas Lange</span><br />
<span id="email"><code>&lt;<a href="mailto:lange@debian.org">lange@debian.org</a>&gt;</code></span><br />
<span id="revnumber">version 6.4,</span>
<span id="revdate">Mer. 10 Avr 2025</span>
<div id="toc">
  <div id="toctitle">Table of Contents</div>
  <noscript><p><b>JavaScript must be enabled in your browser to display the table of contents.</b></p></noscript>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph"><p>Une version plus ancienne de ce guide en français est disponible à
<a href="https://fai-project.org/fai-guide-fr">https://fai-project.org/fai-guide-fr</a>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_résumé">Résumé</h2>
<div class="sectionbody">
<div class="paragraph"><p>FAI est un système non-interactif pour installer, configurer et gérer des
systèmes Linux et les configurations de logiciels sur des ordinateurs comme sur des machines
virtuelles et des environnements chroot, depuis des petits réseaux jusqu&#8217;à de
grandes infrastructures et de grands clusters.</p></div>
<div class="paragraph"><p>Ce manuel décrit le logiciel Fully Automatic Installation (installation entièrement automatique).
Cela inclut l’installation des paquets, la configuration du serveur, la
création de la configuration et la gestion des erreurs.</p></div>
<div class="paragraph"><p>(c) 2000-2025 Thomas Lange</p></div>
<div class="paragraph"><p>Ce manuel est un logiciel libre; Vous pouvez le redistribuer et / ou le
modifier selon les termes de la Licence Publique Générale GNU publiée
par la Free Software Foundation; Soit la version 2, soit (à votre choix)
toute version ultérieure.</p></div>
<div class="paragraph"><p>Ceci est distribué dans l’espoir qu’il sera utile, mais sans aucune
garantie ; Sans même la garantie implicite de qualité marchande ou
d’adaptation à un usage particulier. Pour plus de détails, consultez la
License Générale Publique GNU.</p></div>
<div class="paragraph"><p>Une copie de la Licence Générale Publique GNU est disponible sous la forme
/usr/share/common-licenses/GPL dans la distribution Debian GNU/Linux ou
sur le World Wide Web sur le site GNU Vous pouvez également l’obtenir en
écrivant à la Free Software Foundation , Inc., 59 Temple Place - Suite
330, Boston, MA 02111-1307, États-Unis.</p></div>
<div style="page-break-after:always"></div>
</div>
</div>
<div class="sect1">
<h2 id="_a_id_introduction_a_introduction"><a id="introduction"></a>Introduction</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_a_id_availability_a_disponibilité"><a id="availability"></a>Disponibilité</h3>
<div class="dlist"><dl>
<dt class="hdlist1">
Page d&#8217;accueil
</dt>
<dd>
<p>
<a href="https://fai-project.org">https://fai-project.org</a>
</p>
</dd>
<dt class="hdlist1">
Wiki FAI
</dt>
<dd>
<p>
<a href="https://wiki.fai-project.org">https://wiki.fai-project.org</a>
</p>
</dd>
<dt class="hdlist1">
Téléchargement
</dt>
<dd>
<p>
<a href="https://fai-project.org/download">https://fai-project.org/download</a>
</p>
</dd>
<dt class="hdlist1">
Entrée pour <em>sources.list</em>
</dt>
<dd>
<p>
<code>deb https://fai-project.org/download bookworm koeln</code>
</p>
</dd>
<dt class="hdlist1">
Pages de manuel
</dt>
<dd>
<p>
<a href="https://fai-project.org/doc/man/">https://fai-project.org/doc/man/</a>
</p>
</dd>
<dt class="hdlist1">
Listes de diffusion
</dt>
<dd>
<p>
<a href="https://lists.uni-koeln.de/mailman/listinfo/linux-fai">https://lists.uni-koeln.de/mailman/listinfo/linux-fai</a>
</p>
</dd>
<dt class="hdlist1">
Retour d&#8217;information
</dt>
<dd>
<p>
Envoyez vos réflexions et vos commentaires à <a href="mailto:fai@fai-project.org">fai@fai-project.org</a> ou
à la liste de diffusion.
</p>
</dd>
<dt class="hdlist1">
Boguess
</dt>
<dd>
<p>
Utiliser le système de suivi des bogues Debian (BTS) <a href="https://bugs.debian.org/src:fai">https://bugs.debian.org/src:fai</a>
</p>
</dd>
<dt class="hdlist1">
Changements visibles par l’utilisateur
</dt>
<dd>
<p>
<a href="http://fai-project.org/NEWS">http://fai-project.org/NEWS</a>
</p>
</dd>
<dt class="hdlist1">
Arbre source via git
</dt>
<dd>
<p>
git clone git://github.com/faiproject/fai.git
</p>
</dd>
<dt class="hdlist1">
Voir l’arbre source avec https
</dt>
<dd>
<p>
  <a href="https://github.com/faiproject/fai">https://github.com/faiproject/fai</a>
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Les pages man incluent toujours des informations à jour et beaucoup de
détails sur toutes les commandes FAI. Alors, n’oubliez pas de les lire
attentivement. Lisez maintenant ce manuel, puis profitez de
l’installation entièrement automatique et de votre temps économisé.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_motivation_a_motivation"><a id="motivation"></a>Motivation</h3>
<div class="paragraph"><p>Avez-vous déjà effectué des installations identiques d’un système
d’exploitation à plusieurs reprises? Souhaitez-vous être en mesure
d’installer un cluster Linux avec des dizaines de nœuds d&#8217;un seul coup?</p></div>
<div class="paragraph"><p>Répéter la même tâche encore et encore est ennuyeux&#8201;&#8212;&#8201;et conduira
certainement à des erreurs. Aussi beaucoup de temps pourrait être sauvé
si les installations étaient faites automatiquement. Un processus
d’installation avec interaction manuelle ne peut pas passer à l&#8217;échelle. Mais les
grappes (clusters) ont l’habitude de croître au fil des ans. Pensez à long terme
plutôt que de planifier seulement quelques mois dans l’avenir.</p></div>
<div class="paragraph"><p>En 1999, j’ai dû effectuer une installation d’un cluster Linux avec un
serveur et 16 clients. Puisque j’ai eu beaucoup d’expérience en faisant
des installations automatiques des systèmes d’exploitation de Solaris
sur le matériel de SUN SPARC, l’idée de construire une installation
automatique pour Debian est née. Solaris dispose d’une fonctionnalité
d’installation automatique appelée JumpStart
<span class="footnote"><br />[Solaris 8 Advanced Installation Guide at "https://docs.oracle.com/cd/E19455-01/806-0957/806-0957.pdf]<br /></span>.
En conjonction avec les scripts d’auto-installation de Casper Dik
<span class="footnote"><br />[<a href="http://www.science.uva.nl/pub/solaris/auto-install">http://www.science.uva.nl/pub/solaris/auto-install</a>]<br /></span>,
Je pouvais épargner beaucoup de temps non seulement pour chaque nouvel
ordinateur de SUN, mais aussi pour la réinstallation des postes de
travail existants. Par exemple, j’ai dû construire un LAN temporaire
avec quatre stations de travail SUN pour une conférence, qui a duré
seulement quelques jours. J’ai retiré ces postes de travail de notre
réseau de recherche habituel et mis en place une nouvelle installation
pour la conférence. Quand elle a été terminée, j’ai simplement réintégré les
postes de travail dans le réseau de recherche, redémarré une seule fois,
et après une demi-heure, tout était opérationnel comme avant. La
configuration de tous les postes de travail était exactement la même
qu’avant la conférence, car tout était effectué par le même processus
d’installation. J’ai également utilisé l’installation automatique pour
réinstaller un poste de travail après qu&#8217;un disque dur endommagé ait été
remplacé. Il m’a fallu deux semaines pour recevoir le nouveau disque
dur, mais seulement quelques minutes après l’installation du nouveau
disque, le poste de travail fonctionnait comme avant. Et c’est pourquoi
j’ai choisi d’adapter cette technique à un cluster de PC sous Linux.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_work_a_comment_fonctionne_fai"><a id="work"></a>Comment fonctionne FAI</h3>
<div class="paragraph"><p>Le client d’installation qui sera installé à l’aide de FAI, est démarré
via une carte réseau ou à partir d’un CD ou d’une clé USB. Il obtient
une adresse IP et démarre un noyau Linux qui monte son système de
fichiers racine via NFS (nfsroot) du serveur d’installation. Une fois le
noyau démarré, le script de démarrage FAI exécute l’installation
automatique qui n’a pas besoin d’interaction. Tout d’abord, les disques
durs seront partitionnés, les systèmes de fichiers seront créés et des
paquets logiciels seront ensuite installés. Après cela, le nouveau système
d’exploitation installé est configuré selon vos besoins locaux en
utilisant quelques scripts. Enfin, le nouveau système d’exploitation
sera démarré à partir du disque local.</p></div>
<div class="paragraph"><p>Les détails sur la façon d’installer l’ordinateur (la configuration)
sont stockés dans l’espace de configuration sur le serveur d’installation.
Les fichiers de configuration sont répartis entre des groupes
d’ordinateurs s’ils sont similaires, en utilisant le concept de classe.
Vous n’avez donc pas besoin de créer une configuration pour chaque
nouvel hôte. Ainsi, FAI est une méthode évolutive pour
installer un gros cluster avec un grand nombre de nœuds même si leur
configuration n’est pas identique.</p></div>
<div class="paragraph"><p>FAI peut également être utilisé comme un système de sauvetage ou pour
l’inventaire matériel. Vous pouvez démarrer votre ordinateur, mais il
n’effectuera pas une installation. Au lieu de cela, il exécutera un
Debian GNU / Linux entièrement fonctionnel sans utiliser les disques
durs locaux. Ensuite, vous pouvez effectuer une connexion à distance et
sauvegarder ou restaurer une partition de disque, vérifier un système de
fichiers, inspecter le matériel ou effectuer toute autre tâche.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_features_a_caractéristiques"><a id="features"></a>Caractéristiques</h3>
<div class="ulist"><ul>
<li>
<p>
On peut faire une installation entièrement automatisée.
</p>
</li>
<li>
<p>
Installation très rapide sans surveillance.
</p>
</li>
<li>
<p>
Système flexible grâce à un concept de classe simple.
</p>
</li>
<li>
<p>
Mise à jour des systèmes en cours d’exécution sans réinstallation.
</p>
</li>
<li>
<p>
Images « Cloud » pour un environnement de virtualisation.
</p>
</li>
<li>
<p>
Les hôtes peuvent démarrer à partir d’une carte réseau, d’un CD, d’une clé USB.
</p>
</li>
<li>
<p>
Création simple d’une image ISO vive ou pour l&#8217;installation.
</p>
</li>
<li>
<p>
Prise en charge  de PXE avec la méthode de démarrage DHCP.
</p>
</li>
<li>
<p>
Support des systèmes de fichiers ReiserFS, ext3/ext4, btrfs et XFS.
</p>
</li>
<li>
<p>
Support logiciel RAID et LVM. Support LUKS.
</p>
</li>
<li>
<p>
Détection automatique du matériel.
</p>
</li>
<li>
<p>
On peut déployer Debian, Ubuntu, Rocky Linux, CentOS, AlmaLinux, SuSE
</p>
</li>
<li>
<p>
Possibilité de connexion à distance via ssh lors du processus d’installation.
</p>
</li>
<li>
<p>
Toutes les configurations similaires sont partagées entre tous les les clients d’installation.
</p>
</li>
<li>
<p>
Les fichiers journaux de toutes les installations sont enregistrés sur le serveur d’installation.
</p>
</li>
<li>
<p>
Prise en charge des scripts Shell, Perl, Python, Ruby, expect et CFEngine lors de l&#8217;étape de personnalisation.
</p>
</li>
<li>
<p>
Prise en charge de nombreux protocoles comme NFS, FTP, HTTP, git.
</p>
</li>
<li>
<p>
Peut être utilisé comme un système de sauvetage et pour l’inventaire matériel.
</p>
</li>
<li>
<p>
Prise en charge de clients sans disque.
</p>
</li>
<li>
<p>
Prise en charge trans-architecture, par exemple pour des appareils embarqués (embedded devices).
</p>
</li>
<li>
<p>
Ajoutez facilement vos propres fonctions via des hooks ou modifiez le comportement par défaut.
</p>
</li>
<li>
<p>
Prise en charge du clonage de machines utilisant des images de disque.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_la_durée_d_8217_installation">La durée d&#8217;installation</h3>
<div class="paragraph"><p>La durée d’installation est déterminée par la quantité de logiciel et la
vitesse du disque dur. Voici quelques exemples de durée. Tous les
clients d’installation avaient une carte réseau 1Gbit installée.</p></div>
<div class="tableblock">
<table rules="all"
width="80%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="26%" />
<col width="13%" />
<col width="20%" />
<col width="26%" />
<col width="13%" />
<thead>
<tr>
<th align="left" valign="top"> CPU  </th>
<th align="center" valign="top">  RAM </th>
<th align="left" valign="top">   Disque    </th>
<th align="right" valign="top">   Logiciels installés  </th>
<th align="right" valign="top"> durée</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">i7-3770T 2.50GHz</p></td>
<td align="center" valign="top"><p class="table">8GB</p></td>
<td align="left" valign="top"><p class="table">SSD</p></td>
<td align="right" valign="top"><p class="table">6 GB logiciel</p></td>
<td align="right" valign="top"><p class="table">8.5 min</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Core-i7 3.2GHz</p></td>
<td align="center" valign="top"><p class="table">6GB</p></td>
<td align="left" valign="top"><p class="table">SATA disk</p></td>
<td align="right" valign="top"><p class="table">4.3GB logiciel</p></td>
<td align="right" valign="top"><p class="table">7 min</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Core-i7 3.2GHz</p></td>
<td align="center" valign="top"><p class="table">6GB</p></td>
<td align="left" valign="top"><p class="table">SATA disk</p></td>
<td align="right" valign="top"><p class="table">471 MB logiciel</p></td>
<td align="right" valign="top"><p class="table">77sec</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Intel Core2 Duo</p></td>
<td align="center" valign="top"><p class="table">2GB</p></td>
<td align="left" valign="top"><p class="table">SATA disk</p></td>
<td align="right" valign="top"><p class="table">3 GB logiciel</p></td>
<td align="right" valign="top"><p class="table">14 min</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_id_impatient_a_quickstart_pour_l_8217_utilisateur_impatient"><a id="impatient"></a>Quickstart - Pour l&#8217;utilisateur impatient</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_a_id_first_a_ma_première_installation"><a id="first"></a>Ma première installation</h3>
<div class="paragraph"><p>Sans plus tarder, cette section fournira une démonstration rapide et
facile d’une installation entièrement automatique à l’aide du CD FAI et
d’une machine virtuelle.</p></div>
<div class="paragraph"><p>Il suffit de télécharger l' image ISO du CD à partir de
<a href="https://fai-project.org/fai-cd">https://fai-project.org/fai-cd</a> et de démarrer votre VM à l’aide de ce CD.
Vous verrez un menu grub où vous pouvez choisir parmi différents types
d’installation.</p></div>
<div class="paragraph"><p>Cette installation s’exécutera sans serveur d’installation.
L’installation à partir du CD est identique à celle exécutée dans un
environnement réseau à l’aide du serveur d’installation FAI, et peut être aussi
effectuée à l&#8217;aide d&#8217;une clé USB sur un ordinateur physique.</p></div>
<div class="paragraph"><p>On peut aussi créer soi-même une image FAI (installation entièrement automatique)
à la page web <a href="https://fai-project.org/FAIme">https://fai-project.org/FAIme</a> sans avoir besoin d&#8217;installer
FAI sur son ordinateur.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_cdserver_a_ma_première_installation_à_l_8217_aide_d_8217_un_serveur"><a id="cdserver"></a>Ma première installation à l&#8217;aide d&#8217;un serveur</h3>
<div class="paragraph"><p>Nous allons créer un réseau privé et lancer deux machines vituelles. L&#8217;une
deviendra votre propre serveur FAI, l&#8217;autre sera un client d&#8217;installation.</p></div>
<div class="paragraph"><p>Si vous avez l’intention d’utiliser VMware ou VirtualBox, assurez-vous
que votre client utilise une connexion réseau pontée (bridged network).
On trouve une description détaillée dans le wiki FAI
<span class="footnote"><br />[<a href="https://wiki.fai-project.org/index.php/VirtualBox_for_your_first_FAI_installation">https://wiki.fai-project.org/index.php/VirtualBox_for_your_first_FAI_installation</a>]<br /></span>.
on ne peut pas utiliser des interfaces réseau pontées via le réseau sans
fil, car la plupart des cartes réseau WiFi ne prennent pas en charge
cette fonctionnalité.</p></div>
<div class="paragraph"><p>Quand on utilise Qemu/KVM et le script <code>fai-kvm</code> on peut créer le réseau à l&#8217;aide de
la commande <code>fai-mk-network</code>. Il faut commencer par installer quelques paquets logiciels</p></div>
<div class="listingblock">
<div class="content">
<pre><code># apt-get install qemu-system-gui qemu-kvm qemu-utils</code></pre>
</div></div>
<div class="paragraph"><p>La commande ci-dessous met en place un réseau privé avec un pont logiciel et plusieurs
TAPs réseau
<span class="footnote"><br />[<a href="https://fr.wikipedia.org/wiki/TAP_r%C3%A9seau">https://fr.wikipedia.org/wiki/TAP_r%C3%A9seau</a>]<br /></span>
appartenant à l&#8217;utilisateur <code>&lt;nom_d_utilisateur&gt;</code>.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>fai-mk-network &lt;nom_d_utilisateur&gt;</code></pre>
</div></div>
<div class="paragraph"><p>Après cela, vous pouvez utiliser fai-kvm (-h vous aidera) pour démarrer
des machines virtuelles en utilisant KVM qui sont connectés à ce réseau
privé. Faites attention. Par défaut, fai-kvm créera les images de disque
pour les machines virtuelles dans <code>+/tmp+</code>, qui est un disque RAM sur la plupart des
systèmes. Il n’y a aucun problème à créer une image de disque vide de
20G dans /tmp (même si cette partition est de 4 Go de taille), mais
alors que la VM écrit des données sur son disque, cela commencera à
consommer de l’espace dans <code>+/tmp+</code>.</p></div>
<div class="paragraph"><p>Démarrez le premier hôte virtuel, qui deviendra le serveur FAI
<span class="footnote"><br />[Cette installation utilisera environ 2GB d&#8217;espace dans <code>/tmp</code>.]<br /></span> :</p></div>
<div class="listingblock">
<div class="content">
<pre><code>fai-kvm -Vn -s20 -u 1 cd faicd64-small.iso</code></pre>
</div></div>
<div class="paragraph"><p>Dans le menu grub; sélectionnez <code>faiserver, using internal DHCP and a fixed IP</code>.
Cela va installer
un hôte appelé faiserver avec IP 192.168.33.250 qui contient tous les
logiciels nécessaires pour un serveur FAI. Il configurera également un
cache de paquets local (en utilisant apt-cacher-ng). Une fois
l’installation terminée, redémarrez la machine. Lors du premier
démarrage du nouveau système, il configurera automatiquement le nfsroot.
Cela peut prendre quelques minutes.</p></div>
<div class="paragraph"><p>Après cela, vous pouvez démarrer des hôtes supplémentaires en utilisant
un démarrage réseau. Pour chaque nouvel hôte, vous devez utiliser une
valeur différente pour <code>+-u+</code>, qui sera utilisée pour générer des
adresses MAC différentes et utiliser des noms de fichier d’image de
disque différents.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>fai-kvm -Vn -u 2 pxe</code></pre>
</div></div>
<div class="paragraph"><p>Ces clients d’installation vous montreront un menu, où vous pouvez
sélectionner le type d’installation que vous souhaitez effectuer. Si le
client d’installation ne trouve pas le serveur, c’est généralement parce
que fai-monitor n&#8217;y fonctionne plus. Cela peut se produire si vous
redémarrez le faiserver après l’installation. Pour remédier à cela,
exécutez simplement fai-monitor sur le faiserver et relancez le
démarrage du client.</p></div>
<div class="paragraph"><p>Un autre client pourrait être lancé avec:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>fai-kvm -Vn -u 3 pxe</code></pre>
</div></div>
<div class="paragraph"><p>Vous pouvez démarrer autant de machines dans le réseau que de TAPs réseau
disponibles. Toutes ces machines peuvent se
connecter à l’Internet extérieur, mais sont seulement accessibles à
partir de votre machine hôte.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_id_overview_a_vue_d_8217_ensemble_et_concepts"><a id="overview"></a>Vue d&#8217;ensemble et Concepts</h2>
<div class="sectionbody">
<div class="paragraph"><p>FAI est un système non interactif permettant d’installer, de
personnaliser et de gérer les configurations de systèmes et de logiciels
Linux sur les ordinateurs ainsi que sur les machines virtuelles et les
environnements chroot, des petits réseaux aux grandes infrastructures et
clusters. Vous pouvez prendre un ou plusieurs PC vierges, mettre sous
tension et après quelques minutes, Linux est installé, configuré et
fonctionnel sur l’ensemble du cluster, sans aucune interaction nécessaire.
Ainsi, il s’agit d’une méthode évolutive pour installer et mettre à jour
un cluster sans surveillance impliquant peu d’efforts. FAI utilise
le système d’exploitation Linux et une collection de scripts shell et
Perl pour le processus d’installation. Les modifications apportées aux
fichiers de configuration du système d’exploitation peuvent être
effectuées par des scripts CFEngine, shell (bash et zsh), Perl, Python, Ruby et
expect.</p></div>
<div class="paragraph"><p>Les personnes intéressées par FAI sont des administrateurs système qui doivent
installer Linux sur une ou même des centaines d’ordinateurs. Parce qu’il
s’agit d’un outil d’installation à usage général, il peut être utilisé
pour l’installation d’un cluster Beowulf, d’une ferme de rendu ou
d’un laboratoire Linux ou d’une salle de classe. De plus, des réseaux
Linux de grande envergure avec différents matériels ou différentes
exigences d’installation sont faciles à établir à l’aide de FAI. Mais
n’oubliez pas de planifier votre installation. Le chapitre
<a href="#plan">[plan]</a> contient quelques conseils utiles à ce sujet.</p></div>
<div class="sect2">
<h3 id="_a_id_terms_a_terminologie"><a id="terms"></a> Terminologie</h3>
<div class="paragraph"><p>Commençons par décrire quelques termes utilisés dans ce manuel.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Le serveur d&#8217;installation 
</dt>
<dd>
<p>
Il fournit les services DHCP, TFTP et NFS ainsi que les données de
configuration pour tous les clients d’installation. Dans les exemples
de ce manuel, cet hôte s’appelle <em>faiserver</em>. C&#8217;est l’hôte où le paquet
<em>faiserver</em> est installé.
</p>
</dd>
<dt class="hdlist1">
Le client d&#8217;installation 
</dt>
<dd>
<p>
Un hôte qui sera installé à l’aide de FAI et une configuration fournie
par le serveur d’installation. Aussi appelé client pour faire court. Dans
ce manuel, les hôtes d’exemple sont appelés demohost, xfcehost,
gnomehost … Cet ordinateur doit démarrer à partir de son interface
réseau à l’aide de PXE.
</p>
</dd>
<dt class="hdlist1">
Espace de configuration
</dt>
<dd>
<p>
Une structure de sous-répertoire contenant plusieurs fichiers. Ces
fichiers décrivent les détails de la manière dont l’installation des
clients sera effectuée. Toutes les données de configuration sont
stockées là. Il est également appelé <em>config space</em> pour faire court. Il
comprend des informations sur :
</p>
<div class="ulist"><ul>
<li>
<p>
Organisation du disque dur dans un format similaire à fstab
</p>
</li>
<li>
<p>
Systèmes de fichiers locaux, leurs types, points de montage et options de montage
</p>
</li>
<li>
<p>
Paquets logiciels
</p>
</li>
<li>
<p>
Disposition du clavier, fuseau horaire, configuration Xorg, systèmes de fichiers distants, comptes utilisateurs, imprimantes …
</p>
</li>
</ul></div>
<div class="paragraph"><p>Le package <em>fai-doc</em> inclut un exemple d’espace de configuration
incluant des exemples pour les hôtes utilisant l’environnement XFCE et
GNOME entre autres. En invoquant <code>fai-mk-configspace</code> on copie ces exemples vers
<em>/srv/fai/config</em>. Il est recommandé d&#8217;étudier ces fichiers de configuration et
ces scripts pour mieux comprendre comment FAI fonctionne.</p></div>
</dd>
<dt class="hdlist1">
nfsroot, NFS-Root 
</dt>
<dd>
<p>
Un système de fichiers situé sur le serveur d’installation. Pendant le
processus d’installation, c’est le système de fichiers complet pour
les clients d’installation. Tous les clients partagent le même
nfsroot, qu’ils montent en lecture seule. Le nfsroot a besoin
d’environ 1.1Go d’espace disque libre.
</p>
</dd>
<dt class="hdlist1">
TFTP 
</dt>
<dd>
<p>
Sert aux clients le fichier initrd et le noyau utilisés pour le processus
d’installation. Avec le système de fichiers servi par NFS, ces deux
composent un système d&#8217;exploitation temporaire dans lequel les installations sont
réalisées.
</p>
</dd>
<dt class="hdlist1">
Classes FAI 
</dt>
<dd>
<p>
Les classes sont des noms qui déterminent quel fichier de
configuration est sélectionné. Si un client appartient à la classe
WEBSERVER, il sera configuré en tant que serveur Web, la classe
DESKTOP pour, par exemple, déterminer les paquets logiciels qui seront
installés.
</p>
</dd>
<dt class="hdlist1">
profil 
</dt>
<dd>
<p>
Un profil FAI est juste une liste de classes FAI assignées à un nom de
profil, qui est étendu par une description de ce profil. C’est-à-dire
que l’on peut avoir deux profils "Webserver", l’un incluant la classe
APACHE, et un autre incluant la classe NGINX, pour ensuite installer la solution
de serveur web correspondante.
</p>
</dd>
<dt class="hdlist1">
les tâches 
</dt>
<dd>
<p>
L’installation d’un client se compose de plusieurs parties, appelées
tâches. Les tâches sont des sous-programmes prédéfinis qui effectuent
une certaine partie de la FAI. Les tâches FAI suivantes sont exécutées
au cours d’une installation sur les clients d’installation.
</p>
</dd>
</dl></div>
<div class="quoteblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre><code>confdir               # trouver l'espace de configuration
setup                 # quelques initialisations, lancement de sshd à la demande
defclass              # définition des classes FAI
defvar                # définition de variables
action                # évaluer FAI_ACTION
install               # Démarrer l'installation
partition             # partitionner les disques durs, créer les systèmes de fichiers
mountdisks            # monter les systèmes de fichiers
extrbase              # extraire le fichier base.tar.xz
debconf               # pré-ensemencer le deconf de Debian
repository            # préparer l'accès aux dépôts de paquets
updatebase            # mettre en place les outils de gestion de paquets et mettre les paquets à jour
instsoft              # installer les paquets logiciels
configure             # lancer les scripts de personnalisation
finish                # faire un peu de ménage, afficher les statistiques d'installation
tests                 # appeler des tests s'il y en a
chboot                # lancer fai-chboot sur le serveur d'installation
savelog               # enregistrer les fichiers de journalisation localement et à distance
faiend                # redémarrage de l'hôte, éjection du CD si nécessaire</code></pre>
</div></div>
</div>
<div class="attribution">
</div></div>
<div class="quoteblock">
<div class="content">
<div class="paragraph"><p>Voilà des tâches qui sont exécutées seulement lorsqu’on fait une action différente</p></div>
<div class="literalblock">
<div class="content">
<pre><code>dirinstall           # installer un environnement chroot
softupdate           # ne faire que la configuration du système
sysinfo              # imprimer une information système détaillée
inventory            # imprimer un inventaire court du matériel</code></pre>
</div></div>
</div>
<div class="attribution">
</div></div>
<div class="paragraph"><p>Pour une description plus détaillée des <em>tâches</em> , voir <a href="#tasks">[tasks]</a>.</p></div>
<div class="paragraph"><p>Notez que vous n&#8217;êtes pas limité aux tâches FAI. Vous pouvez également
définir des programmes ou des scripts supplémentaires qui seront
exécutés à certaines occasions. On les appelle des <em>hooks</em>.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
hooks
</dt>
<dd>
<p>
Les Hooks sont des plugins, ils peuvent ajouter des fonctionnalités
supplémentaires au processus d’installation ou même remplacer des
tâches entières de FAI. Les Hooks sont expliqués en détail dans
<a href="#hooks">[hooks]</a>.
</p>
</dd>
</dl></div>
</div>
<div class="sect2">
<h3 id="_a_id_classc_a_le_concept_de_classe"><a id="classc"></a>Le concept de classe</h3>
<div class="paragraph"><p>Les classes sont utilisées dans presque toutes les tâches de
l’installation. Les classes déterminent quels fichiers de configuration
choisir parmi une liste d’alternatives disponibles. Pour déterminer les
fichiers de configuration à utiliser, FAI recherche dans la liste des classes
définies et utilise tous les fichiers de configuration correspondant à
un nom de classe <span class="footnote"><br />[on peut aussi seulement utiliser le fichier de configuration
qui a la priorité la plus élevée, comme l&#8217;ordre des classes définit une
priorité de la plus basse à la plus élevée dans la liste des classes.  ]<br /></span>. La boucle suivante
implémente cette fonction en pseudo-code shell :</p></div>
<div class="listingblock">
<div class="content">
<pre><code>for class in $all_classes; do
   if [ -r $config_dir/$class ]; then      # s'il exite un fichier nommé $class
      your_command $config_dir/$class      # invoquer une commande avec ce nom de fichier
      # sortir si on n'a besoin que du premier fichier qui convient
   fi
done</code></pre>
</div></div>
<div class="paragraph"><p>La beauté de ceci c&#8217;est qu&#8217;on peut ajouter
une nouvelle alternative de configuration et qu&#8217;elle sera automatiquement
utilisée par FAI sans modifier le code, si le fichier de configuration
utilise un nom de classe.</p></div>
<div class="paragraph"><p>C’est parce que la boucle détecte automatiquement les nouveaux fichiers
de configuration qui doivent être utilisés. L’idée d’utiliser des
classes en général et d’utiliser certains fichiers correspondant à un
nom de classe pour une configuration est adoptée à partir des scripts
d’installation par Casper Dik pour Solaris. Cette technique s’est avérée
très utile et facile.</p></div>
<div class="paragraph"><p>Vous pouvez regrouper plusieurs hôtes partageant les mêmes fichiers de
configuration en utilisant la même classe. Vous pouvez également diviser
l’ensemble des données de configuration pour tous les clients en
plusieurs classes et les utiliser comme des briques de lego et
construire la configuration entière pour un seul client en assemblant
les briques.</p></div>
<div class="paragraph"><p>Si un client appartient à la classe <em>A</em>, on dit que la classe <em>A</em>
est définie pour ce client. Une classe n’a pas de valeur, elle est juste
définie ou indéfinie.</p></div>
<div class="paragraph"><p>Les classes déterminent comment l’installation est effectuée. Par
exemple, un client d’installation peut être configuré pour obtenir le
bureau XFCE en y ajoutant simplement la classe <em>XFCE</em> . Naturellement,
des configurations plus granulaires sont également possibles. Par
exemple, les classes peuvent décrire comment le disque dur doit être
partitionné, elles peuvent définir quels paquets logiciels seront
installés, ou quelles étapes de personnalisation seront exécutées.</p></div>
<div class="paragraph"><p>Souvent, une configuration client est juste créée en modifiant ou en ajoutant
les classes auxquelles ce client appartient, ce qui rend
l’installation d’un nouveau client très facile. Ainsi, aucune
information supplémentaire ne doit être ajoutée à l’espace de
configuration si les classes existantes suffisent à vos besoins.</p></div>
<div class="paragraph"><p>Comme vous pouvez le voir, les classes sont un pilier central de la
personnalisation de votre espace de configuration et de celui de
de votre client d&#8217;installation. Pour définir vos propres classes, reportez-vous à
<a href="#defining classes">[defining classes]</a>.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_id_setup_a_configurer_votre_faiserver"><a id="setup"></a>Configurer votre faiserver</h2>
<div class="sectionbody">
<div class="paragraph"><p>Voici comment configurer le serveur d’installation en quelques minutes.
Les étapes suivantes sont nécessaires :</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Configurer le serveur d’installation
</p>
<div class="olist loweralpha"><ol class="loweralpha">
<li>
<p>
Installer les paquets de FAI
</p>
</li>
<li>
<p>
Créer le nfsroot
</p>
</li>
<li>
<p>
Copier les exemples dans l’espace de configuration
</p>
</li>
<li>
<p>
Configurer les démons réseau
</p>
</li>
<li>
<p>
Créer les configurations PXELINUX
</p>
</li>
</ol></div>
</li>
<li>
<p>
Démarrage et installation des clients
</p>
</li>
</ol></div>
<div class="sect2">
<h3 id="_installer_les_paquets_fai">Installer les paquets FAI</h3>
<div class="ulist"><ul>
<li>
<p>
Installer la clé du dépôt de paquets du projet FAI.
</p>
</li>
<li>
<p>
Ajouter l’URL du dépôt de paquets du projet FAI.
</p>
</li>
<li>
<p>
Installer le paquet <em>fai-quickstart</em> sur le serveur d&#8217;installation.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Utilisez ces commandes pour l&#8217;installation :</p></div>
<div class="listingblock">
<div class="content">
<pre><code># wget -O /etc/apt/trusted.gpg.d/fai-project.gpg https://fai-project.org/download/2BF8D9FE074BCDE4.gpg
# echo "deb http://fai-project.org/download bookworm koeln" &gt; /etc/apt/sources.list.d/fai.list</code></pre>
</div></div>
<div class="paragraph"><p>ou</p></div>
<div class="listingblock">
<div class="content">
<pre><code># apt install extrepo ; extrepo enable fai</code></pre>
</div></div>
<div class="paragraph"><p>et ensuite :</p></div>
<div class="listingblock">
<div class="content">
<pre><code># apt-get update
# aptitude install fai-quickstart</code></pre>
</div></div>
<div class="paragraph"><p>Cela installera également les paquets pour les démons de serveur DHCP,
TFTP et NFS.</p></div>
</div>
<div class="sect2">
<h3 id="_créer_le_nfsroot">Créer le nfsroot</h3>
<div class="ulist"><ul>
<li>
<p>
Activez également le dépôt de paquets du projet FAI dans un
autre fichier <em>sources.list</em> qui est utilisé lors de la construction du
nfsroot. Ensuite, activez l’utilisateur de journal pour FAI.
</p>
</li>
</ul></div>
<div class="literalblock">
<div class="content">
<pre><code># sed -i -e 's/^#deb/deb/' /etc/fai/apt/sources.list
# sed -i -e 's/#LOGUSER/LOGUSER/' /etc/fai/fai.conf</code></pre>
</div></div>
<div class="ulist"><ul>
<li>
<p>
Par défaut, FAI utilise
<a href="http://httpredir.debian.org/">http://httpredir.debian.org/</a> comme miroir
de paquets, qui va tenter de trouver un dépôt de paquets
rapide pour vous.
<span class="footnote"><br />[Si vous voulez un miroir plus rapide, ajustez l&#8217;URL dans
<em>/etc/fai/apt/sources.list</em> et <code>FAI_DEBOOTSTRAP</code> dans
<em>/etc/fai/nfsroot.conf</em> avant de lancer fai-setup.]<br /></span>
Ensuite, on peut lancer <code>fai-setup(8)</code>
<span class="footnote"><br />[Cela invoque <code>fai-make-nfsroot(8)</code> en interne.]<br /></span>
Et vérifiez si tout s’est bien passé. Le fichier de journal est écrit dans
/var/log/fai/fai-setup.log.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content">
<pre><code># fai-setup -v</code></pre>
</div></div>
<div class="ulist"><ul>
<li>
<p>
Voilà quelques-unes des lignes que vous verrez à la fin de fai-setup.
Un exemple complet de <em>fai-setup.log</em> est disponible sur la page web FAI
à  <a href="https://fai-project.org/logs/fai-setup.log">https://fai-project.org/logs/fai-setup.log</a>.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content">
<pre><code>FAI packages and related packages inside the nfsroot:
dracut             059-4
dracut-live        059-4
dracut-network     059-4
dracut-squash      059-4
fai-client         6.2
fai-nfsroot        6.2
fai-setup-storage  6.2
Waiting for background jobs to finish
fai-make-nfsroot finished properly.
Log file written to /var/log/fai/fai-make-nfsroot.log
Adding line to /etc/exports: /srv/fai/config 192.168.33.250/24(async,ro,no_subtree_check)
Adding line to /etc/exports: /srv/fai/nfsroot 192.168.33.250/24(async,ro,no_subtree_check,no_root_squash)
Reloading nfs-kernel-server configuration (via systemctl): nfs-kernel-server.service.

Your initial config space is now located in /srv/fai/config
Please don't forget to fill out the FAI questionnaire after you've finished your project with FAI.

FAI setup finished.
Log file written to /var/log/fai/fai-setup.log</code></pre>
</div></div>
<div class="ulist"><ul>
<li>
<p>
<code>fai-setup</code> a créé le LOGUSER, le nfsroot et a ajouté des lignes
supplémentaires à <em>/etc/exports</em>. Les sous-répertoires ajoutés à
<em>/etc/exports</em> sont exportés via NFS v3, de sorte que tous les clients
d’installation dans le même sous-réseau peuvent les monter via NFS.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_création_de_l_espace_de_configuration">Création de l’espace de configuration</h3>
<div class="paragraph"><p>Installez les exemples simples dans l’espace de configuration
<span class="footnote"><br />[Il n&#8217;est pas nécessaires que ces fichiers appartiennent au compte root.]<br /></span>.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ fai-mk-configspace</code></pre>
</div></div>
<div class="paragraph"><p>Ces exemples contiennent la configuration pour certains hôtes d’exemple.
Selon le nom d’hôte utilisé, votre ordinateur sera configuré comme suit :</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
demohost
</dt>
<dd>
<p>
Une machine qui n’a besoin que d’un petit disque dur. Cette machine
est configurée avec le réseau en tant que client DHCP, et une démo de
compte est créée.
</p>
</dd>
<dt class="hdlist1">
xfcehost
</dt>
<dd>
<p>
Un bureau XFCE est installé, utilisant LVM, et la démo du compte est
créée.
</p>
</dd>
<dt class="hdlist1">
gnomehost
</dt>
<dd>
<p>
  Un bureau GNOME est installé et la démo du compte est créée.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>ubuntuhost::\n"
Un bureau Ubuntu sera installé et la démo du compte est créée.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
autres noms d&#8217;hôtes
</dt>
<dd>
<p>
Les hôtes disposant d’un autre nom d’hôte utiliseront notamment les
classes FAIBASE, DHCPC et GRUB.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Tous les hôtes auront un compte appelé <em>demo</em> avec mot de passe <em>fai</em>. Le
compte root a également le mot de passe <em>fai</em>.</p></div>
<div class="paragraph"><p>Si l’indicateur FAI <code>menu</code> est ajouté, au lieu d’utiliser le nom
d’hôte pour déterminer le type d’installation, un menu est présenté et
l’utilisateur peut choisir un profil pour l’installation.</p></div>
</div>
<div class="sect2">
<h3 id="_configurer_les_démons_réseau">Configurer les démons réseau</h3>
<div class="paragraph"><p>Pour démarrer le client d’installation via PXE, le serveur
d’installation a besoin d’un démon DHCP et d’un démon TFTP fonctionnels.
Le paquet <em>fai-quickstart</em> a déjà installé les paquets logiciels
pour ces démons. En outre, le paquet du serveur NFS pour
l’exportation du nfsroot et de l’espace de configuration a été installé.</p></div>
<div class="sect3">
<h4 id="_a_id_bootdhcp_a_configuration_du_démon_dhcp"><a id="bootdhcp"></a>Configuration du démon DHCP</h4>
<div class="paragraph"><p>Idéalement, votre faiserver doit également être votre serveur DHCP. Si ce
n’est pas le cas, demandez à l’administrateur responsable du serveur
DHCP de le configurer conformément à cette section. Il est
possible d&#8217;éviter cela optionnellement en utilisant la fonctionnalité
<a href="#autodiscover">[autodiscover]</a> diffusée dans FAI 5.0.</p></div>
<div class="paragraph"><p>Un exemple pour <code>dhcpd.conf(5)</code> est fourni avec le paquet <em>fai-doc</em>.
Commencez à utiliser cet exemple et regardez toutes les options qui y
sont utilisées.</p></div>
<div class="listingblock">
<div class="content">
<pre><code># cp /usr/share/doc/fai-doc/examples/etc/dhcpd.conf /etc/dhcp/</code></pre>
</div></div>
<div class="paragraph"><p>Les seules informations spécifiques FAI contenues dans ce fichier de
configuration sont d&#8217;assigner <code>filename</code> (DHCP option 67) à la valeur <code>fai/pxelinux.0</code> et
d&#8217;assigner <code>next-server</code> (DHCP option 66, also aussi nommée TFTP server name) et <code>server-name</code>
à la valeur du nom de votre serveur d’install . Toutes les autres informations sont uniquement des
données liées au réseau, qui sont utilisées dans presque toutes les
configurations DHCP. Ajustez ces paramètres de réseau à vos besoins locaux.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>deny unknown-clients;
option dhcp-max-message-size 2048;
use-host-decl-names on;

subnet 192.168.33.0 netmask 255.255.255.0 {
   option routers 192.168.33.250;
   option domain-name "my.example";
   option domain-name-servers 192.168.33.250;
   option time-servers faiserver;
   option ntp-servers faiserver;
   server-name faiserver;
   next-server faiserver;
   filename "fai/pxelinux.0";
}</code></pre>
</div></div>
<div class="paragraph"><p>Si vous apportez des modifications à la configuration DHCP, vous devez
redémarrer le démon.</p></div>
<div class="listingblock">
<div class="content">
<pre><code># invoke-rc.d isc-dhcp-server restart</code></pre>
</div></div>
<div class="paragraph"><p>Si vous disposez de plusieurs interfaces réseau, vous pouvez définir
l’interface que le serveur écoutera dans <em>/etc/default/isc-dhcp-server</em>.
Par défaut, le démon DHCP écrit ses messages de journalisation dans
<em>/var/log/daemon.log</em>.</p></div>
</div>
<div class="sect3">
<h4 id="_ajout_d_une_entrée_d_hôte_au_dhcp">Ajout d’une entrée d’hôte au DHCP</h4>
<div class="paragraph"><p>L’adresse MAC est donnée par le matériel de la carte réseau. Pour chaque
client d’installation, vous collectez son adresse MAC et l&#8217;associez à une
adresse IP et à un nom d’hôte. Tout d’abord, nous ajoutons l’adresse IP
et le nom d’hôte à <em>/etc/hosts</em> <span class="footnote"><br />[On peut aussi ajouter cela dans son serveur de noms de domaine (DNS)]<br /></span>.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>192.168.33.100    demohost</code></pre>
</div></div>
<div class="paragraph"><p>L&#8217;association de l’adresse MAC à l’adresse IP est effectuée dans le fichier
<em>dhcpd.conf</em>. Ici, nous ajoutons une entrée d’hôte en utilisant la
commande <code>+dhcp-edit(8)+</code> . Ici, vous devez remplacer 01:02:03:AB:CD:EF
avec l&#8217;adresse MAC que vous avez trouvé.</p></div>
<div class="listingblock">
<div class="content">
<pre><code># dhcp-edit demohost 01:02:03:AB:CD:EF</code></pre>
</div></div>
<div class="paragraph"><p>Après l&#8217;invocation de cette commande, voici à quoi l&#8217;entrée d&#8217;hôte dans
<em>dhcpd.conf</em> ressemblera :</p></div>
<div class="listingblock">
<div class="content">
<pre><code>host demohost {hardware ethernet 01:02:03:AB:CD:EF;fixed-address demohost;}</code></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_tftp">TFTP</h4>
<div class="paragraph"><p>Normalement, vous n’avez pas besoin d’apporter de modifications à la
configuration démon TFTP. Les fichiers fournis par TFTP sont situés
dans <em>/srv/tftp/fai</em>.</p></div>
</div>
<div class="sect3">
<h4 id="_nfs">NFS</h4>
<div class="paragraph"><p>La commande <code>fai-setup</code> a déjà configuré le démon NFS et ajouté
quelques lignes au fichier de configuration <em>/etc/exports</em>. Il exporte
les répertoires en utilisant NFS v3.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_création_de_la_configuration_pxelinux">Création de la configuration PXELINUX</h3>
<div class="paragraph"><p>La dernière étape avant de démarrer votre client pour la première fois
est de spécifier quelle configuration le client doit démarrer lors de
l’amorçage PXE. Nous utilisons la commande <code>fai-chboot(8)</code> pour
créer une configuration pxelinux pour chaque client d’installation. Cela
comprend des informations sur le noyau, le fichier initrd, l’espace de
configuration et certains paramètres d’amorçage. Vous devriez lire la
page de manuel, qui vous donne quelques bons exemples. Voici la commande
pour démarrer l’installation de l’hôte demohost.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ fai-chboot -IFv -u nfs://faiserver/srv/fai/config demohost

Booting kernel vmlinuz-4.19.0-5-amd64
 append initrd=initrd.img-4.19.0-5-amd64 ip=dhcp
   FAI_FLAGS=verbose,sshd,createvt FAI_CONFIG_SRC=nfs://faiserver/srv/fai/config

demohost has 192.168.33.100 in hex C0A82164
Writing file /srv/tftp/fai/pxelinux.cfg/C0A82164 for demohost</code></pre>
</div></div>
<div class="paragraph"><p>À ce stade, vous devriez avoir une configuration faiserver de travail et
vos clients devraient démarrer dans FAI et être en mesure d’installer
l’un des exemples.</p></div>
<div class="paragraph"><p>Dans la section suivante, vous pouvez lire la planification de votre
installation, adapter votre espace de configuration à vos besoins
particuliers et étendre FAI à l’aide de hooks.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_custom_server_a_serveur_personnalisé"><a id="custom server"></a>Serveur personnalisé</h3>
<div class="paragraph"><p>Le faiserver et sa configuration n’est nullement statique. Il est possible
de personnaliser et d&#8217;étendre votre serveur. Pour cela, reportez-vous à
la section<a href="#Customizing your install server setup">[Customizing your install server setup]</a> dans <a href="#advanced">[advanced]</a>."</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_id_plan_a_planifiez_votre_installation"><a id="plan"></a>Planifiez votre installation</h2>
<div class="sectionbody">
<div class="paragraph"><p>Avant de commencer votre installation, vous devriez investir beaucoup de
temps dans la planification de votre installation. Une fois que vous
êtes satisfait de votre concept d’installation, FAI peut faire toutes
les tâches ennuyeuses et répétitives pour transformer vos plans en
réalité. FAI ne peut pas faire de bonnes installations si votre concept
est imparfait ou qu&#8217;il y manque quelques détails importants. Commencez à
planifier l’installation en répondant aux questions suivantes :</p></div>
<div class="ulist"><ul>
<li>
<p>
Est-ce que je vais créer un cluster Beowulf ou dois-je installer des machines de bureau ?
</p>
</li>
<li>
<p>
À quoi ressemble ma topologie LAN ?
</p>
</li>
<li>
<p>
Ai-je un matériel uniforme ? Le matériel sera-t-il uniforme à l’avenir ?
</p>
</li>
<li>
<p>
Le matériel a-t-il besoin d’un noyau spécial ?
</p>
</li>
<li>
<p>
Comment nommer les hôtes ?
</p>
</li>
<li>
<p>
Comment les disques durs locaux doivent-ils être partitionnés ?
</p>
</li>
<li>
<p>
Quelles applications seront lancées par les utilisateurs ?
</p>
</li>
<li>
<p>
Les utilisateurs ont-ils besoin d’un système de mise en file d’attente ?
</p>
</li>
<li>
<p>
Quels logiciels faut-il installer ?
</p>
</li>
<li>
<p>
Quels démons devraient être lancés, et à quoi devrait ressembler leur configuration ?
</p>
</li>
<li>
<p>
Quels systèmes de fichiers distants doivent être montés ?
</p>
</li>
<li>
<p>
Comment effectuer les sauvegardes ?
</p>
</li>
</ul></div>
<div class="paragraph"><p>Vous devez également penser à des comptes d’utilisateur, des
imprimantes, un système de courrier, des travaux de cron, des cartes
graphiques, au double amorçage, au NIS, au NTP, au fuseau horaire,
à la disposition de clavier, à l’exportation et au montage des annuaires via
NFS et à beaucoup d’autres choses. Donc, il ya beaucoup à faire avant de
commencer une installation. Et rappelez-vous que la connaissance est le
pouvoir, et c’est à vous de l’utiliser. L’installation et
l’administration sont un processus et non un produit. FAI ne peut pas
faire les choses que vous ne lui dites pas de faire.</p></div>
<div class="paragraph"><p>Mais vous ne devez pas commencer à partir de zéro. Examinez les fichiers
et les scripts dans l’espace de configuration. Il ya beaucoup de choses
que vous pouvez utiliser pour votre propre installation. Un bon article
intitulé « Bootstrapping an Infrastructure » avec d’autres aspects de la
construction d’une infrastructure est disponible sur
<a href="http://www.infrastructures.org/papers/bootstrap/bootstrap.html">http://www.infrastructures.org/papers/bootstrap/bootstrap.html</a></p></div>
<div class="sect2">
<h3 id="_a_id_c3_a_l_espace_de_configuration_et_ses_sous_répertoires"><a id="c3"></a>L’espace de configuration et ses sous-répertoires</h3>
<div class="paragraph"><p>L&#8217;espace de configuration est la collection des informations qui disent comment exactement
configurer un client. L&#8217;espace central de configuration pour tous les clients
d&#8217;installation est situé sur le serveur d&#8217;installation dans <em>/srv/fai/config</em> et ses
sous-répertoires. Il sera monté par les clients sous
<em>/var/lib/fai/config</em>. La commande princpale d&#8217;installation <code>fai(8)</code> utilise tous
ces sous-répertoires dans l&#8217;ordre listé sauf pour les hooks.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<em>class/</em>
</dt>
<dd>
<p>
Scripts et fichiers pour définir des classes et des variables.
</p>
</dd>
<dt class="hdlist1">
<em>disk_config/</em>
</dt>
<dd>
<p>
Fichiers de configuration pour le partitionnement de disque, RAID
logiciel, LVM et création de système de fichiers.
</p>
</dd>
<dt class="hdlist1">
<em>basefiles/</em>
</dt>
<dd>
<p>
Normalement , le fichier <em>base.tar.xz</em> (situé à l&#8217;intérieur du
nfsroot) est extrait sur le client d’installation après la création
des nouveaux systèmes de fichiers et avant l’installation des paquets.
Il s’agit d’une image de base minimale, créée juste après avoir appelé
debootstrap lors de la création du nfsroot sur le serveur
d’installation. Si vous voulez installer une autre distribution que celle
du nfsroot, vous pouvez mettre un fichier tar dans le sous-répertoire
<em>basefiles/</em> et le nommer selon une classe. Ensuite, la commande
<code>ftar(8)</code> est utilisée pour extraire le fichier tar en fonction des
classes définies. Ainsi, le fichier doit être nommé <em>CLASS.tar.xz</em>
et non <em>CLASS.base.tar.xz</em>. Cela se fait dans la tâche <em>extrbase</em>.
Utilisez cette option si vous souhaitez installer une autre
distribution ou une version différente de celle exécutée pendant
l’installation.
</p>
<div class="paragraph"><p>Ce fichier de base peut également être reçu en fonction des classes
FAI via HTTP/HTTPS ou FTP en définissant la variable <code>FAI_BASEFILEURL</code>. FAI
téléchargera un fichier CLASSNAME.tar.xz (ou tgz, ou tar.gz, …) à
partir de cette URL, si <code>CLASSNAME</code> correspond à une classe FAI.</p></div>
<div class="paragraph"><p>Exemple :</p></div>
</dd>
</dl></div>
<div class="listingblock">
<div class="content">
<pre><code>FAI_BASEFILEURL=https://fai-project.org/download/basefiles/</code></pre>
</div></div>
<div class="paragraph"><p>Le dossier doit prendre en charge la liste des répertoires. FAI ne
recherchera pas de fichiers potentiellement correspondants.</p></div>
<div class="paragraph"><p>Voir le chapitre <a href="#otherdists">[otherdists]</a> pour savoir comment
installer différentes distributions.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<em>debconf/</em>
</dt>
<dd>
<p>
Ce répertoire contient toutes les données <code>debconf(7)</code>. Le format
est le même que celui utilisé par <code>debconf-set-selections(1)</code>.
</p>
</dd>
<dt class="hdlist1">
<em>package_config/</em>
</dt>
<dd>
<p>
Les fichiers avec des noms de classe contiennent des listes de
paquets à installer ou à désinstaller par
<code>install_packages(8)</code>. Les fichiers nommés <em>&lt;CLASS&gt;.gpg</em> sont ajoutés à la liste des clés utilisées par apt
pour les dépôts de paquets approuvés.
</p>
</dd>
<dt class="hdlist1">
<em>pkgs/</em>
</dt>
<dd>
<p>
Ce répertoire peut avoir des sous-répertoires nommés selon des classes. Vous pouvez
mettre des fichiers <em>.deb</em> ou <em>.rpm</em> dans ces sous-répertoires. FAI installera
ces paquets sans qu&#8217;il soit besoin de créer les métadonnées d&#8217;un dépôt de paquets.
</p>
</dd>
<dt class="hdlist1">
<em>scripts/</em>
</dt>
<dd>
<p>
Scripts pour la personnalisation de votre site local. Utilisé par
<code>fai-do-scripts(1)</code>.
</p>
</dd>
<dt class="hdlist1">
<em>files/</em>
</dt>
<dd>
<p>
Les Fichiers utilisés par les scripts de personnalisation. La plupart
des fichiers se trouvent dans un sous-répertoire qui
reflète l’arborescence de répertoires ordinaire. Par exemple, les
modèles de <code>_nsswitch.conf_</code> se trouvent dans
<em>$FAI/files/etc/nsswitch.conf</em> et sont nommés en fonction des classes
auxquelles ils doivent correspondre :
<em>$FAI/files/etc/nsswitch.conf/NIS</em> est la version de
<em>/etc/nsswitch.conf</em> à utiliser pour la classe NIS. Notez que le
contenu du répertoire n’est pas automatiquement copié sur la machine
cible, mais qu’il doit être explicitement copié par des scripts de
personnalisation à l’aide de la commande <code>fcopy(8)</code>.
</p>
</dd>
<dt class="hdlist1">
<em>hooks/</em>
</dt>
<dd>
<p>
Les hooks sont des programmes ou des scripts définis par
l’utilisateur, qui sont lancés pendant le processus d’installation.
Ils peuvent étendre ou remplacer les tâches par défaut. Le nom du
fichier doit être de format <em>taskname.CLASSNAME[.sh]</em>. Un hook appelé
<code>updatebase.DEBIAN</code> est exécuté avant la tâche
<code>updatebase</code> et seulement si l’installation du client fait partie de
la classe DEBIAN.
</p>
</dd>
</dl></div>
</div>
<div class="sect2">
<h3 id="_a_id_defining_classes_a_définition_des_classes"><a id="defining classes"></a>Définition des classes</h3>
<div class="paragraph"><p>Il existe différentes possibilités pour définir des classes :</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Certaines classes par défaut sont définies pour chaque hôte : DEFAULT, LAST et son nom d’hôte.
</p>
</li>
<li>
<p>
Les classes peuvent être répertoriées dans un fichier (par défaut dans <em>class/&lt;hostname&gt;</em>).
</p>
</li>
<li>
<p>
Les classes peuvent être dynamiquement définies par des scripts.
</p>
</li>
</ol></div>
<div class="paragraph"><p>La dernière option est une fonctionnalité très intéressante, puisque ces
scripts définiront des classes d&#8217;une façon très souple. Par exemple,
plusieurs classes peuvent être définies uniquement si certains matériels
sont identifiés ou si une classe est définie en fonction des
informations du sous-réseau.</p></div>
<div class="paragraph"><p>Tous les noms de classes, sauf le nom d’hôte, sont écrits en
majuscules. Ils ne doivent pas contenir de trait d’union, de dièse, de
point-virgule ni de point, mais peuvent contenir des caractères de
soulignement et des chiffres.</p></div>
<div class="paragraph"><p>La tâche <em>defclass</em> appelle la commande <code>fai-class(1)</code> pour définir
les classes. Tous les scripts correspondant à l&#8217;expression <em>^[0-9][0-9]*</em> (qui
commencent avec deux chiffres) Dans le sous-repertoire <em>$FAI/class</em> sont
exécutés afin de définir les classes. Tout ce qui is affiché sur STDOUT
est automatiquement defini comme une classe. Pour plus d’informations
sur Les définitions de classe , lire les pages de manuel de
<code>fai-class(1)</code>. Le script <em>50-host-classes</em> (voir ci - dessous la
version allégée) est utilisé pour les définir des classes en fonction du
nom d’hôte.</p></div>
<div class="listingblock">
<div class="content">
<pre><code># use a list of classes for our demo machines
case $HOSTNAME in
    demohost)
        echo "FAIBASE GRUB DEMO" ;;
    xfcehost)
        echo "FAIBASE GRUB DEMO XORG XFCE LVM";;
    faiserver)
        echo "FAIBASE DEBIAN DEMO FAISERVER" ;;
    ubuntuhost)
        echo "FAIBASE DEBIAN DEMO UBUNTU JAMMY JAMMY64 XORG";;
    *)
        echo "FAIBASE DEBIAN DEMO" ;;
esac</code></pre>
</div></div>
<div class="paragraph"><p>Les noms d’hôtes doivent rarement être utilisé pour les fichiers de
configuration dans l’espace de configuration. Au lieu de ça, une classe doit
être définie et ensuite ajoutée pour un hôte donné. En effet, la plupart
du temps les données de configuration ne sont pas spécifiques à un nom
d&#8217;hôte, mais peuvent être partagées entre différents hôtes.</p></div>
<div class="paragraph"><p>L’ordre des classes est important car celui-ci définit la priorité des
classes de faible à élevée.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_classvariables_a_définition_des_variables"><a id="classvariables"></a>Définition des Variables</h3>
<div class="paragraph"><p>La tâche <em>defvar</em> definit les variables pour le client d&#8217;installation.
Les variables sont définies par les scripts dans <em>class/*.var</em>.
Toutes les variables globales peuvent être définies dans <em>DEFAULT.var</em>.
Pour un groupe d’hôtes utiliser un fichier de classe. Pour un
hôte seul, utiliser le Fichier <code>$HOSTNAME</code> <em>.var</em>. Ici aussi, il est
utile d&#8217;étudier tous les exemples.</p></div>
<div class="paragraph"><p>Les variables suivantes sont utilisées dans les exemples et peuvent aussi être
utiles pour votre installation :</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
FAI_ACTION
</dt>
<dd>
<p>
Configure les actions que doit effectuer FAI. Normalement, ceci se fait
par <code>fai-chboot(8)</code>. Si vous ne pouvez pas utiliser cette commande,
définissez cette variable dans le script <em>LAST.var</em>.
</p>
</dd>
<dt class="hdlist1">
FAI_ALLOW_UNSIGNED
</dt>
<dd>
<p>
Si cette variable vaut 1, FAI permet l’installation de paquets à partir de
dépôts non signés.
</p>
</dd>
<dt class="hdlist1">
CONSOLEFONT
</dt>
<dd>
<p>
La police de caractères qui est chargée lors de l’installation par
<code>setfont(8)</code>.
</p>
</dd>
<dt class="hdlist1">
KEYMAP
</dt>
<dd>
<p>
Définit les fichiers de disposition du clavier dans <em>/usr/share/keymaps</em>
et <em>$FAI/files</em>. Vous n&#8217;avez pas besoin de spécifier le chemin complet,
car ce fichier sera localisé automatiquement.
</p>
</dd>
<dt class="hdlist1">
ROOTPW
</dt>
<dd>
<p>
Le mot de passe root chiffré pour le nouveau système. Vous pouvez
utiliser
<code>crypt(3)</code>, md5 et d’autres types de hachage pour le mot de passe. Utilisez 'mkpasswd(1)+`
pour créer le hachage d’un mot de passe donné. Par exemple, pour
générer le hachage MD5 un mot de passe, utilisez :
</p>
</dd>
</dl></div>
<div class="literalblock">
<div class="content">
<pre><code>$ echo "votre_mot_secret" | mkpasswd -m yescrypt -s</code></pre>
</div></div>
<div class="dlist"><dl>
<dt class="hdlist1">
UTC
</dt>
<dd>
<p>
Règle l’horloge matérielle à UTC si <em>UTC=yes</em>. Sinon, règle
l’horloge à l’heure locale. Voir <code>clock(8)</code> pour plus
d’informations.
</p>
</dd>
<dt class="hdlist1">
TIMEZONE
</dt>
<dd>
<p>
C&#8217;est le fichier sous <em>/usr/share/zoneinfo/</em> qui indique votre
fuseau horaire. Par exemple : <em>TIMEZONE=Europe/Berlin</em>.
</p>
</dd>
<dt class="hdlist1">
MODULESLIST
</dt>
<dd>
<p>
Une liste des modules du noyau qui sont chargés pendant le démarrage
du nouveau système (écrits dans /etc/modules).
</p>
</dd>
</dl></div>
</div>
<div class="sect2">
<h3 id="_a_id_diskconfig_a_configuration_du_disque_dur"><a id="diskconfig"></a>Configuration du disque dur</h3>
<div class="paragraph"><p>L’outil <code>setup-storage(8)</code> lit un fichier dans <em>$FAI/disk_config</em> pour
la configuration du disque. Ce fichier décrit comment tous les disques
Locaux seront partitionnés, quels types de systèmes de fichiers
doivent etre créés (comme ext3/4, xfs, btrfs), et où ils seront montés.
Vous pouvez aussi créer des configurations RAID logiciel et LVM en
utilisant ce fichier de configuration. Il est aussi possible de préserver
le partitionnement du disque ou de préserver les
données sur certaines partitions.</p></div>
<div class="paragraph"><p>Pendant le processus d’installation, tous les systèmes de fichiers
locaux sont montés sous le répertoire <em>/target</em>. Par exemple, si vous
spécifiez le point de montage <em>/home</em> dans un fichier de configuration
de disque, ce sera le répertoire <em>/target/home</em> pendant le processus
d’installation et ça deviendra <em>/home</em> pour le nouveau système installé.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_extrbase_a_extraction_du_fichier_de_base"><a id="extrbase"></a>Extraction du fichier de base</h3>
<div class="paragraph"><p>Un fichier de base n&#8217;est nécessaire que si on installe une distribution qui est
défférente de celle dans le nfsroot.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_debconf_a_pré_ensemencement_debconf"><a id="debconf"></a>Pré-ensemencement Debconf</h3>
<div class="paragraph"><p>On peut utiliser le fomat décrit dans <code>debconf-set-selections(1)</code>.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_repository_a_accès_au_dépôt_de_paquets"><a id="repository"></a>Accès au dépôt de paquets</h3>
<div class="paragraph"><p>FAI supporte http, https, et NFS pour l&#8217;accès au miroir de paquets. Réglez
la variable <em>$FAI_DEBMIRROR</em> pour l&#8217;utilisation de NFS.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_packageconfig_a_configuration_des_paquets_logiciels"><a id="packageconfig"></a>Configuration des paquets logiciels</h3>
<div class="paragraph"><p>Avant l’installation de paquets, FAI va ajouter le contenu de tous
les fichiers nommés <em>package_config/class.gpg</em> à la liste des clés apt.
Si votre dépôt local est signé par votre keyid AB12CD34 vous pouvez
facilement ajouter cette clé, ainsi FAI l’utilisera pendant
l’installation. Utilisez cette commande pour créer le fichier
<em>CLASS.gpg</em> :</p></div>
<div class="listingblock">
<div class="content">
<pre><code>faiserver$ gpg --export AB12CD34 &gt; /srv/fai/config/package_config/MYCLASS.gpg</code></pre>
</div></div>
<div class="paragraph"><p>Le script <code>install_packages(8)</code> installe les logiciels sélectionnés.
Il lira tous les fichiers de configuration Dans <em>$FAI/package_config</em>
dont le nom correspond à une classe définie. La syntaxe est très simple.</p></div>
<div class="listingblock">
<div class="content">
<pre><code># an example package class

PACKAGES taskinst
german

PACKAGES install-norec
adduser nmap
less zstd

PACKAGES remove
gpm xdm

PACKAGES install GRUB_PC
grub-pc</code></pre>
</div></div>
<div class="paragraph"><p>Les commentaires commencent par une dièse (#) et se terminent à la fin de la
ligne. Chaque commande de paquet commence par le mot <em>PACKAGES</em> suivi
par un nom de commande, qui correspond à gestionnaire de paquets
distinct comme apt-get, aptitude ou dnf par exemple. la commande définit quelle
commande sera utilisé pour installer les paquets nommés après
cette commande. La liste de toutes les commandes disponibles peut
être listée en utilisant <em>install_packages -H</em>. Les gestionnaires de paquets pris
en charges sont <em>aptitude, apt-get, smart, yast, dnf, rpm, zypper</em></p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
hold
</dt>
<dd>
<p>
Mettre un paquet en attente. Ce paquet ne sera pas pris en charge par
dpkg, pas exemple il ne sera pas mis à niveau.
</p>
</dd>
<dt class="hdlist1">
install
</dt>
<dd>
<p>
Pour installer tous les paquets (en utilisant <code>apt-get</code>) qui sont précisés
dans les lignes suivantes. Si un tiret est ajouté au nom du paquet
(sans espace intermédiaire), le paquet sera supprimé, pas installé.
Tous les noms de paquets sont vérifiées pour les fautes de frappe.
Tout paquet qui n’existe pas, sera retiré de la liste des paquets à
installer. Soyez donc attentif à ne pas mal orthographier les
noms de paquets.
</p>
</dd>
<dt class="hdlist1">
install-norec
</dt>
<dd>
<p>
Comme install, mais sans installer les paquets recommandés.
</p>
</dd>
<dt class="hdlist1">
remove
</dt>
<dd>
<p>
Supprimer tous les paquets qui sont pécisés dans les lignes suivantes.
Si on ajoute un + au nom du paquet, le paquet doit être installé.
</p>
</dd>
<dt class="hdlist1">
taskinst
</dt>
<dd>
<p>
Installer tous les paquets appartenant aux tâches qui sont spécifiées
dans les lignes suivantes à l’aide de <code>tasksel(1)</code>. Vous pouvez
aussi utiliser <em>aptitude</em> pour installer les tâches.
</p>
</dd>
<dt class="hdlist1">
aptitude
</dt>
<dd>
<p>
Installer tous les paquets avec la commande <code>aptitude</code>. Ce sera la
valeur par défaut à l’avenir et pourra remplacer apt-get et taskinst.
Aptitude peut aussi installer les tâches de paquets.
</p>
</dd>
<dt class="hdlist1">
aptitude-r
</dt>
<dd>
<p>
Idem aptitude avec l’option <em>--with-recommends</em>.
</p>
</dd>
<dt class="hdlist1">
unpack
</dt>
<dd>
<p>
Télécharger les paquets et les décompresser seulement. Ne pas configurer les
paquets.
</p>
</dd>
<dt class="hdlist1">
dselect-upgrade
</dt>
<dd>
<p>
Definir des sélections des paquets en utilisant les lignes suivantes puis
installer ou supprimer les paquets précisés. Ces lignes sont le résultat
de la commande <em>dpkg --get-selections</em>. Il est recommandé de ne pas
utiliser ce format, puisque cela spécifie aussi tous les
paquets qui sont installés seulement en raison d’une dépendance ou
d&#8217;une recommandation. Il vaut mieux juste spécifier le paquet que vous
voulez avoir, et de laisser FAI (et apt-get) résoudre les dépendances.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Plusieurs lignes avec des listes de noms de paquets séparés par des
espaces suivent les directive PACKAGES. Toutes les dépendances sont
résolues. Les paquets avec suffixe <em>-</em> (par exemple, <em>lilo-</em>) seront
supprimés au lieu d&#8217;être installés. L’ordre des paquet n’a pas
d’importance. Si vous souhaitez installer des paquets d’une autre
version que la valeur par défaut, vous pouvez ajouter le nom de la
version au nom du paquet comme dans <em>openoffice.org/etch-backports</em>.
Vous pouvez également spécifier une certaine version comme <em>apt=0.3.1</em>.
Plus d’informations sur ces fonctionnalités sont décrites dans
<code>aptitude(8)</code>.</p></div>
<div class="paragraph"><p>On peut spécifier des paramètres supplémentaires pour le gestionnaire de paquets
en ajoutant des paires <em>cle=valeur</em> après <em>PACKAGES &lt;commande&gt;</em>. les paires clé, valeur
actuellement supportées sont <em>release=&lt;nom&gt;</em> qui ajoute <em>-t &lt;nom&gt;</em> durant
l&#8217;installation des paquets.</p></div>
<div class="paragraph"><p>Exemple:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>PACKAGES install-norec release=testing
nvidia-smi</code></pre>
</div></div>
<div class="paragraph"><p>Cela installerait le paquet nvidia-smi  de la distribution testing,
en incluant les dépendances. N&#8217;oubliez pas d&#8217;ajouter une entrée dans
<em>sources.list</em>. Vous pouvez aussi vouloir ajuste l&#8217;épinglage apt (apt pinning)
(voir <em>apt_references(5)</em>)</p></div>
<div class="paragraph"><p>Une ligne qui contient la commande <em>PRELOADRM</em>, télécharge un fichier à
l’aide de <code>wget(1)</code> dans un répertoire avant d’installer les paquets.
À l’aide d&#8217;une URL de type <em>file:</em>, ce fichier est copié de <code>$FAI_ROOT</code> vers le
répertoire de téléchargement. Par exemple, le paquet <code>realplayer</code> a
besoin d’une archive pour installer le logiciel, donc cette archive est
téléchargée dans le répertoire <em>/root</em>. Après l’installation des
paquets, ce fichier sera supprimé. Si le fichier ne doit pas être
supprimé, utilisez plutôt la commande <em>PRELOAD</em>.</p></div>
<div class="paragraph"><p>On peut ajouter une expression booléenne arbitraire qui utilise des classes FAI pour
définir quand la liste des paquets devrait être installée. Ici, les
paquets seront installés seulement si la classe XORG est définie mais la classe
MINT n&#8217;est pas définie.</p></div>
<div class="paragraph"><p>Exemple:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>PACKAGES install UBUNTU &amp;&amp; XORG &amp;&amp; ! MINT
ubuntu-standard
ubuntu-desktop</code></pre>
</div></div>
<div class="paragraph"><p>L&#8217;ancienne façon d&#8217;ajouter des expressions logiques dans les lignes PACKAGES est encore valable :
Il est possible d&#8217;ajouter une liste de noms de classes après la commande pour
apt-get. Ainsi une telle commande <em>PACKAGES</em> sera exécutée seulement au moins
une des classes correspondantes est définie (OU logique). On peut donc combiner
plusieurs petits fichiers dans le fichier DEFAULT.</p></div>
<div class="paragraph"><p>Si vous souhaitez supprimer un nom de paquet d’une certaine classe
faisait partie de cette classe précédemment, vous ne devez pas supprimer le
nom du paquet classe, mais plutôt de lui ajouter un tiret (-). Cela
garantira que le paquet soit enlevé pendant une mise a jour sur des hôtes
qui étaient installés en utilisant l’ancienne définition de classe qui
comprenait ce nom de paquet.</p></div>
<div class="paragraph"><p>Si vous spécifiez un paquet qui n’existe pas, ce paquet sera supprimé
automatiquement de la liste d’installation uniquement si la commande
<em>install</em> est utilisée.</p></div>
<div class="paragraph"><p>Le concept de priorité des classes permet à une classe de priorité plus élevée (qui
arrive plus tard dans la séquence des classes) d&#8217;écraser les sélections des
paquets de priorité plus basse. Pour que cela fonctionne correctement,
les classes de priorité plus élevée doivent utiliser les mêmes commandes <em>PACKAGES</em> (par exemple
<em>PACKAGES install-norec</em> au lieu de seulement <em>PACKAGES install</em>) que celles qu&#8217;utilisent
la classe qu&#8217;on essaie d&#8217;écraser. Cela est utile pour supprimer
l&#8217;installation d&#8217;un paquet, par exemple, pour éviter d&#8217;installer le paquet
<em>linuxlogo</em> installé par la classe FAIBASE :</p></div>
<div class="listingblock">
<div class="content">
<pre><code># exemple montrant comment écraser :
#
# Dans FAIBASE il y a :
#    PACKAGES install-norec
#    linuxlogo
#
# On veut _ne pas_ installer linuxlogo, et il se trouve dans
# une section install-norec, donc il faut aussi utiliser install-norec.

PACKAGES install-norec
linuxlogo-</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_a_id_cscripts_a_scripts_de_personnalisation"><a id="cscripts"></a>Scripts de personnalisation</h3>
<div class="paragraph"><p>La commande <code>fai-do-scripts(1)</code> est lancée pour exécuter tous les
scripts dans ce répertoire. Si un répertoire avec un nom de classe
existe, tous les scripts correspondant à l&#8217;expression <em>^[0-9][0-9]*</em> sont exécutés
par ordre alphabétique. Il est donc possible d’utiliser des scripts de
différentes langages (shell, cfengine, Perl, Python, Ruby, expect,..)
pour une classe.</p></div>
<div class="paragraph"><p>Ces scripts écrivent leur sortie standard dans scripts.log. Le fichier status.log
contient les noms de tous les scripts exécutés et leur statut de terminaison.</p></div>
<div class="sect3">
<h4 id="_a_id_shell_a_scripts_shell"><a id="shell"></a>Scripts shell</h4>
<div class="paragraph"><p>La plupart des scripts sont des scripts Bourne shell. Les scripts shell
sont utiles si la tâche de configuration n&#8217;a besoin d&#8217;appeler que
quelques commandes shell ou créer un fichier à partir de zéro. Afin d&#8217;éviter
d&#8217;écrire beaucoup de scripts courts, il est possible d’utiliser la
commande <code>ifclass</code> pour tester si certaines classes sont définies.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>ifclass -o A B C</code></pre>
</div></div>
<div class="paragraph"><p>Vérifie si l’une des classes A, B ou C est définie. L’utilisation de -a
(ET, AND logique) vérifie si toutes les classes d’une liste sont définies.
La commande <em>ifclass C</em> vérifie si seule la classe C est définie.</p></div>
<div class="paragraph"><p>Pour copier des fichiers avec des classes, utilisez la commande
<code>fcopy(8)</code>. Si vous voulez extraire une archive à l’aide de classes,
utilisez <code>ftar(8)</code>. Pour ajouter des lignes à un fichier de
configuration, utilisez <code>ainsl(1)</code> au lieu de simplement
<code>echo string &gt;&gt; filename</code>.</p></div>
<div class="paragraph"><p>FAI prend également en charge les scripts <em>zsh(1)</em> pendant la tâche de
personnalisation. Dans les scripts, la variable <code>$classes</code> contient
une liste séparée par des espaces avec les noms de toutes les classes
définies.</p></div>
</div>
<div class="sect3">
<h4 id="_a_id_cfengine_a_scripts_cfengine"><a id="cfengine"></a>Scripts cfengine</h4>
<div class="paragraph"><p>CFEngine dispose d’un riche ensemble de fonctions pour modifier les
fichiers de configuration existants, par exemple <em>LocateLineMatching,
ReplaceAll, InsertLine, AppendIfNoSuchLine, HashCommentLinesContaining</em>.
Mais il ne peut pas traiter les variables qui sont indéfinies. Si une
variable n’est pas définie, l’ensemble du script cfengine s’arrêtera.</p></div>
<div class="paragraph"><p>On peut trouver plus d’informations dans la page de manuel
<code>cfengine(8)</code> ou sur la page d’accueil de cfengine
<a href="https://www.cfengine.com">https://www.cfengine.com</a>.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_a_id_hooks_a_les_hooks_les_crochets"><a id="hooks"></a>Les hooks, les « crochets »</h3>
<div class="paragraph"><p>Les crochets (hooks) vous permettent de spécifier des fonctions ou des programmes
qui sont exécutés à certaines étapes du processus d’installation. Avant
qu’une tâche soit appelée, FAI recherche les crochets existants pour cette
tâche et les exécute. Comme on peut s’y attendre, les classes sont
également utilisées lors de l’appel de hooks. Les hooks sont exécutés
pour chaque classe définie. Il vous suffit de créer le hook avec le nom
de la classe désirée et il sera utilisé. Si plusieurs hooks pour une
tâche existent, ils sont appelés dans l’ordre défini par les classes. Si
<em>debug</em> est inclus dans <code>$FAI_FLAG</code> l’option <em>-d</em> est passée à tous
les hooks, donc vous pouvez déboguer vos propres hooks. Si certaines
tâches par défaut doivent être ignorées, utilisez la sous-routine
<em>skiptask</em> et une liste de tâches par défaut comme paramètres. Dans les
exemples fournis, les hooks de la classe CENTOS ignorent certaines
tâches spécifiques de Debian.</p></div>
<div class="paragraph"><p>Le répertoire <em>$FAI/hooks/</em> contient tous les hooks. Un hook est un
fichier exécutable qui est nommé selon la tâche : <em>taskname.CLASSNAME[.sh]</em>
(par exemple, <em>repository.CENTOS</em> ou <em>savelog.LAST.sh</em>). Le nom de tâche
spécifie quelle tâche précède l&#8217;exécution de ce hook, si la
classe spécifiée est définie pour le client d’installation.
Voir la section <a href="#tasks">[tasks]</a> pour une liste complète des tâches
par défaut qu&#8217;on peut utiliser.</p></div>
<div class="paragraph"><p>Un hook du formulaire <em>hookprefix.classname</em> ne peut pas définir de
variables pour le script d’installation, car il s’agit d’un
sous-processus. Mais vous pouvez utiliser n’importe quel exécutable
binaire ou n’importe quel script que vous avez écrit. Les hooks qui ont
le suffixe <em>.sh</em> (par exemple, <em>partition.DEFAULT.sh</em>) doivent être des
scripts Bourne shell et sont sourcé. Il est donc possible de redéfinir
des variables pour les scripts d’installation.</p></div>
<div class="paragraph"><p>Dans la première partie de FAI, tous les hooks avec le préfixe <em>confdir</em>
sont appelés. Ces hooks ne peuvent pas être localisés dans l’espace de
configuration, car il n’est pas encore disponible. Par conséquent, ces
hooks sont les seuls hooks situés dans <code>$nfsroot</code><em>/$FAI/hooks</em> sur le
serveur d’installation. Tous les autres hooks se trouvent dans
<em>$FAI_CONFIGDIR/hooks</em> sur le serveur d’installation.</p></div>
<div class="paragraph"><p>Tous les hooks appelés avant la définition des classes peuvent
utiliser uniquement les classes suivantes: <em>DEFAULT $HOSTNAME LAST</em>. Si un hook
pour la classe <em>DEFAULT</em> doit être appelé uniquement dans le cas où aucun hook pour
la classe <code>$HOSTNAME</code> n’est disponible, insérez ces lignes dans le hook
par défaut :</p></div>
<div class="listingblock">
<div class="content">
<pre><code>hookexample.DEFAULT:

#! /bin/sh

# sauter le hook DEFAULT s'il existe un hook pour $HOSTNAME
scriptname=$(basename $0 .DEFAULT)
[-f $FAI/hooks/$scriptname.$HOSTNAME ] &amp;&amp; exit
# suivent alors les actions pour la classe DEFAULT
.
.</code></pre>
</div></div>
<div class="paragraph"><p>Quelques exemples de ce à quoi les hooks pourraient être utiles :</p></div>
<div class="ulist"><ul>
<li>
<p>
Charger les modules du noyau avant que les classes soient définies dans <em>$FAI/class</em>.
</p>
</li>
<li>
<p>
Envoyer un courriel à l’administrateur si l’installation est terminée.
</p>
</li>
<li>
<p>
Installer un client sans disque et sautez le partitionnement de disque local.
</p>
</li>
<li>
<p>
Jeter un œil à <code>hooks/debconf.IMAGE</code> pour savoir comment cloner une machine en utilisant une image de système de fichiers.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_a_id_faiflags_a_options_flags_de_fai"><a id="faiflags"></a>Options (flags) de FAI</h3>
<div class="paragraph"><p>La variable <code>$FAI_FLAGS</code> contient une liste d&#8217;options séparées par des
espaces. Les options sont normalement définies dans le fichier pxelinux.cfg qui
est censément créé par <em>fai-chboot(1)</em>. Les options suivantes sont connues :</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
verbose
</dt>
<dd>
<p>
Rend l&#8217;installation verbeuse. Cela doit toujours
être la première option (le premier flag), de sorte que les définitions suivantes des
options soient affichées verbeusement.
</p>
</dd>
<dt class="hdlist1">
debug
</dt>
<dd>
<p>
Afficher des informations de débogage. Aucune installation sans assistance
n’est effectuée. Pendant l’installation du paquet, vous devez répondre
à toutes les questions des scripts postinstall sur la console du
client. Beaucoup d’informations de débogage seront affichées. Cette option
n’est utile que pour les développeurs FAI.
</p>
</dd>
<dt class="hdlist1">
sshd
</dt>
<dd>
<p>
Démarrer le démon ssh pour activer les connexions à distance. Vous
pouvez ensuite vous connecter en tant que <em>root</em> à tous les clients
d’installation pendant l’installation. Le mot de passe par défaut est
<em>fai</em> et peut être modifié en définissant <code>FAI_ROOTPW</code> dans
<code>nfsroot.conf(5)</code>. Pour vous connecter à partir de votre serveur vers le
client d’installation (nommé demohost dans cet exemple), utilisez :
</p>
</dd>
</dl></div>
<div class="listingblock">
<div class="content">
<pre><code>$ ssh root@demohost
Warning: Permanently added 'demohost,192.168.33.100' to the list of known hosts.
root@demohost's password:</code></pre>
</div></div>
<div class="paragraph"><p>Ce n’est le mot de passe root que pendant le processus d’installation,
pas pour le nouveau système installé. Vous pouvez également vous
connecter sans mot de passe lorsque vous utilisez <code>$SSH_IDENTITY</code>.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
createvt
</dt>
<dd>
<p>
Créez deux terminaux virtuels et exécutez un bash si <em>ctrl-c</em> est tapé
dans le terminal de console. Vous pouvez accéder aux terminaux
supplémentaires en tapant <em>Alt-F2</em> ou <em>Alt-F3</em>. Sinon, aucun terminal
n’est disponible et la saisie <em>ctrl-c</em> va redémarrer le client
d’installation. La définition de cette option est utile pour le débogage.
Si vous voulez une installation qui ne soit pas interruptible,
ne définissez pas cette option.
</p>
</dd>
<dt class="hdlist1">
menu
</dt>
<dd>
<p>
Cela active un menu utilisateur pour sélectionner un profil. Tous les
fichiers <code>class/*.profile</code> sont lus et un menu basé sur curses
sera créé.
</p>
</dd>
<dt class="hdlist1">
screen
</dt>
<dd>
<p>
Lancer FAI dans une session <code>screen(1)</code>. La session est nommée FAI.
Si on se connecte via ssh à distance on peut se rattacher à la session en utilisant :
</p>
</dd>
</dl></div>
<div class="listingblock">
<div class="content">
<pre><code>$ screen -x</code></pre>
</div></div>
<div class="dlist"><dl>
<dt class="hdlist1">
tmux
</dt>
<dd>
<p>
Lancer FAI dans une session <code>tmux(1)</code>. La session est nommée FAI.
Si on se connecte via ssh à distance on peut se rattacher à la session en utilisant :
</p>
</dd>
</dl></div>
<div class="listingblock">
<div class="content">
<pre><code>$ tmux attach</code></pre>
</div></div>
<div class="dlist"><dl>
<dt class="hdlist1">
reboot
</dt>
<dd>
<p>
Redémarrer le client d’installation une fois l’installation terminée
sans taper Entrée sur la console. Si cette option n’est pas définie, et
que error.log contient quelque chose, le client d’installation
s’arrêtera et attendra que vous appuyez sur Entrée. Si aucune erreur
ne s’est produite, le client redémarrera toujours
automatiquement.
</p>
</dd>
<dt class="hdlist1">
halt
</dt>
<dd>
<p>
Arrêter le client d’installation à la fin de l’installation, au lieu
de redémarrer dans le nouveau système.
</p>
</dd>
<dt class="hdlist1">
initial
</dt>
<dd>
<p>
Utilisé par <code>setup-storage(8)</code>. Les partitions marquées avec
<code>preserve_reinstall</code> sont préservées à moins que cette option ne soit
définie. Souvent, cette option est définie dans un fichier <em>class/*.var</em> en
utilisant le paramètre <em>flag_initial=1</em>.
</p>
</dd>
</dl></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_id_install_a_fai_installe_votre_planification"><a id="install"></a> FAI installe votre planification</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_la_première_phase_d_une_installation">La première phase d’une installation</h3>
<div class="paragraph"><p>Après le démarrage du noyau, on monte le système de fichiers racine via
NFS à partir du serveur d’installation et on démarre le script
<em>/usr/sbin/fai</em> <span class="footnote"><br />[Comme le système de fichiers racine des clients
est monté via NFS, <code>fai</code> se situe dans <em>/srv/fai/nfsroot/usr/sbin</em> sur le
serveur d&#8217;installation.]<br /></span>. Ce script contrôle la séquence de
l’installation. Aucun autre script dans <em>/etc/init.d/</em> n’est utilisé.</p></div>
<div class="paragraph"><p>L’espace de configuration est rendu disponible via la méthode configurée
(un montage NFS par défaut) depuis le serveur d’installation vers le chemin défini
dans <em>$FAI</em> <span class="footnote"><br />[<em>$FAI</em> est une variable interne utilisée par les scripts FAI.
Le chemin par défaut est <em>/var/lib/fai/config</em>.]<br /></span></p></div>
</div>
<div class="sect2">
<h3 id="_a_id_bootmesg_a_messages_de_démarrage"><a id="bootmesg"></a>Messages de démarrage</h3>
<div class="paragraph"><p>Lorsqu&#8217;on démarre le client d’installation à partir de la carte
réseau avec PXE, on voit des messages comme ceci :</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Managed PC Boot Agent (MBA) v4.00
Pre-boot eXecution Environment (PXE) v2.00
DHCP MAC ADDR: 00 A2 A3 04 05 06
DHCP.../

CLIENT MAC ADDR: 00 A2 A3 04 05 06  GUID: 3D6C4552
CLIENT IP: 192.168.33.100 MASK: 255.255.255.0  DHCP IP: 192.168.33.250
GATEWAY IP: 192.168.33.1

!PXE entry point found (we hope) at 9854:0106 via plan A
UNDI code segment at: 9854 len 5260
UNDI data segment at: 921D len 63A2
Getting cached packet  01 02 03
My Ip address seems to be C0A82164 192.168.33.100
ip=192.168.33.100:192.168.33.250:192.168.33.1:255.255.255.0
BOOTIF=01-00-A2-A3-04-05-06
SYSUUID=
TFTP prefix: fai/
Trying to load pxelinux.cfg/C0A82164

Loading vmlinuz-6.1.0-17-amd64..................
Loading initrd.img-6.1.0-17-amd64......................ready.</code></pre>
</div></div>
<div class="paragraph"><p>À ce stade, le client d’installation a réussi à recevoir la configuration
réseau via DHCP, le noyau et le fichier initrd via TFTP. Il démarre maintenant Le
noyau Linux et met en place initrd. Si tout se passe bien, l’initrd monte
le nfsroot <span class="footnote"><br />[<em>/srv/fai/nfsroot</em> depuis le serveur d&#8217;installation via NFS]<br /></span>
et les scripts FAI sont lancés. La première
chose qu&#8217;on voit est le message de copyright en rouge de FAI.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>             -------------------------------------------------
                   Fully Automatic Installation  -  FAI

                   6.2           (c) 1999-2024
                   Thomas Lange  &lt;lange@cs.uni-koeln.de&gt;
             -------------------------------------------------

Calling task_confdir
Kernel currently running: Linux 6.1.0-17-amd64 x86_64 GNU/Linux
Kernel parameters: BOOT_IMAGE=vmlinuz-6.1.0-17-amd64 initrd=initrd.img-6.1.0-17-amd64 \
  ip=dhcp rw root=192.168.33.250:/srv/fai/nfsroot rootovl FAI_FLAGS=verbose,sshd,createvt
  FAI_ACTION=install FAI_CONFIG_SRC=nfs://faiserver/srv/fai/config
Reading /tmp/fai/boot.log
FAI_FLAGS: verbose sshd createvt
Monitoring to server faiserver enabled.
FAI_CONFIG_SRC is set to nfs://faiserver/srv/fai/config
Configuration space faiserver:/srv/fai/config mounted to /var/lib/fai/config
Source hook: setup.DEFAULT.sh
setup.DEFAULT.sh     OK.
Calling task_setup
FAI_FLAGS: verbose sshd createvt
Press ctrl-c to interrupt FAI and to get a shell
Starting FAI execution - 20240117_194012
Calling task_defclass
fai-class: Defining classes.
Executing /var/lib/fai/config/class/01-classes.
01-classes           OK.
Executing /var/lib/fai/config/class/10-base-classes.
10-base-classes      OK.
Executing /var/lib/fai/config/class/20-hwdetect.sh.
ens3             UP             52:54:00:11:23:01 &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;
ens3             UP             192.168.33.101/24 fe80::5054:ff:fe11:2301/64
New disklist: vda
20-hwdetect.sh       OK.
Executing /var/lib/fai/config/class/40-parse-profiles.sh.
40-parse-profiles.sh OK.
Executing /var/lib/fai/config/class/41-warning.sh.
41-warning.sh        OK.
Executing /var/lib/fai/config/class/50-host-classes.
50-host-classes      OK.
Executing /var/lib/fai/config/class/60-misc.
60-misc              OK.
Executing /var/lib/fai/config/class/85-efi-classes.
85-efi-classes       OK.
List of all classes:  DEFAULT LINUX AMD64 DHCPC FAIBASE DEBIAN DEMO GRUB_PC demohost2 LAST</code></pre>
</div></div>
<div class="paragraph"><p>On peut également voir la liste des classes FAI, qui sont définies
pour cet hôte. Cette liste est très importante pour le reste de l’installation.</p></div>
<div class="paragraph"><p>La première tâche est appelée <em>confdir</em>, qui est chargée de accès à
l’espace de configuration. Ici, on utilise un montage NFS depuis
le serveur d&#8217;installation comme on peut le voir sur la console (et plus tard
dans les journaux).</p></div>
<div class="listingblock">
<div class="content">
<pre><code>FAI_CONFIG_SRC is set to nfs://faiserver/srv/fai/config
Configuration space faiserver:/srv/fai/config mounted to /var/lib/fai/config</code></pre>
</div></div>
<div class="paragraph"><p>Avant de lancer l’installation (<code>$FAI_ACTION=install</code>), l’ordinateur
émet trois bips. Donc, faites attention quand vous entendez trois bips
et que vous ne voulez pas effectuer une installation, ni laisser FAI
effacer toutes vos données sur Le disque local !</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_reboot_a_redémarrage_de_l_ordinateur_dans_le_nouveau_système"><a id="reboot"></a>Redémarrage de l’ordinateur dans le nouveau système</h3>
<div class="paragraph"><p>Pour redémarrer l’ordinateur pendant ou à la fin de l’installation, vous
devez utiliser la commande <code>faireboot</code> de préférence à la commande de
redémarrage normal. Utilisez aussi <code>faireboot</code> si vous êtes connecté
à distance. Si l’installation n’est pas terminée, utilisez
<em>faireboot -s</em>, afin que les fichiers journaux soient aussi copiés sur le
serveur d’installation.</p></div>
<div class="paragraph"><p>Si l’installation s&#8217;est bien terminée, l’ordinateur doit démarrer un petit
système Debian. Vous pouvez vous connecter en tant qu&#8217;utilisateur <em>demo</em> ou <em>root</em>
avec le mot de passe <em>fai</em>.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_isetup_a_démarrage_de_fai_tâche_confdir"><a id="isetup"></a>Démarrage de FAI (tâche confdir)</h3>
<div class="paragraph"><p>Une fois le client d’installation démarré, seul le script
<em>/usr/sbin/fai</em> est exécuté. Il effectuera une initialisation minimale.
La variable <code>$FAI_CONFIG_SRC</code> <span class="footnote"><br />[Celle-ci est définie dans la ligne de commande du noyau]<br /></span>
est utilisée pour accéder à l’espace de configuration FAI qui est alors
disponible dans le répertoire <code>$FAI</code> <span class="footnote"><br />[/var/lib/fai/config]<br /></span>.
FAI ne se fonctionnera pas sans l’espace de configuration.</p></div>
<div class="paragraph"><p>On peut accéder à l&#8217;espace de configuration à l&#8217;aide de diverses méthodes. Les
méthodes supportées sont : nfs:, file:, cvs:, svn: git:, hg:, http: et detect:.
Voir <code>fai.conf(5)</code> pour une description détaillée de ces méthodes.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_iclass_a_définition_de_classes_et_de_variables_tâches_defclass_et_defvar"><a id="iclass"></a>Définition de classes et de variables (tâches defclass et defvar)</h3>
<div class="paragraph"><p>La commande <code>fai-class(1)</code> exécute des scripts dans <em>$FAI/class</em> pour
définir des classes. Si les scripts écrivent une chaîne dans stdout, cela
sera défini comme une classe. Lisez tous les détails dans la page de
manuel de <code>fai-class(1)</code>.</p></div>
<div class="paragraph"><p>Après avoir défini les classes, chaque fichier correspondant à <em>.var</em>
avec un préfixe qui correspond à une classe définie est pris en compte pour
définir des variables. Il doit contenir du code shell valide.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_ipartition_a_partitionnement_des_disques_locaux_création_des_systèmes_de_fichiers_tâche_partition"><a id="ipartition"></a>Partitionnement des disques locaux, création des systèmes de fichiers (tâche partition)</h3>
<div class="paragraph"><p>Pour le partitionnement du disque, un fichier de configuration de disque
de <em>$FAI/disk_config</em> est sélectionné à l’aide de classes, et un seul.</p></div>
<div class="paragraph"><p>Le format de la configuration du disque est similaire à un fichier fstab.</p></div>
<div class="paragraph"><p>L’outil de partitionnement <code>setup-storage(8)</code> exécute toutes les
commandes nécessaires pour créer l&#8217;organisation des partitions du
disque, du RAID logiciel, du LVM et pour créer les systèmes de
fichiers. Lisez la page de manuel de <code>setup-storage(8)</code> pour une
description détaillée et quelques exemples du format.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_ipreseed_a_pré_ensemencement_debconf_tâche_debconf"><a id="ipreseed"></a>Pré-ensemencement Debconf (tâche debconf)</h3>
<div class="paragraph"><p>Les fichiers dans <em>$FAI/debconf</em> sont utilisés par le système de pré-ensemencement
habituel de <code>debconf(7)</code> si les noms de fichier correspondent à un
nom de classe.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_ipackages_a_installation_de_paquets_logiciels_tâche_instsoft"><a id="ipackages"></a>Installation de paquets logiciels (tâche instsoft)</h3>
<div class="paragraph"><p>La commande <code>install_packages(8)</code> lit les fichiers de configuration à
partir de <em>$FAI/package_config</em> d&#8217;une façon basée sur la classe et installe des paquets
logiciels sur le nouveau système de fichiers.</p></div>
<div class="paragraph"><p>Elle installe les paquets en utilisant <code>apt-get(8)</code>, <code>aptitude(1)</code>,
<code>yum</code> ou d’autres gestionnaires de paquets sans besoin d&#8217;aucune interaction manuelle.
Les dépendances des paquets sont également résolues par les gestionnaires de paquets.</p></div>
<div class="paragraph"><p>Le format des fichiers de configuration est décrit dans <a href="#packageconfig">[packageconfig]</a>.</p></div>
<div class="paragraph"><p>De plus, FAI installera les paquets (<em>.deb</em> or .rpm') depuis les
répertoires <em>$FAI/pkgs/&lt;CLASSNAME&gt;</em>.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_icscripts_a_personnalisation_spécifique_au_site_tâche_configure"><a id="icscripts"></a>Personnalisation spécifique au site (tâche configure)</h3>
<div class="paragraph"><p>Souvent, les configurations par défaut des paquets logiciels ne répondent pas à
vos besoins spécifiques au site. Vous pouvez appeler des scripts
arbitraires qui ajustent la configuration du système. Par conséquent, la
commande <code>fai-do-scripts(1)</code> exécute des scripts dans <em>$FAI/scripts</em>
d’une manière basée sur la classe. Il est possible d’avoir plusieurs
scripts de différents types (shell, cfengine, …) à exécuter pour une classe.</p></div>
<div class="paragraph"><p>L’ensemble de scripts par défaut dans <em>$FAI/scripts</em> inclut des exemples
d’installation de machines Debian et Rocky Linux. Ils définissent le mot de
passe root, ajoutent un compte utilisateur (défini par <em>$username</em>, avec demo par défaut),
paramètrent le fuseau horaire, configurent le réseau avec DHCP ou en utilisant une adresse IP
fixe, configurent grub et plus encore. Ils devraient faire un
travail raisonnable pour votre installation. Vous pouvez les modifier ou
ajouter de nouveaux scripts pour répondre à vos besoins locaux.</p></div>
<div class="paragraph"><p>Plus d’information sur ces scripts est disponible dans <a href="#cscripts">[cscripts]</a>.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_isavelog_a_enregistrement_des_fichiers_journaux_tâche_savelog"><a id="isavelog"></a>Enregistrement des fichiers journaux (tâche savelog)</h3>
<div class="paragraph"><p>Lorsque toutes les tâches sont terminées, les fichiers journaux sont écrits dans
<em>/var/log/fai/$HOSTNAME/install/</em>
<span class="footnote"><br />[<em>/var/log/fai/localhost/install/</em> est un lien vers ce répertoire.]<br /></span>
sur le nouveau système, et sur le compte sur le serveur d’installation si
<code>$LOGUSER</code> est défini (il faut l&#8217;activer dans <em>/srv/fai/config/class/FAIBASE.var</em>).
Il est également possible de spécifier un autre hôte comme destination pour cet enregistrement
à l&#8217;aide de la variable
<code>$LOGSERVER</code>. Si <code>$LOGSERVER</code> n’est pas défini, FAI utilise la
variable <code>$SERVER</code> qui n’est définie que lors d’une installation
initiale (par get-boot-info).</p></div>
<div class="paragraph"><p>De plus, deux liens symboliques seront créés pour indiquer le dernier
répertoire où on a écrit. Le lien symbolique <em>last</em> pointe vers le répertoire
journal de la dernière action FAI exécutée. Les liens symboliques
<em>last-install</em> et <em>last-sysinfo</em> pointent vers le répertoire avec la
dernière action correspondante. Par défaut, les fichiers journaux seront
copiés sur le serveur de journalisation à l’aide de scp. Vous pouvez utiliser
la variable <code>$FAI_LOGPROTO</code> dans le fichier <em>fai.conf(5)</em> pour choisir
une autre méthode d’enregistrement des journaux sur le serveur distant.
Voici un exemple de structure de lien symbolique :</p></div>
<div class="listingblock">
<div class="content">
<pre><code>lrwxrwxrwx   1 fai fai   23 Dec  2  2013 last-sysinfo -&gt; sysinfo-20131202_161237
drwxr-xr-x   2 fai fai 4096 Dec  2  2013 sysinfo-20131202_161237
drwxr-xr-x   2 fai fai 4096 Feb 14  2014 install-20140214_142150
drwxr-xr-x   2 fai fai 4096 Dec  2 11:47 install-20141202_113918
lrwxrwxrwx   1 fai fai   23 Dec  4 13:22 last-install -&gt; install-20141204_131351
lrwxrwxrwx   1 fai fai   23 Dec  4 13:22 last -&gt; install-20141204_131351
drwxr-xr-x   2 fai fai 4096 Dec  4 13:22 install-20141204_131351</code></pre>
</div></div>
<div class="paragraph"><p>Vous trouverez des exemples de fichiers journaux à l’adresse <a href="https://fai-project.org/logs">https://fai-project.org/logs</a>.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_ireboot_a_redémarrage_du_nouveau_système_installé"><a id="ireboot"></a>Redémarrage du nouveau système installé</h3>
<div class="paragraph"><p>Avant de redémarrer, le client d’installation appelle
<code>fai-chboot -d &lt;hostname&gt;</code> sur le serveur d’installation, pour
désactiver sa propre configuration PXELINUX. Sinon, il redémarrerait
l’installation lors de la prochaine initialisation. Normalement, cela
devrait démarrer le nouveau système installé à partir de son second
périphérique d’amorçage, le disque dur local.</p></div>
<div class="paragraph"><p>À la fin, le système est automatiquement redémarré si "reboot" a été
ajouté à <code>$FAI_FLAGS</code>.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_id_advanced_a_sujets_avancés_pour_fai"><a id="advanced"></a>Sujets avancés pour FAI</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_a_id_checkbootp_a_vérification_des_paramètres_reçus_des_serveurs_dhcp"><a id="checkbootp"></a>Vérification des paramètres reçus des serveurs DHCP</h3>
<div class="paragraph"><p>Si le client d’installation démarre, vous pouvez vérifier si toutes les
informations provenant du démon DHCP sont correctement reçues. Les
informations reçues sont écrites dans <em>/tmp/fai/boot.log</em>. Un exemple de
résultat d’une requête DHCP peut être trouvé dans les fichiers journaux
d’exemple.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_fai_monitor_a_surveillance_de_plusieurs_clients_d_8217_installation"><a id="fai-monitor"></a>Surveillance de plusieurs clients d&#8217;installation</h3>
<div class="paragraph"><p>Vous pouvez surveiller l’installation de tous les clients d’installation
avec la commande <code>fai-monitor(8)</code>. Tous les clients vérifient si ce
démon est en cours d’exécution sur le serveur d’installation (ou sur
l’ordinateur défini par la variable <code>$monserver</code>). Chaque fois qu’une
tâche démarre ou se termine, un message est envoyé. Le démon du moniteur
FAI envoie ces messages dans sa sortie standard. On peut aussi utiliser une interface
graphique, appelée <code>fai-monitor-gui(1)</code>.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$  fai-monitor | fai-monitor-gui - &amp;</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_a_id_mac_a_collecte_d_adresses_ethernet_pour_plusieurs_hôtes"><a id="mac"></a>Collecte d’adresses Ethernet pour plusieurs hôtes</h3>
<div class="paragraph"><p>Vous devez collecter toutes les adresses Ethernet (MAC) des clients
d’installation et affecter un nom d’hôte et une adresse IP à chaque
client. Pour collecter les adresses MAC, démarrez vos clients
d’installation. Vous pouvez déjà le faire avant que n’importe quel démon
DHCP s’exécute dans votre sous-réseau. Ils échoueront à démarrer (en
raison de l&#8217;absence de DHCP ou de TFTP), mais vous pouvez toujours
collecter les adresses MAC.</p></div>
<div class="paragraph"><p>Pendant que les clients d’installation démarrent, ils envoient des
paquets de diffusion (broadcast) au LAN. Vous pouvez enregistrer les adresses MAC de
ces hôtes en exécutant simultanément la commande suivante sur le serveur :</p></div>
<div class="listingblock">
<div class="content">
<pre><code>faiserver# tcpdump -qtel broadcast and port bootpc &gt;/tmp/mac.list</code></pre>
</div></div>
<div class="paragraph"><p>Une fois que les hôtes ont envoyés quelques paquets de diffusion, arrêtez <code>tcpdump</code>
en tapant <em>ctrl-c</em>. Vous obtenez une liste de toutes les adresses MAC uniques avec ces commandes :</p></div>
<div class="listingblock">
<div class="content">
<pre><code>faiserver$ perl -ane 'print "\U$F[0]\n"' /tmp/mac.list|sort|uniq</code></pre>
</div></div>
<div class="paragraph"><p>Après cela, vous n’avez qu&#8217;à assigner ces adresses MAC aux noms d’hôte
et aux adresses IP (<em>/etc/ethers</em> et <em>/etc/hosts</em> ou aux associations NIS
correspondantes). Avec ces informations, vous pouvez configurer votre
démon DHCP (voir la section <a href="#bootdhcp">[bootdhcp]</a>). <span class="footnote"><br />[Je recommande d&#8217;inscrire
l&#8217;adresse MAC (les trois derniers octets devraient suffire si vous avez des cartes du
même vendeur) et le nom d&#8217;hôte devant chaque boîtier.]<br /></span></p></div>
<div class="sect3">
<h4 id="_débogage_du_trafic_réseau">Débogage du trafic réseau</h4>
<div class="paragraph"><p>Si le client ne peut démarrer correctement à partir de la carte réseau,
utilisez <code>tcpdump(8)</code> pour rechercher des paquets Ethernet entre le
serveur d’installation et le client. Recherchez également dans les entrées de
plusieurs fichiers journaux venant de <code>tftpd(8)</code> et <code>dhcpd(8)</code> :</p></div>
<div class="listingblock">
<div class="content">
<pre><code>faiserver$ egrep "tftpd|dhcpd" /var/log/*</code></pre>
</div></div>
</div>
</div>
<div class="sect2">
<h3 id="_a_id_pxeboot_a_détails_du_démarrage_pxe"><a id="pxeboot"></a>Détails du démarrage PXE</h3>
<div class="paragraph"><p>Ici, nous décrivons les détails du démarrage PXE, qui sont
nécessaires seulement si vous avez des problèmes lors du démarrage de vos
clients d’installation.</p></div>
<div class="paragraph"><p>Presque toutes les cartes réseau modernes prennent en charge
l’environnement de démarrage PXE. PXE est l’environnement d’exécution de
pré-lancement. Cela nécessite le chargeur de démarrage PXELINUX et une
version spéciale du démon <em>TFTP</em>, disponibles dans les paquets Debian
<code>pxelinux</code> et <code>tftpd-hpa</code>. Le démarrage PXE nécessite également un
serveur DHCP, afin que la carte réseau puisse configurer ses paramètres
IP. Voici la séquence d’une amorce PXE :</p></div>
<div class="ulist"><ul>
<li>
<p>
La carte réseau du client envoie son adresse MAC
</p>
</li>
<li>
<p>
Le serveur DHCP répond par la configuration IP du client
</p>
</li>
<li>
<p>
La carte réseau configure son IP
</p>
</li>
<li>
<p>
Le client d’installation obtient le binaire pxelinux.0 via TFTP
</p>
</li>
<li>
<p>
Il obtient le fichier de configuration pxelinux.cfg/C0A8210C via TFTP
</p>
</li>
<li>
<p>
C0A8210C est l’adresse IP du client en hexadécimal
</p>
</li>
<li>
<p>
Cette configuration contient le noyau, le fichier initrd et les paramètres de ligne de commande supplémentaires du noyau, qui ont été créés par <code>fai-chboot</code>.
</p>
</li>
<li>
<p>
Il obtient le noyau et le fichier initrd via TFTP.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Exemple d&#8217;un fichier pxelinux.cfg :</p></div>
<div class="listingblock">
<div class="content">
<pre><code>default fai-generated

label fai-generated
kernel vmlinuz-6.1.0-17-amd64
append initrd=initrd.img-6.1.0-17-amd64 ip=dhcp root=/srv/fai/nfsroot rootovl FAI_FLAGS=verbose,sshd,createvt FAI_CONFIG_SRC=nfs://faiserver/srv/fai/config FAI_ACTION=install</code></pre>
</div></div>
<div class="paragraph"><p>Voir <em>/usr/share/doc/syslinux/pxelinux.doc</em> pour des informations plus
détaillées sur PXELINUX. FAI utilise le fichier binaire lpxelinux.0 qui
s&#8217;occupe du chargement du noyau et du fichier initrd via FTP
ou HTTP. La commande <code>fai-chboot(8)</code> prend cela en charge avec
l’option <em>-U</em>.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_customizing_your_install_server_setup_a_personnaliser_la_configuration_de_son_serveur_d_installation"><a id="Customizing your install server setup"></a>Personnaliser la configuration de son serveur d’installation</h3>
<div class="ulist"><ul>
<li>
<p>
Miroir de paquets logiciels local/plus rapide
</p>
</li>
<li>
<p>
Loguser différent
</p>
</li>
<li>
<p>
Mot de passe root local dans nfsroot
</p>
</li>
</ul></div>
<div class="paragraph"><p>La configuration du paquet FAI (et non les données de configuration pour
les clients d’installation) est définie dans <em>fai.conf(5)</em>. Les
définitions qui sont utilisées uniquement pour créer le nfsroot sont
situées dans <em>nfsroot.conf(5)</em>. Vérifiez ces variables importantes dans
<em>nfsroot.conf</em> avant d’appeler <em>fai-setup</em> ou <em>fai-make-nfsroot</em>.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
FAI_DEBOOTSTRAP
</dt>
<dd>
<p>
La construction du nfsroot utilise la commande <code>debootstrap(8)</code>. Elle
a besoin de l’emplacement d’un miroir Debian et du nom de la
distribution (comme bullsseye, bookworm, sid) pour laquelle le système
Debian de base devrait être construit. N’utilisez pas de distributions
différentes ici et dans <em>/etc/fai/apt/sources.list</em>. Cela créerait un
nfsroot dysfonctionnel.
</p>
</dd>
<dt class="hdlist1">
NFSROOT_ETC_HOSTS
</dt>
<dd>
<p>
Cette variable est nécessaire seulement si les clients n’ont pas accès à
un serveur DNS. Cette variable multiligne est ajoutée à /etc/hosts
dans le nfsroot. Ensuite, les clients d’installation peuvent accéder à
ces hôtes par leur nom sans utiliser DNS.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Le contenu de <em>/etc/fai/apt/sources.list</em> est utilisé par le serveur
d’installation et aussi par les clients. Si votre serveur d’installation a
plusieurs cartes réseau et différents noms d’hôte pour chaque carte
(comme pour un serveur Beowulf), utilisez le nom du serveur
d’installation qui est connu des clients d’installation.</p></div>
<div class="paragraph"><p>Si vous avez des problèmes lors de l’exécution de <code>fai-setup</code>, ils
proviennent habituellement de <code>fai-make-nfsroot(8)</code> qui est appelé par
la commande précédente. L’ajout de <em>-v</em> vous donne une sortie plus
détaillée qui vous aide à repérer l’erreur. La sortie est écrite dans
<em>/var/log/fai/fai-make-nfsroot.log</em>. <span class="footnote"><br />[À des fins de débogage,
il peut être utile d&#8217;entrer dans l&#8217;environnement chroot à la main à l&#8217;aide
de cette commande :  <em>faiserver# chroot /srv/fai/nfsroot bash</em>]<br /></span></p></div>
<div class="paragraph"><p>L’installation crée également le compte <em>fai</em> (défini par <code>$LOGUSER</code>)
s’il n’est pas déjà disponible. Vous pouvez donc ajouter un utilisateur
avant d’appeler <code>fai-setup(8)</code> à l’aide de la commande <code>adduser(8)</code>
et l&#8217;utiliser comme compte local pour enregistrer des fichiers journaux. Les
fichiers journaux de tous les clients d’installation sont enregistrés
dans le répertoire de personnel de ce compte. Vous devriez changer le groupe
principal de ce compte, afin que ce compte ait des droits d&#8217;écriture sur
<em>/srv/tftp/fai</em> afin d&#8217;appeler fai-chboot pour créer la configuration PXE
pour les hôtes.</p></div>
<div class="paragraph"><p>Lorsque vous apportez des modifications à <em>fai.conf</em>, <em>nfsroot.conf</em>, le
nfsroot doit être reconstruit en appelant <code>fai-make-nfsroot(8)</code>. Si
vous souhaitez uniquement installer un nouveau paquet de noyau sur
nfsroot, ajoutez les options <em>-k</em> ou <em>-K</em> à <code>fai-make-nfsroot</code>. Cela ne
recréera pas votre nfsroot, mais mettra à jour seulement vos noyaux et les
modules du noyau dans le nfsroot ou ajoutera des paquets supplémentaires
dans le nfsroot.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_cdboot_a_création_d_un_cd_ou_d_une_clé_usb_fai"><a id="cdboot"></a>Création d’un CD ou d’une clé USB FAI</h3>
<div class="paragraph"><p>Vous pouvez facilement créer un CD d’installation (ou une clé USB) de
votre installation réseau. Cela permettra d’effectuer la même
installation et la même configuration à partir du CD sans avoir besoin
du serveur d’installation. Par conséquent, vous devez créer un miroir
partiel de tous les paquets Debian nécessaires à vos classes FAI (à
l’aide de <code>fai-mirror(1)</code>). Ensuite, la commande <code>fai-cd(8)</code> écrira
ce miroir, le nfsroot et l’espace de configuration sur un CD amorçable.
Et voilà !</p></div>
<div class="paragraph"><p>Pour créer facilement le CD d&#8217;installation, on peut utiliser la commande suivante
(Pour plus de détails de configuration voir <code>fai-cd(8)</code>) :</p></div>
<div class="listingblock">
<div class="content">
<pre><code> faiserver# fai-cd -m &lt;partialMirrorDir&gt; fai-cd.iso</code></pre>
</div></div>
<div class="paragraph"><p>Ce CD d’installation contient toutes les données nécessaires à
l’installation. La commande <code>fai-cd(8)</code> écrit le nfsroot, l’espace de
configuration et un sous-ensemble du miroir Debian sur un CD-ROM. Un
miroir de paquets partiel est créé à l’aide de la commande
<code>fai-mirror(1)</code> qui contient tous les paquetages utilisés par les
classes utilisées dans votre espace de configuration. Un échantillon
d’image ISO est disponible à l’adresse <a href="https://fai-project.org/fai-cd">https://fai-project.org/fai-cd</a>.</p></div>
<div class="paragraph"><p>Avec la commande <code>dd(1)</code>, vous pouvez également créer une clé USB
amorçable en écrivant simplement le contenu du fichier ISO sur votre clé
USB (ici la clé est <em>/dev/sdf</em>).</p></div>
<div class="listingblock">
<div class="content">
<pre><code> faiserver# dd if=fai-cd.iso of=/dev/sdf bs=1M</code></pre>
</div></div>
<div class="paragraph"><p><code>mk-data-partition</code> est un outil qui étend une image ISO (qui sera copiée
sur une clé USB) ou une clé USB contenant une image ISO avec
une partition ext4 ou exFAT et y place le label MY-DATA.
Cette partition est automatiquement montée dans <em>/media/data</em> par FAI.
On peut copier ses propres paquets <em>.deb</em> dans cette partition de données sous les
sous-répertoires <em>pkgs/&lt;CLASSNAME&gt;</em>. FAI installera alors ces paquets
si la classe équivalente est définie.</p></div>
<div class="paragraph"><p>exemple d&#8217;usage de <code>mk-data-partition</code>:</p></div>
<div class="listingblock">
<div class="content">
<pre><code># mk-data-partition -s 1G -c faicd-large.iso A B</code></pre>
</div></div>
<div class="paragraph"><p>La commande ci-desus crée la partition de données avec une taille de 1 Go dans
le fichier ISO et y copie les répertoires A et B. On peut écrire l&#8217;image ISO modifiée
sur une clé USB.</p></div>
<div class="paragraph"><p>Si l&#8217;image ISO est déjà sur la clé USB, qui est disponible sous
<em>dev/sdf</em>, on peut ajouter la partition de données de type exFAT qui utilisera
tout l&#8217;espace disponible de la clé USB en utilisant cette commande
 :</p></div>
<div class="listingblock">
<div class="content">
<pre><code># mk-data-partition -F /dev/sdf</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_a_id_diskimage_a_création_d_images_de_disque_vm_à_l_aide_de_fai"><a id="diskimage"></a>Création d’images de disque VM à l’aide de FAI</h3>
<div class="paragraph"><p>En utilisant la commande <code>fai-diskimage(8)</code>, vous pouvez créer des
images de disques qui peuvent être utilisées avec une
machine virtuelle comme KVM, VMware, VirtualBox ou un service cloud
comme OpenStack, GCE, EC2 et autres. Le processus d’installation exécute
les tâches FAI normales sur une image de disque brut. Après
l’installation, vous pouvez démarrer l’image disque et avoir un système
fonctionnel. L’image disque peut également être convertie au format qcow2.
Vous n&#8217;avez pas besoin de mettre en place le nfsroot de FAI quand vous utilisez seulement
fai-diskimage. Mais vous avez besoin d&#8217;un fichier de base dans votre espace de
configuration. Le réglage de la variable <code>$FAI_BASEFILEURL</code> permet de télécharger automatiquement
un fichier de base approprié dans votre espace de configuration.</p></div>
<div class="paragraph"><p>Voici par exemple comment créer une image de disque brute pour un hôte nommé
cloud3, avec un petit ensemble de paquets logiciels :</p></div>
<div class="listingblock">
<div class="content">
<pre><code># export FAI_BASEFILEURL=https://fai-project.org/download/basefiles/
# fai-diskimage -vu cloud3 -S2G -cDEBIAN,BOOKWORM64,AMD64,FAIBASE,GRUB_PC,DHCPC,DEMO,CLOUD,LAST disk.raw</code></pre>
</div></div>
<div class="paragraph"><p>Cette commande créera une image de disque nommée ubuntu.qcow2 pour une configuration de bureau Ubuntu 16.04
avec pour nom d&#8217;hôte machin.</p></div>
<div class="listingblock">
<div class="content">
<pre><code># export FAI_BASEFILEURL=https://fai-project.org/download/basefiles/
# cl=DHCPC,UBUNTU,JAMMY,JAMMY64,AMD64,XORG,LAST
# fai-diskimage -Nvu machin -S5G -c$cl ubuntu.qcow2</code></pre>
</div></div>
<div class="paragraph"><p>Vous pouvez essayer quelques images de disques sans installer FAI, si vous visitez
<a href="https://fai-project.org/FAIme/cloud">https://fai-project.org/FAIme/cloud</a></p></div>
</div>
<div class="sect2">
<h3 id="_a_id_live_image_a_création_d_8217_une_image_vive_amorçable"><a id="live-image"></a>Création d&#8217;une image vive amorçable</h3>
<div class="paragraph"><p>La création d&#8217;images ISO vives amorçables est facile avec FAI. Il suffit de deux
étapes. Premièrement, créez votre environnement vif à l&#8217;aide de la commande <em>fai
dirinstall</em>. N&#8217;oubliez pas d&#8217;ajouter la classe <code>LIVEISO</code>.
Ensuite, créez l&#8217;image ISO vive en utilisant <em>fai-cd</em> :</p></div>
<div class="listingblock">
<div class="content">
<pre><code># cl="DEBIAN,BOOKWORM64,AMD64,FAIBASE,XFCE,XORG,DHCPC,DEMO,LIVEISO,LAST"
# LC_ALL=C fai -v dirinstall -u xfce33 -c $cl \
    -s file:///srv/fai/config /srv/xfce
# fai-cd -s500 -MH -d none -g /etc/fai/grub.cfg.live \
    -n /srv/xfce live.iso</code></pre>
</div></div>
<div class="paragraph"><p>Le nfsroot n&#8217;est pas nécessaire pour une image ISO vive.
Il n&#8217;y a pas actuellement d&#8217;image vive ISO disponible sur le serveur d&#8217;installation.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_cross_arch_a_construire_des_images_disque_d_8217_architecture_différente_cross_architecture"><a id="cross-arch"></a>Construire des images disque d&#8217;architecture différente (cross-architecture)</h3>
<div class="paragraph"><p>À partir de FAI 5.4 il devient possible de construire une image disque pour
des architectures différentes de l&#8217;hôte qui est utilisé. Par exemple on peut
construire une image pour une architecture ARM 64-bit (aarch64) sur un hôte qui fonctionne
sur une architecture amd64. Voici les étapes successives :</p></div>
<div class="listingblock">
<div class="content">
<pre><code># apt install qemu-system-arm qemu-user-static fai-server fai-setup-storage fai-doc qemu-utils
# fai-mk-configspace

# export FAI_BASEFILEURL=https://fai-project.org/download/basefiles/
# fai-diskimage -vu armhost -S2G -cDEFAULT,DHCPC,DEBIAN,ARM64,BUSTER_ARM64,FAIBASE,DEMO,CLOUD,LAST arm64.raw
# chown your_user_id arm64.raw
# cp /var/log/fai/armhost/last/vmlinuz* vmlinuz
# cp /var/log/fai/armhost/last/initrd.img* initrd</code></pre>
</div></div>
<div class="paragraph"><p>Ensuite on peut lancer qemu en tant qu&#8217;utilisateur ordinaire :</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&gt; qemu-system-aarch64 -m 1000 -M virt,gic_version=3 -cpu cortex-a57 -drive file=arm64.raw,if=virtio,index=1 -no-reboot -nographic -name ARM64 -net nic,name=eth0,model=virtio -net user,name=eth0,-kernel vmlinuz -initrd initrd -append "console=ttyAMA0 rw ip=dhcp root=/dev/vda1 net.ifnames=0"</code></pre>
</div></div>
<div class="paragraph"><p>Ça fonctionne de même pour d&#8217;autres architectures.
Il faut garder en tête que les réglages réseau de qemu ont des performances dégradées si
on n&#8217;utilise pas le pilote virtio comme ci-dessus ou des TAPs réseaux.</p></div>
<div class="paragraph"><p>On peut trouver les fichiers de base pour plusieurs architectures à
<a href="https://fai-project.org/download/basefiles/">https://fai-project.org/download/basefiles/</a>, ou utiliser <code>mk-basefile</code> pour
créer son fichier propre.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_sysinfo_a_système_de_sauvetage_fai"><a id="sysinfo"></a>Système de sauvetage FAI</h3>
<div class="paragraph"><p>Si vous assignez à la variable <code>$FAI_ACTION</code> la valeur <em>sysinfo</em> (par exemple
en utilisant fai-chboot -S), le client n’installera pas de nouveau
système, mais collectera beaucoup d’informations système. Si vous
assignez à <code>$FAI_ACTION</code> la valeur <em>inventory</em>, vous ne recevrez que
quelques informations sur le matériel. Les deux actions peuvent être
utilisées pour FAI comme un système de sauvetage.</p></div>
<div class="paragraph"><p>Tapez <em>ctrl-c</em> pour obtenir un shell ou utilisez <em>Alt-F2</em> ou <em>Alt-F3</em> et
vous obtiendrez une autre console de terminal, si vous avez ajouté
<em>createvt</em> à <code>$FAI_FLAGS</code>.</p></div>
<div class="paragraph"><p>Vous voilà maintenant avec un système Linux qui fonctionne sur le client
d’installation sans utiliser le disque dur local. Utilisez-le comme
système de secours si votre disque local est endommagé ou si
l’ordinateur ne peut pas démarrer correctement à partir du disque dur.
Vous obtiendrez un shell et vous pouvez exécuter diverses commandes
(<code>dmesg</code>, <code>lsmod</code>, <code>df</code>, <code>lspci</code>, …). Regardez le fichier
journal dans <code>/tmp/fai</code>. Vous y trouverez de nombreuses informations
sur le processus d’amorçage.</p></div>
<div class="paragraph"><p>FAI monte tous les systèmes de fichiers qu’il trouve sur les disques
locaux en lecture seule. Il vous indique également sur quelle partition
un fichier <em>/etc/fstab</em> existe. Lorsqu’une seule table de système de
fichiers est trouvée, les partitions sont montées selon ces
informations. Voici un exemple :</p></div>
<div class="listingblock">
<div class="content">
<pre><code>demohost:~# df -h

Filesystem                Size  Used Avail Use% Mounted on
devtmpfs                  4.0M     0  4.0M   0% /dev
tmpfs                     2.0G     0  2.0G   0% /dev/shm
tmpfs                     783M   18M  766M   3% /run
tmpfs                     5.0M     0  5.0M   0% /run/lock
LiveOS_rootfs             783M   18M  766M   3% /
192.168.33.250:/srv/fai/config   59G   23G   24G  49% /var/lib/fai/config
/dev/mapper/vg1-root      7.3G  1.8G  5.2G  26% /target
/dev/vda1                 459M   53M  378M  13% /target/boot
/dev/mapper/vg1-home      1.4G   72K  1.3G   1% /target/home</code></pre>
</div></div>
<div class="paragraph"><p><strong>Cette méthode peut être utilisée comme un environnement de sauvetage !</strong> Si
vous avez besoin d’un système de fichiers avec accès en
lecture/écriture, utilisez la commande <code>rwmount</code> :</p></div>
<div class="listingblock">
<div class="content">
<pre><code>demohost# rwmount /target/home</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_a_id_nonfs_a_fai_sans_nfs"><a id="nonfs"></a>FAI sans NFS</h3>
<div class="paragraph"><p>Pour démarrer dans FAI et commencer la séquence d’installation sans
utiliser le protocole NFS, vous démarrez la machine cliente en utilisant
PXE comme d’habitude, puis récupérez une image contenant le nfsroot via
http.</p></div>
<div class="paragraph"><p>Pour créer une image, utilisez l’argument -S de fai-cd et -M pour éviter de créer
un miroir partiel à l&#8217;intérieur de l&#8217;image.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>faiserver# fai-cd -M -S squash.img</code></pre>
</div></div>
<div class="paragraph"><p>Déplacez cette image vers un répertoire à partir duquel elle peut être
demandée via http (généralement un répertoire accessible par le serveur
web)</p></div>
<div class="paragraph"><p>Pour demander alors l’image squashfs, ajoutez ce qui suit à votre
ligne de commande du noyau, par exemple dans votre fichier de configuration
pxelinux pour le client avec fai-chboot.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>root=live:http://faiserver/cskoeln/squash.img FAI_CONFIG_SRC=file:///var/lib/fai/config</code></pre>
</div></div>
<div class="paragraph"><p>Remplacez faiserver par le nom de domaine ou l&#8217;IP de la machine de laquelle
votre image de squash est servie.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_otherdists_a_installation_d_autres_distributions_à_l_aide_d_un_nfsroot_debian"><a id="otherdists"></a>Installation d’autres distributions à l’aide d’un nfsroot Debian</h3>
<div class="paragraph"><p>Vous pouvez installer toutes sortes de distributions Linux à partir d’un
seul nfsroot Debian. Par conséquent, vous devez créer un fichier
base.tar.xz de la distribution que vous souhaitez installer et le placer
dans le répertoire <code>basefiles</code>. Puis nommez-le UBUNTU2204.tar.xz par
exemple. Un client d’installation appartenant à la classe UBUNTU2204
extrait ensuite ce fichier de base dans son système de fichiers vide. De
plus, vous devez ajuster les <em>sources.list</em> ou les fichiers de
configuration similaires nécessaires pour spécifier l’emplacement du
dépôt de paquets.</p></div>
<div class="paragraph"><p>L’outils <code>rinse(8)</code> est utilisé pour créer des fichiers de base pour
des distributions comme Rocky Linux, CentOS, openSUSE, ou Fedora.
Certains fichiers de base peuvent être téléchargés à partir de
<a href="https://fai-project.org/download/basefiles/">https://fai-project.org/download/basefiles/</a>.</p></div>
<div class="paragraph"><p>Le script <code>mk-basefile</code> dans
<em>/usr/share/doc/fai-doc/examples/simple/basefiles/</em> aide à créer ces
fichiers de base.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_dirinstall_a_création_d_environnements_chroot_et_de_virtualisation"><a id="dirinstall"></a>Création d’environnements chroot et de virtualisation</h3>
<div class="paragraph"><p>Si vous devez créer certains environnements chroot, ou un environnement
de virtualisation où vous ne pouvez ni ne voulez exécuter un programme
d’installation Debian normal pour accéder à un système opérationnel (par
exemple, les domaines hôtes Xen), il y a l’action FAI <em>dirinstall</em>. En
appelant :</p></div>
<div class="listingblock">
<div class="content">
<pre><code>faiserver# fai &lt;options&gt; dirinstall &lt;target-directory&gt;</code></pre>
</div></div>
<div class="paragraph"><p>et en utilisant l’option <em>-c &lt;classes&gt;</em> ou <em>-N</em> vous obtenez une
installation FAI, sans l’action de partitionnement, directement dans le
répertoire cible. Le nom d’hôte de la cible d&#8217;installation peut être
spécifié à l’aide de <em>-u &lt;nom-d-hote&gt;</em></p></div>
<div class="paragraph"><p>On peut utiliser cela, par exemple, pour combiner FAI avec les outils
<em>xen-tools</em>, qui vous aident à construire des domaines invités Xen.
Les <em>xen-tools</em> sont très agréables pour générer des fichiers de configuration
et bloquer des périphériques pour de nouveaux invités sur la base de
commandes simples et/ou des fichiers de configuration, mais ils ne
peuvent assigner qu’un seul rôle par installation pour la
personnalisation. Les utilisateurs de FAI ont besoin de plus et en veulent, car
ils ont l&#8217;habitude d&#8217;avoir le système de classes. Ils peuvent y arriver
même dans les installations xen-tools, en utilisant le code suivant en
tant que rôle xen-tools script :</p></div>
<div class="listingblock">
<div class="content">
<pre><code>#!/bin/sh
TARGET=$1
CMD="fai -N  -v -u ${hostname} dirinstall $TARGET"
echo running $CMD
$CMD</code></pre>
</div></div>
<div class="paragraph"><p>Ensuite, il faut définir la variable <em>install=0</em> dans la configuration
xen-tools pour cet hôte.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_softupdate_a_utilisation_de_fai_pour_les_mises_à_jour"><a id="softupdate"></a>Utilisation de FAI pour les mises à jour</h3>
<div class="paragraph"><p>FAI peut également effectuer des mises à jour de systèmes déjà en cours
d’exécution, sans réinstallation à partir de zéro. C’est ce qu’on
appelle softupdate. Un FAI softupdate ignore les tâches qui ne sont pas
adaptées à la mise à jour d’un système en cours d’exécution, comme le
partitionnement des disques durs et la création de systèmes de fichiers.
Au lieu de cela, il exécute uniquement les tâches de mise à jour et
d’installation des paquets logiciels et l’appel des scripts de
personnalisation.</p></div>
<div class="paragraph"><p>Pour lancer un softupdate :</p></div>
<div class="listingblock">
<div class="content">
<pre><code># fai -v -s nfs://faiserver/srv/fai/config softupdate</code></pre>
</div></div>
<div class="paragraph"><p>Par défaut, un softupdate utilise la liste des classes définies lors de
l’installation initiale. Assurez-vous de définir la variable
<code>$LOGSERVER</code> (ça se fait dans un fichier <em>class/*.var</em>) si FAI doit
enregistrer les fichiers journaux sur une machine distante.</p></div>
<div class="paragraph"><p>C’est à vous de décider, comment démarrer un softupdate sur un plus grand nombre
d’hôtes. Vous pouvez faire le softupdate sur régulièreent via cron
ou vous pouvez utiliser des outils comme <code>clusterssh(1)</code> pour démarrer
un softupdate via un push sur une liste d’hôtes.</p></div>
<div class="paragraph"><p>Gardez à l’esprit que les scripts de personnalisation sont exécutés
chaque fois que vous faites un softupdate. Cela signifie qu’ils doivent
être <strong>idempotents</strong>, c’est-à-dire que le résultat de leur fonctionnement
doit toujours produire le même résultat, même lorsqu’ils fonctionnent
plus d’une fois.</p></div>
<div class="paragraph"><p>Par exemple, l’ajout d’une ligne à un fichier ne doit pas se faire via ce code :</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ echo "some strings" &gt;&gt; /etc/fstab</code></pre>
</div></div>
<div class="paragraph"><p>Au lieu de ça, utilisez la commande <code>ainsl(1)</code> dans un script shell ou utilisez la fonction
de cfengine <em>AppendIfNoSuchLine</em>.</p></div>
<div class="paragraph"><p>Toutes les commandes du script de personnalisation doivent être capables
de modifier le système de fichiers cible qui’il soit disponible dans
<em>/target</em> lors de l’installation initiale ou qu&#8217;il soit le système de
fichiers normal relatif à <em>/</em> pendant le softtupdate.</p></div>
<div class="paragraph"><p>Voici quelques variables qui aident à écrire ces scripts :</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<code>$target</code>
</dt>
<dd>
<p>
Pointe vers le répertoire racine du client, qui est <em>/target</em> pendant
l’installation et <em>/</em> pendant un softupdate.
</p>
</dd>
<dt class="hdlist1">
<code>$FAI_ROOT</code>
</dt>
<dd>
<p>
C’est la même valeur que <code>$target</code>. Pour des raisons historiques,
on a ces deux variables dans FAI.
</p>
</dd>
<dt class="hdlist1">
<code>$ROOTCMD</code>
</dt>
<dd>
<p>
Dans le cas de l’installation, il s’agit d’un alias pour <em>chroot $target</em>
en cas de softupdate, c’est juste vide. Vous pouvez ajouter
ceci avant les commandes si vous avez besoin d’exécuter une commande dans le
système de fichiers cible des clients via chroot.
</p>
</dd>
<dt class="hdlist1">
<code>$FAI_ACTION</code>
</dt>
<dd>
<p>
Si vous devez appeler le code en fonction de l’action FAI effectuée,
vous pouvez utiliser cette variable. Elle contient l’action actuellement
exécutée: <em>install</em>, <em>softupdate</em>, <em>dirinstall</em>, <em>sysinfo</em>,
<em>inventory</em> ou votre propre action définie.
</p>
</dd>
</dl></div>
</div>
<div class="sect2">
<h3 id="_a_id_archcross_a_comment_installer_un_système_d_exploitation_32_bits_à_partir_d_un_système_d_exploitation_64_bits"><a id="archcross"></a>Comment installer un système d’exploitation 32 bits à partir d’un système d’exploitation 64 bits</h3>
<div class="paragraph"><p>Pour installer un ordinateur avec un système d’exploitation 32 bits,
vous avez besoin d’un nfsroot i386. La création de ce nfsroot 32 bits
sur un serveur d’installation qui fonctionne sous amd64 est simple.
Installez et configurez les paquets FAI. Copiez ensuite vos fichiers de
configuration FAI dans un nouveau sous-répertoire.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>faiserver# cp -a /etc/fai /etc/fai-i386</code></pre>
</div></div>
<div class="paragraph"><p>Modifiez la variable <code>$FAI_DEBOOTSTRAP_OPTS</code> dans
<em>/etc/fai-i386/nfsroot.conf</em> et ajoutez l’option <code>--arch i386</code>.
Choisissez également un répertoire différent pour votre nouveau nfsroot.
Voici les deux lignes après l&#8217;édition.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>NFSROOT=/srv/fai/nfsroot-i386
FAI_DEBOOTSTRAP_OPTS="--arch i386 --exclude=info --include=aptitude""</code></pre>
</div></div>
<div class="paragraph"><p>Appelez maintenant fai-make-nfsroot qui crée le nfsroot 32 bits dans
<em>/srv/fai/nfsroot-i386</em></p></div>
<div class="listingblock">
<div class="content">
<pre><code>faiserver# fai-make-nfsroot -v -C/etc/fai-i386</code></pre>
</div></div>
<div class="paragraph"><p>La création d’un miroir partiel utilisant <code>fai-mirror(1)</code> qui est nécessaire à
un CD amorçable ou une clé USB est également possible sur une
architecture différente. Vous devez spécifier l’architecture lors de
l’appel de fai-mirror.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ fai-mirror -m800 -B -a i386 -v -cDEFAULT,DEBIAN,FAIBASE,I386 /srv/mirror-i386</code></pre>
</div></div>
<div class="paragraph"><p>Et voilà !</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_error_a_arrêt_d_8217_urgence_de_l_8217_installation_quand_une_erreur_se_produit"><a id="error"></a>Arrêt d&#8217;urgence de l&#8217;installation quand une erreur se produit</h3>
<div class="paragraph"><p>Chaque tâche, chaque hook peut appeler la fonction <code>task_error</code>
pour envoyer une valeur d&#8217;erreur à l&#8217;installation. Cette erreur apparaîtra dans
le fichier de journalisation et peut être visionnée dans le <code>fai-monitor-gui(1)</code>.
La valeur de l&#8217;erreur est aussi examinée en tenant compte de la variable <code>$STOP_ON_ERROR</code>
qui est réglée à 700 par défaut. Si la valeur d&#8217;erreur est
supérieure à <code>$STOP_ON_ERROR</code>, l&#8217;installation s&#8217;arrêtera
immédiatment. Dans un hook, ajoutez simplement un appel comme celui-ci :</p></div>
<div class="listingblock">
<div class="content">
<pre><code>task_error &lt;valeur&gt;</code></pre>
</div></div>
<div class="paragraph"><p>C&#8217;est commode d&#8217;appeler task_error avec $? comme deuxième paramètre, par
exemple si on veut émettre une valeur d&#8217;erreur de 123 on peut faire ainsi</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;some command&gt;
task_error 123 $?</code></pre>
</div></div>
<div class="paragraph"><p>Alors, l&#8217;erreur de tâche n&#8217;est mise en place que si la commande précédente a échoué avec
une certaine erreur. La même syntaxe peut être utilisée par les scripts dans le sous-répertoire
de classe qui se terminent en .sh.</p></div>
<div class="paragraph"><p>Un cas particulier est celui des scripts dans le sous-répertoire class/ qui ne se termine
pas en .sh. Dans ces scripts il faut appeler task_error avec 1 comme
troisième paramètre. Par exemple on peut utiliser deux variantes pour
régler la valeur à 123</p></div>
<div class="listingblock">
<div class="content">
<pre><code>task_error 123 $? 1</code></pre>
</div></div>
<div class="paragraph"><p>ou</p></div>
<div class="listingblock">
<div class="content">
<pre><code>task_error 123 1 1</code></pre>
</div></div>
<div class="paragraph"><p>La dernière commande met toujours l&#8217;erreur de tâche à 123 sans tenir compte de $?.
Si la valeur d&#8217;erreur est supérieure à <code>$STOP_ON_ERROR</code>,
l&#8217;installation sera immédiatement stoppée.</p></div>
<div class="paragraph"><p>Les valeurs d&#8217;erreur sont regroupées dans quatre catégories</p></div>
<div class="listingblock">
<div class="content">
<pre><code>normale ou messages d'information :   1xx, 2xx
avertissements :                      3xx, 4xx
erreurs mineures :                    5xx, 6xx
erreurs :                             7xx, 8xx</code></pre>
</div></div>
<div class="paragraph"><p>Le fai-monitor-gui possède 4 icônes différentes pour ces catégories d&#8217;erreur.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_id_hints_a_divers_conseils_et_détails"><a id="hints"></a>Divers conseils et détails</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_a_id_tasks_a_la_liste_des_tâches"><a id="tasks"></a>La liste des tâches</h3>
<div class="paragraph"><p>La plupart des tâches de l’installation sont définies comme des
sous-routines qui sont définies dans <em>/usr/lib/fai/subroutines</em> (par
exemple <code>task_instsoft</code>). Certaines sont des scripts shell externes
situés dans <em>/usr/lib/fai/</em>. Elles sont appelées via un sous-programme
supérieur nommé <em>task</em>. Ce sous-programme appelle les hooks si
disponibles, puis appelle la tâche (définie comme <em>task</em>&lt;nom&gt;_). Une
tâche et ses hooks peuvent être ignorés à la demande en utilisant la
commande <em>skiptask()</em>.</p></div>
<div class="paragraph"><p>Voici maintenant la description de toutes les tâches, énumérées dans
l’ordre dans lequel elles sont exécutées.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
confdir
</dt>
<dd>
<p>
  Les paramètres ajoutés au noyau peuvent définir des variables, le
  démon syslog est démarré. Les paramètres de réseau sont récupérés d&#8217;un serveur DHCP
  et sont enregistrés dans <code>boot.log</code>. La configuration pour la résolution DNS est créée.
 <br />
  L’emplacement de l’espace de configuration est défini par la variable
  <code>$FAI_CONFIG_SRC</code>.
 <br />
  Ensuite, le fichier <em>$FAI/hooks/subroutines</em> est sourcé s’il existe.
  En utilisant ce fichier, vous pouvez définir vos propres
  sous-programmes ou remplacer la définition des sous-programmes de FAI.
</p>
</dd>
<dt class="hdlist1">
setup
</dt>
<dd>
<p>
  Cette tâche définit l’heure du système, tous les <code>$FAI_FLAGS</code> sont
  définis et deux terminaux virtuels supplémentaires sont ouverts à la
  demande. Un démon ssh est lancé à la demande pour les
  connexions à distance.
</p>
</dd>
<dt class="hdlist1">
defclass
</dt>
<dd>
<p>
  Appels de <code>fai-class(1)</code> pour définir des classes à l’aide de scripts
  et de fichiers dans <em>$FAI/class</em> et classes de
  <em>/tmp/fai/additional-classes</em> et la variable <code>$ADDCLASSES</code>. La liste
  de toutes les classes définies est stockée dans la variable
  <code>$classes</code> et enregistrée dans <em>/tmp/fai/FAI_CLASSES</em>.
</p>
</dd>
<dt class="hdlist1">
defvar
</dt>
<dd>
<p>
  Source tous les fichiers <em>$FAI/class/*.var</em> pour chaque classe
  définie. Si un hook a écrit quelques définitions de variables dans le
  fichier <em>$LOGDIR/additional.var</em>, ce fichier est également sourcé.
</p>
</dd>
<dt class="hdlist1">
action
</dt>
<dd>
<p>
  En fonction de la valeur de <code>$FAI_ACTION</code>, ce sous-programme décide
  de l’action FAI à exécuter. Les actions disponibles par défaut sont :
  <em>sysinfo</em>, <em>install</em>, <em>inventory</em>, <em>dirinstall</em> et <em>softupdate</em>. Si
  <code>$FAI_ACTION</code> a une autre valeur, une action définie par
  l’utilisateur est appelée si un fichier <em>$FAI/hooks/$FAI_ACTION</em>
  existe. Ainsi, vous pouvez facilement définir vos propres actions.
</p>
</dd>
<dt class="hdlist1">
sysinfo
</dt>
<dd>
<p>
  Appelée lorsque aucune installation n’est effectuée mais que l’action
  est <em>sysinfo</em>. Elle affiche des informations sur le matériel détecté et
  monte les disques durs locaux en lecture seule sur
  <em>/target/<code>partitionname</code></em> ou en tenant compte d’un fichier <em>fstab</em> trouvé à
  l’intérieur d’une partition. Les fichiers journaux sont stockés sur le
  serveur d’installation.
</p>
</dd>
<dt class="hdlist1">
inventory
</dt>
<dd>
<p>
  Une courte liste des informations système est imprimée.
</p>
</dd>
<dt class="hdlist1">
install
</dt>
<dd>
<p>
  Cette tâche contrôle la séquence d’installation. Vous entendrez trois
  bips avant le début de l’installation. Le travail principal consiste à
  appeler d’autres tâches et à enregistrer la sortie dans
  <em>/tmp/fai/fai.log</em>. Si vous avez des problèmes pendant l’installation,
  regardez tous les fichiers dans <em>/tmp/fai/</em>. Vous trouverez des
  exemples de fichiers journaux à l’adresse
  <a href="https://fai-project.org/logs/">https://fai-project.org/logs/</a>.
</p>
</dd>
<dt class="hdlist1">
dirinstall
</dt>
<dd>
<p>
  Installe dans un répertoire, et non pas sur un disque local.
  Utilisez-le pour créer des environnements chroot.
</p>
</dd>
<dt class="hdlist1">
softupdate
</dt>
<dd>
<p>
  Cette tâche, exécutée à l’intérieur d’un système en cours d’exécution
  via la commande en ligne <code>fai(8)</code>, effectue un
  softupdate. Voir le chapitre <a href="#softupdate">[softupdate]</a> pour plus
  de détails.
</p>
</dd>
<dt class="hdlist1">
partition
</dt>
<dd>
<p>
  Appelle <code>setup-storage(8)</code> pour partitionner les disques durs et
  créer des systèmes de fichiers. La tâche écrit des définitions de
  variables pour les partitions et périphériques racine et de démarrage
  (<code>$ROOT_PARTITION, $BOOT_PARTITION, $BOOT_DEVICE</code>) dans
  <em>/tmp/fai/disk_var.sh</em> et crée un fichier <em>fstab</em> pour le nouveau
  système.
</p>
</dd>
<dt class="hdlist1">
mountdisks
</dt>
<dd>
<p>
  Monte les partitions créées en fonction du fichier <em>/tmp/fai/fstab</em>
  créé par rapport à <code>$FAI_ROOT</code>.
</p>
</dd>
<dt class="hdlist1">
extrbase
</dt>
<dd>
<p>
  Extrait un système minimal après lequel un chroot puisse y être
  introduit. Par défaut, le fichier tar de base <em>/var/tmp/base.tar.xz</em> sera
  extrait. Les fichiers correspondant à un nom de classe dans
  <code>$FAI/basefiles/</code> sont également utilisés pour décompresser un autre
  fichier tar selon les classes définies. Cela peut être utilisé pour
  installer des distributions Linux différentes de celles utilisées pour
  créer le nfsroot. Le fichier par défaut <em>base.tar.xz</em> est un
  instantané d’un système Debian de base créé par <code>debootstrap(8)</code>
  Cette tâche utilise la variable <code>FAI_BASEFILEURL</code> pour récupérer le
  fichier de base via FTP, HTTPS ou HTTP si celle-ci est définie.
</p>
</dd>
<dt class="hdlist1">
debconf
</dt>
<dd>
<p>
  Appelle <code>fai-debconf(1)</code> pour définir les valeurs de la base de
  données de pré-ensemencement de debconf.
</p>
</dd>
<dt class="hdlist1">
repository
</dt>
<dd>
<p>
  Prépare l’accès au dépôt de paquets en préparant la
  configuration apt. Cela peut également ajouter des clés de dépôts
  en tenant compte des classes à partir de fichiers comme
  <em>CLASSNAME.gpg</em> dans le répertoire <em>package_config</em>.
</p>
</dd>
<dt class="hdlist1">
updatebase
</dt>
<dd>
<p>
  Met à jour les paquets de base du nouveau système et met à jour la
  liste des paquets disponibles. Il contrefait également certaines
  commandes (appelées diversions) à l’intérieur du nouveau système
  installé à l’aide de <code>dpkg-divert(8)</code>, de sorte qu’aucun démon ne
  soit démarré pendant l’installation.
</p>
</dd>
<dt class="hdlist1">
instsoft
</dt>
<dd>
<p>
  Installe les paquets logiciels souhaités en utilisant des fichiers de classe
  dans <em>$FAI/package_config/</em>.
</p>
</dd>
<dt class="hdlist1">
configure
</dt>
<dd>
<p>
  Appelle les scripts dans <em>$FAI/scripts/</em> et ses sous-répertoires pour
  chaque classe définie.
</p>
</dd>
<dt class="hdlist1">
tests
</dt>
<dd>
<p>
  Appelle les scripts de test dans <em>$FAI/tests/</em> et ses sous-répertoires
  pour chaque classe définie.
</p>
</dd>
<dt class="hdlist1">
finish
</dt>
<dd>
<p>
  Démonte tous les systèmes de fichiers dans le nouveau système installé
  et supprime les diversions de fichiers à l’aide de la commande
  <code>fai-divert</code>.
</p>
</dd>
<dt class="hdlist1">
chboot
</dt>
<dd>
<p>
  Modifie la configuration PXE d’un hôte sur le serveur d’installation,
  qui indique quelle configuration PXELINUX doit être chargée lors de la
  prochaine initialisation à partir de la carte réseau via TFTP. Par
  conséquent, la commande <code>fai-chboot(8)</code> est exécutée à distance sur
  le serveur d’installation.
</p>
</dd>
<dt class="hdlist1">
savelog
</dt>
<dd>
<p>
  Enregistre les fichiers journaux sur le disque local et sur le compte
  <code>$LOGUSER</code> sur <code>$LOGSERVER</code> (par défaut sur le serveur
  d’installation).
</p>
</dd>
<dt class="hdlist1">
faiend
</dt>
<dd>
<p>
  Attend que les travaux en arrière-plan se terminent (par exemple,
  qu&#8217;emacs compile des fichiers lisp) puis redémarre automatiquement les
  clients d’installation ou attend la saisie manuelle avant le
  redémarrage.
</p>
</dd>
</dl></div>
</div>
<div class="sect2">
<h3 id="_a_id_itests_a_tests_automatisés"><a id="itests"></a>Tests automatisés</h3>
<div class="paragraph"><p>Après l’exécution des scripts de personnalisation, FAI exécutera
certains tests si disponibles. En utilisant ces tests, vous pouvez
vérifier les erreurs de l’installation. Les scripts de test sont appelés
via <code>fai-do-scripts(1)</code> et doivent ajouter leurs messages à
<em>$LOGDIR/test.log</em>. Un module Perl comprenant des sous-routines utiles
peut être trouvé dans <em>Faitest.pm</em>. Un test peut également définir une
nouvelle classe pour exécuter d’autres tests lors du prochain démarrage
via la variable <code>$ADDCLASSES</code>.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_autodiscover_a_découvrir_automatiquement"><a id="autodiscover"></a>Découvrir automatiquement</h3>
<div class="paragraph"><p>Dans FAI 5.0, nous avons publié une fonctionnalité qui permet aux
clients de rechercher le faiserver dans leur sous-réseau respectif. Cela
soulève la nécessité de récupérer l’adresse MAC de chaque client et de
configurer le démon DHCP.</p></div>
<div class="paragraph"><p>Cela se fait en démarrant à partir d’une petit media vif autodiscover FAI
(CD, USB, etc.), qui peut être créé via la commande :</p></div>
<div class="listingblock">
<div class="content">
<pre><code>faiserver# fai-cd -A autodiscover.iso</code></pre>
</div></div>
<div class="paragraph"><p>L’image a une taille d’environ 25 Mo et analyse le sous-réseau d’un
serveur FAI. Par défaut, il affiche un menu avec tous les profils
disponibles dans l’espace de configuration de la même manière que
le fait l&#8217;option <em>menu</em>. Dans ce menu, vous pouvez sélectionner le type
d’installation que vous souhaitez effectuer.</p></div>
<div class="paragraph"><p>Pour que les clients puissent trouver le faiserver, le faiserver doit
lancer fai-monitor.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_changeboot_a_modification_du_périphérique_d_amorçage"><a id="changeboot"></a>Modification du périphérique d’amorçage</h3>
<div class="paragraph"><p>La modification de la séquence d’amorçage s’effectue normalement dans la
configuration du BIOS. Mais vous ne pouvez pas changer le BIOS d’un
système Linux en cours d’exécution.</p></div>
<div class="paragraph"><p>Ainsi, la séquence d’amorçage du BIOS restera inchangée et votre
ordinateur devrait toujours démarrer en premier à partir de sa carte
réseau et le deuxième périphérique d’amorçage devrait être le disque
local. Ensuite, vous pouvez changer le périphérique d’amorçage du client
en créant différentes configurations PXELINUX. Cela définira si une
installation doit être effectuée, ou si le client doit démarrer à partir
du disque local. Cela se fait à l’aide de <code>fai-chboot(8)</code>.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_debian_mirror_a_comment_créer_un_miroir_debian_local"><a id="debian-mirror"></a>Comment créer un miroir Debian local</h3>
<div class="paragraph"><p>Le script utilitaire <code>mkdebmirror</code> <span class="footnote"><br />[On peut trouver ce script dans
<em>/usr/share/doc/fai-doc/examples/utils/</em>]<br /></span> peut
être utilisé pour créer votre propre miroir Debian local. Ce script
utilise la commande <code>debmirror(1)</code>. Un miroir Debian partiel pour
l’architecture amd64 pour Debian 11 et 12 (noms de code bullseye et bookworm) sans les
paquets source nécessite environ 180 Go d’espace disque. L’accès au miroir
via HTTP sera la méthode par défaut dans la plupart des cas. Pour
afficher plus de résultats à partir du script, appelez
<code>mkdebmirror -v</code>. Un compte root n’est pas nécessaire pour créer et
maintenir le miroir Debian.</p></div>
<div class="paragraph"><p>Pour utiliser l’accès HTTP au miroir Debian local, installez un serveur
web et créez un lien symbolique vers le répertoire local où se trouve
votre miroir :</p></div>
<div class="listingblock">
<div class="content">
<pre><code>faiserver# apt-get install apache2
faiserver# ln -s /files/scratch/debmirror /var/www/html/debmirror</code></pre>
</div></div>
<div class="paragraph"><p>Créez un fichier <code>sources.list(5)</code> dans <em>/etc/fai/apt</em> qui donne accès
à votre miroir Debian. Ajoutez également l’adresse IP du serveur HTTP à
la variable <code>$NFSROOT_ETC_HOSTS</code> dans <em>nfsroot.conf</em> si les clients
d’installation n’ont pas de résolution DNS.</p></div>
</div>
<div class="sect2">
<h3 id="_petits_conseils">Petits conseils</h3>
<div class="ulist"><ul>
<li>
<p>
Lorsque vous utilisez l’accès HTTP à un miroir Debian, la partition
locale <em>/var</em> sur tous les clients d’installation doit être suffisamment
grande pour conserver les paquets Debian téléchargés. N’essayez pas avec
moins de 250 Moctets à moins que vous sachiez pourquoi. Vous pouvez
limiter le nombre de paquets installés à la fois avec la variable
<code>$MAXPACKAGES</code>.
</p>
</li>
<li>
<p>
Vous pouvez supprimer le logo rouge sur le client d’installation en
appelant simplement une fois <code>reset</code>. Il ne s’affichera pas si vous
créez un fichier à l’aide de cette commande sur le serveur
d’installation :
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content">
<pre><code>touch /srv/fai/nfsroot/.nocolorlogo</code></pre>
</div></div>
<div class="ulist"><ul>
<li>
<p>
Une liste des variables utilisées par FAI peut être trouvée à
<a href="https://wiki.fai-project.org/index.php/Variables">https://wiki.fai-project.org/index.php/Variables</a>.
</p>
</li>
<li>
<p>
Vous pouvez raccourcir certains scripts de personnalisation en
utilisant une seule commande fcopy <em>fcopy -r /</em>.
</p>
</li>
<li>
<p>
Si vous reconstruisez le nfsroot, vous allez créer une nouvelle clé
hôte ssh dans le nfsroot. La connexion à un client d’installation peut
échouer, car la clé hôte change. Vous pouvez utiliser ceci :
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content">
<pre><code>$ ssh -o StrictHostKeyChecking=no root@installclient</code></pre>
</div></div>
<div class="ulist"><ul>
<li>
<p>
Vous pouvez également supprimer l’entrée hôte de votre client
d’installation dans votre fichier <em>~/.ssh/known_hosts</em> à l’aide de la
commande <em>ssh-keygen -R</em>.
</p>
</li>
<li>
<p>
Dans les tâches chboot et savelog, une connexion utilisant un shell
sécurisé est ouverte vers le serveur FAI (voir <a href="#isavelog">[isavelog]</a>).
Pour garantir que cela fonctionne de manière non interactive, une entrée
appropriée dans <em>NFSROOT/root/.ssh/known_hosts</em> doit être créée. Lors de
l’utilisation de fai-setup, cela se fait automatiquement, mais il peut
s’avérer nécessaire de l&#8217;éditer manuellement si le nom de votre serveur
FAI n’a pas été correctement déterminé. Si vous trébuchez sur des
connexions ssh qui nécessitent de taper "yes" pour accepter la clé hôte
pendant l’installation, vérifiez le contenu de votre fichier
<em>NFSROOT/root/.ssh/known_hosts</em>
</p>
</li>
<li>
<p>
Une liste de tous les disques durs locaux est stockée dans
<code>$disklist</code>. Elle est définie après l’appel de <code>set_disk_info</code>.
</p>
</li>
<li>
<p>
Il y a de nombreuses fonctions pour générer un liste personnalisée
de disques. Voir <code>fai-disk-info</code> pour un exemple.
</p>
<div class="ulist"><ul>
<li>
<p>
set_bootstick()
</p>
</li>
<li>
<p>
grepv_disks()
</p>
</li>
<li>
<p>
grep_disks()
</p>
</li>
<li>
<p>
notmatchdisks()
</p>
</li>
<li>
<p>
matchdisks()
</p>
</li>
<li>
<p>
smallestdisk()
</p>
</li>
<li>
<p>
largestdisk()
</p>
</li>
<li>
<p>
all_disks_by_size()
</p>
</li>
<li>
<p>
all_disks_and_size()
</p>
</li>
<li>
<p>
once_only()
</p>
</li>
<li>
<p>
checkdisk()
</p>
</li>
<li>
<p>
disks_by_id()
</p>
</li>
</ul></div>
</li>
<li>
<p>
Utilisez <code>fai-divert -a</code> si un script postinst appelle un programme
de configuration, par exemple le script postinst pour  le paquet apache
appelle apacheconfig, qui nécessite une entrée manuelle. Vous pouvez
contrefaire le programme de configuration pour que l’installation puisse
être entièrement automatique.
</p>
</li>
<li>
<p>
Parfois, l’installation semble s’arrêter, mais souvent il y a seulement
un script postinstall d’un logiciel qui nécessite une entrée manuelle de
la console. Passez à un autre terminal virtuel et regardez quel
processus fonctionne avec des outils comme <code>top(1)</code> et <code>pstree(1)</code>.
Vous pouvez ajouter <em>debug</em> à <em>FAI_FLAGS</em> pour faire en sorte que le
processus d’installation affiche toutes les sorties des scripts postinst
sur la console et obtenir son entrée aussi à partir de la console.
</p>
</li>
<li>
<p>
Comment puis-je définir des classes sur la ligne de commande du noyau ?
</p>
<div class="paragraph"><p>Lire la page de manuel de <code>fai-class(8)</code>. Si vous voulez définir quelques
classes supplémentaires (par exemple A; B, C) dans la commande du noyau,
ajoutez ceci : <em>ADDCLASSES=A,B,C</em></p></div>
</li>
<li>
<p>
Comment utiliser un noyau personnalisé dans le nfsroot ?
</p>
<div class="paragraph"><p>Construisez votre noyau personnalisé en construisant un paquet kernelde noyau à
l’aide de <code>make-kpkg(8)</code> et utilisez l’option <code>--initrd</code>. Copiez ce
paquet Debian dans un dépôt local et ajoutez-le à
/etc/fai/sources.list. Ajoutez le nom de votre paquet à
/etc/fai/NFSROOT. Ensuite appelez</p></div>
<div class="listingblock">
<div class="content">
<pre><code># fai-make-nfsroot -k</code></pre>
</div></div>
</li>
<li>
<p>
Comment utiliser le nfsroot comme système pour les clients sans
disque ?
</p>
<div class="paragraph"><p><a href="https://wiki.fai-project.org/index.php/Use_nfsroot_for_diskless_clients">https://wiki.fai-project.org/index.php/Use_nfsroot_for_diskless_clients</a></p></div>
</li>
<li>
<p>
Comment faire pour servir plusieurs arborescence nfsroot sur un
serveur FAI ?
</p>
<div class="paragraph"><p>Si vous souhaitez diffuser plusieurs répertoires nfsroot, vous devez
créer des répertoires de configuration spécifiques dans <em>/etc</em> pour FAI,
comme <em>/etc/fai-buster</em> et <em>/etc/fai-bookworm</em>. Ensuite, vous devez
définir les variables <code>$NFSROOT</code> dans différents répertoires et
lancer</p></div>
</li>
</ul></div>
<div class="listingblock">
<div class="content">
<pre><code>faiserver#fai-make-nfsroot -C /etc/fai-buster</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_flag_reboot_fai_flags">flag_reboot (FAI_FLAGS)</h3>
<div class="paragraph"><p>Si flag_reboot est défini, en ajoutant "reboot" à <code>$FAI_FLAGS</code>, votre
ordinateur client redémarrera après la fin de la tâche faiend. Ceci est vrai
pour les installations par réseau ainsi que pour les installations par
media amorçable.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_logfiles_a_fichiers_journaux"><a id="logfiles"></a>Fichiers journaux</h3>
<div class="paragraph"><p>FAI crée plusieurs fichiers journaux. Pendant l’installation, ils sont
stockés dans <em>/tmp/fai</em> sur le client d’installation lui-même. A la fin
de l’installation, ils seront copiés sur le serveur d’installation (voir
<a href="#isavelog">[isavelog]</a>). Une fois le client d’installation redémarré
dans son système nouvellement installé, vous pouvez trouver les journaux
FAI dans <em>/var/log/fai</em>. Les fichiers journaux sont également créés lors
de l’action softupdate ou dirinstall.</p></div>
<div class="paragraph"><p>Sur le faiserver, vous pouvez trouver les fichiers journaux (distants)
sous le répertoire ~fai.</p></div>
<div class="paragraph"><p>Des exemples de fichiers journaux d&#8217;ordinateurs installés avec succès
sont disponibles sur <a href="https://fai-project.org/logs">https://fai-project.org/logs</a>. Ce sont quelques
fichiers journaux qui sont créés par FAI.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
FAI_CLASSES
</dt>
<dd>
<p>
  Contient une liste de toutes les classes définies.
</p>
</dd>
<dt class="hdlist1">
dmesg.log
</dt>
<dd>
<p>
  La sortie de la commande <code>dmesg</code>. Contient des messages utiles de la
  mémoire tampon du noyau.
</p>
</dd>
<dt class="hdlist1">
fai.log
</dt>
<dd>
<p>
  Le fichier journal principal. Contient toutes les informations
  importantes. Vous devez <strong>toujours</strong> lire ce fichier.
</p>
</dd>
<dt class="hdlist1">
boot.log
</dt>
<dd>
<p>
  Une liste de variables de paramètres de réseau, principalement définis
  par le démon DHCP.
</p>
</dd>
<dt class="hdlist1">
format.log
</dt>
<dd>
<p>
  Sortie de l’outil de partition <code>setup-storage(8)</code>.
</p>
</dd>
<dt class="hdlist1">
scripts.log
</dt>
<dd>
<p>
Sortie de tous les scripts, qui sont utilisés pour la personnalisation.
</p>
</dd>
<dt class="hdlist1">
variables.log
</dt>
<dd>
<p>
  Une liste de toutes les variables shell qui sont disponibles au cours
  d’une installation.
</p>
</dd>
<dt class="hdlist1">
error.log
</dt>
<dd>
<p>
  Résumé des erreurs possibles dans tous les fichiers journaux.
</p>
</dd>
<dt class="hdlist1">
disk_var.sh
</dt>
<dd>
<p>
  Une liste des variables contenant des informations sur les
  périphériques et les partitions à partir desquelles on démarre, la partition
  racine et une liste de périphériques de swap. Ces informations sont
  utilisées par certains scripts de personnalisation (par exemple
  <em>GRUB_PC/10-setup</em>).
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Si le processus d’installation se termine, le hook <em>savelog.LAST.sh</em>
recherche dans tous les fichiers journaux les erreurs courantes et les
écrit dans le fichier <em>error.log</em>. Donc, vous devriez d’abord regarder
dans ce fichier pour les erreurs. Le fichier <em>status.log</em> vous donne
également le code de sortie de la dernière commande exécutée dans un
script. Pour être sûr, vous devrez rechercher plus de détails dans tous
les fichiers journaux.</p></div>
</div>
<div class="sect2">
<h3 id="_comment_utiliser_http_pour_le_démarrage_pxe">Comment utiliser HTTP pour le démarrage PXE</h3>
<div class="paragraph"><p>fai-make-nfsroot utilise maintenant le fichier binaire lpxelinux.0 qui
prend en charge déjà le transfert du noyau et du fichier initrd via http
(en plus de tftp). Il vous suffit d&#8217;activer un accès HTTP au répertoire tftp :</p></div>
<div class="listingblock">
<div class="content">
<pre><code>cd /var/www/html
ln -s /srv/tftp/fai</code></pre>
</div></div>
<div class="paragraph"><p>Ajoutez <em>-U URL</em> à l’appel <em>fai-chboot</em>. Par exemple :</p></div>
<div class="listingblock">
<div class="content">
<pre><code>fai-chboot -U http://faiserver/fai -IFv .......</code></pre>
</div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_id_troubleshoot_a_dépannage"><a id="troubleshoot"></a>Dépannage</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_a_id_booterror_a_erreurs_d_amorçage"><a id="booterror"></a>Erreurs d’amorçage</h3>
<div class="paragraph"><p>Le message d’erreur suivant indique que votre client d’installation
n’obtient pas de réponse d’un serveur DHCP. Vérifiez vos câbles ou
démarrez le démon <code>dhcpd(8)</code> avec l&#8217;option debug activée.</p></div>
<div class="quoteblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre><code>PXE-E51: No DHCP or BOOTP offers received
Network boot aborted</code></pre>
</div></div>
</div>
<div class="attribution">
</div></div>
<div class="paragraph"><p>Si vous ne voyez pas le message suivant, le noyau d’installation n’a pas
pu détecter votre carte réseau, par exemple en raison d’un pilote
manquant :</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Starting dhcp for interface eth0
dhcp: PREINIT eth0 up
dhcp: BOND setting eth</code></pre>
</div></div>
<div class="paragraph"><p>Vérifiez le fichier initrd dans le nfsroot (<code>lsinird</code>) pour voir
si le pilote du noyau de
votre carte réseau est inclus et vérifiez si vous souhaitez ajouter le
paquet <em>firmware-linux-nonfree</em> dans <code>/etc/fai/NFSROOT` puis
reconstruisez le fichier initrd en appelant <code>fai-make-nfsroot -k</code>. Vous pouvez
également ajouter un pilote à +/srv/fai/nfsroot/etc/dracut.conf</code> dans
la ligne <code>add_drivers</code>+<code>=</code>.</p></div>
<div class="paragraph"><p>Voici le message d’erreur que vous verrez, lorsque votre carte réseau
fonctionne, mais le serveur d’installation n’exporte pas le répertoire
nfsroot vers les clients d’installation. Cela est souvent dû aux
permissions NFS manquantes du côté serveur.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Starting dhcp for interface eth0
dhcp: PREINIT eth0 up
dhcp: BOND setting eth
mount.nfs: access denied by server while mounting 192.168.33.250:/srv/fai/nfsroot
.
.
dracut Warning: Could not boot
.
Dropping to debug shell
dracut:/#</code></pre>
</div></div>
<div class="paragraph"><p>Maintenant, vous êtes à l’intérieur du shell d’urgence de l’initrd qui a
été créé par <em>dracut(8)</em>. Vous obtiendrez une invite du shell et pourrez
consulter les fichiers journaux. Pour plus d’informations sur le
débogage du processus de démarrage précoce à l’aide de dracut, consultez
<code>dracut.cmdline(7)</code></p></div>
<div class="paragraph"><p>Utilisez la commande suivante sur le serveur d’installation pour voir
quels répertoires sont exportés à partir du serveur d’installation
(nommé faiserver) :</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ showmount -e faiserver</code></pre>
</div></div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Version 6.4<br />
Last updated
 2025-10-25 13:23:56 CEST
</div>
</div>
</body>
</html>
