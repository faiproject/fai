<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 10.2.1" />
<title>FAI Guide (Fully Automatic Installation)</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

pre {
  padding: 0;
  margin: 0;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #777777;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }


/*
 * xhtml11 specific
 *
 * */

tt {
  font-family: monospace;
  font-size: inherit;
  color: navy;
}

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overridden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

.monospaced {
  font-family: monospace;
  font-size: inherit;
  color: navy;
}

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}


/*
 * Theme specific overrides of the preceding (asciidoc.css) CSS.
 *
 */
body {
  font-family: Garamond, Georgia, serif;
  font-size: 17px;
  color: #3E4349;
  line-height: 1.3em;
}
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Garmond, Georgia, serif;
  font-weight: normal;
  border-bottom-width: 0;
  color: #3E4349;
}
div.title, caption.title { color: #596673; font-weight: bold; }
h1 { font-size: 240%; }
h2 { font-size: 180%; }
h3 { font-size: 150%; }
h4 { font-size: 130%; }
h5 { font-size: 115%; }
h6 { font-size: 100%; }
#header h1 { margin-top: 0; }
#toc {
  color: #444444;
  line-height: 1.5;
  padding-top: 1.5em;
}
#toctitle {
  font-size: 20px;
}
#toc a {
    border-bottom: 1px dotted #999999;
    color: #444444 !important;
    text-decoration: none !important;
}
#toc a:hover {
    border-bottom: 1px solid #6D4100;
    color: #6D4100 !important;
    text-decoration: none !important;
}
div.toclevel1 { margin-top: 0.2em; font-size: 16px; }
div.toclevel2 { margin-top: 0.15em; font-size: 14px; }
em, dt, td.hdlist1 { color: black; }
strong { color: #3E4349; }
a { color: #004B6B; text-decoration: none; border-bottom: 1px dotted #004B6B; }
a:visited { color: #615FA0; border-bottom: 1px dotted #615FA0; }
a:hover { color: #6D4100; border-bottom: 1px solid #6D4100; }
div.tableblock > table, table.tableblock { border: 3px solid #E8E8E8; }
th.tableblock, td.tableblock { border: 1px solid #E8E8E8; }
ul > li > * { color: #3E4349; }
pre, tt, .monospaced { font-family: Consolas,Menlo,'Deja Vu Sans Mono','Bitstream Vera Sans Mono',monospace; }
tt, .monospaced { font-size: 0.9em; color: black;
}
div.exampleblock > div.content, div.sidebarblock > div.content, div.listingblock > div.content { border-width: 0 0 0 3px; border-color: #E8E8E8; }
div.verseblock { border-left-width: 0; margin-left: 3em; }
div.quoteblock { border-left-width: 3px; margin-left: 0; margin-right: 0;}
div.admonitionblock td.content { border-left: 3px solid #E8E8E8; }


@media screen {
  body {
    max-width: 50em; /* approximately 80 characters wide */
    margin-left: 16em;
  }

  #toc {
    position: fixed;
    top: 0;
    left: 0;
    bottom: 0;
    width: 13em;
    padding: 0.5em;
    padding-bottom: 1.5em;
    margin: 0;
    overflow: auto;
    border-right: 3px solid #f8f8f8;
    background-color: white;
  }

  #toc .toclevel1 {
    margin-top: 0.5em;
  }

  #toc .toclevel2 {
    margin-top: 0.25em;
    display: list-item;
    color: #aaaaaa;
  }

  #toctitle {
    margin-top: 0.5em;
  }
}
</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install(3);
/*]]>*/
</script>
</head>
<body class="article">
<div id="header">
<h1>FAI Guide (Fully Automatic Installation)</h1>
<span id="author">Thomas Lange</span><br />
<span id="email"><code>&lt;<a href="mailto:lange@debian.org">lange@debian.org</a>&gt;</code></span><br />
<span id="revnumber">version 6.4,</span>
<span id="revdate">Mer. 10 Avr 2025</span>
<div id="toc">
  <div id="toctitle">Table of Contents</div>
  <noscript><p><b>JavaScript must be enabled in your browser to display the table of contents.</b></p></noscript>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph"><p>Une version plus ancienne de ce guide en français est disponible à
<a href="https://fai-project.org/fai-guide-fr">https://fai-project.org/fai-guide-fr</a>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_résumé">Résumé</h2>
<div class="sectionbody">
<div class="paragraph"><p>FAI est un système non-interactif pour installer, configurer et gérer des
systèmes Linux et les configurations de logiciels sur des ordinateurs comme sur des machines
virtuelles et des environnements chroot, depuis des petits réseaux jusqu&#8217;à de
grandes infrastructures et de grands clusters.</p></div>
<div class="paragraph"><p>Ce manuel décrit le logiciel Fully Automatic Installation (installation entièrement automatique).
Cela inclut l’installation des paquets, la configuration du serveur, la
création de la configuration et la gestion des erreurs.</p></div>
<div class="paragraph"><p>(c) 2000-2025 Thomas Lange</p></div>
<div class="paragraph"><p>Ce manuel est un logiciel libre; Vous pouvez le redistribuer et / ou le
modifier selon les termes de la Licence Publique Générale GNU publiée
par la Free Software Foundation; Soit la version 2, soit (à votre choix)
toute version ultérieure.</p></div>
<div class="paragraph"><p>Ceci est distribué dans l’espoir qu’il sera utile, mais sans aucune
garantie ; Sans même la garantie implicite de qualité marchande ou
d’adaptation à un usage particulier. Pour plus de détails, consultez la
License Générale Publique GNU.</p></div>
<div class="paragraph"><p>Une copie de la Licence Générale Publique GNU est disponible sous la forme
/usr/share/common-licenses/GPL dans la distribution Debian GNU/Linux ou
sur le World Wide Web sur le site GNU Vous pouvez également l’obtenir en
écrivant à la Free Software Foundation , Inc., 59 Temple Place - Suite
330, Boston, MA 02111-1307, États-Unis.</p></div>
<div style="page-break-after:always"></div>
</div>
</div>
<div class="sect1">
<h2 id="_a_id_introduction_a_introduction"><a id="introduction"></a>Introduction</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_a_id_availability_a_disponibilité"><a id="availability"></a>Disponibilité</h3>
<div class="dlist"><dl>
<dt class="hdlist1">
Page d&#8217;accueil
</dt>
<dd>
<p>
<a href="https://fai-project.org">https://fai-project.org</a>
</p>
</dd>
<dt class="hdlist1">
Wiki FAI
</dt>
<dd>
<p>
<a href="https://wiki.fai-project.org">https://wiki.fai-project.org</a>
</p>
</dd>
<dt class="hdlist1">
Téléchargement
</dt>
<dd>
<p>
<a href="https://fai-project.org/download">https://fai-project.org/download</a>
</p>
</dd>
<dt class="hdlist1">
Entrée pour <em>sources.list</em>
</dt>
<dd>
<p>
<code>deb https://fai-project.org/download bookworm koeln</code>
</p>
</dd>
<dt class="hdlist1">
Pages de manuel
</dt>
<dd>
<p>
<a href="https://fai-project.org/doc/man/">https://fai-project.org/doc/man/</a>
</p>
</dd>
<dt class="hdlist1">
Listes de diffusion
</dt>
<dd>
<p>
<a href="https://lists.uni-koeln.de/mailman/listinfo/linux-fai">https://lists.uni-koeln.de/mailman/listinfo/linux-fai</a>
</p>
</dd>
<dt class="hdlist1">
Retour d&#8217;information
</dt>
<dd>
<p>
Envoyez vos réflexions et vos commentaires à <a href="mailto:fai@fai-project.org">fai@fai-project.org</a> ou
à la liste de diffusion.
</p>
</dd>
<dt class="hdlist1">
Boguess
</dt>
<dd>
<p>
Utiliser le système de suivi des bogues Debian (BTS) <a href="https://bugs.debian.org/src:fai">https://bugs.debian.org/src:fai</a>
</p>
</dd>
<dt class="hdlist1">
Changements visibles par l’utilisateur
</dt>
<dd>
<p>
<a href="http://fai-project.org/NEWS">http://fai-project.org/NEWS</a>
</p>
</dd>
<dt class="hdlist1">
Arbre source via git
</dt>
<dd>
<p>
git clone git://github.com/faiproject/fai.git
</p>
</dd>
<dt class="hdlist1">
Voir l’arbre source avec https
</dt>
<dd>
<p>
  <a href="https://github.com/faiproject/fai">https://github.com/faiproject/fai</a>
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Les pages man incluent toujours des informations à jour et beaucoup de
détails sur toutes les commandes FAI. Alors, n’oubliez pas de les lire
attentivement. Lisez maintenant ce manuel, puis profitez de
l’installation entièrement automatique et de votre temps économisé.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_motivation_a_motivation"><a id="motivation"></a>Motivation</h3>
<div class="paragraph"><p>Avez-vous déjà effectué des installations identiques d’un système
d’exploitation à plusieurs reprises? Souhaitez-vous être en mesure
d’installer un cluster Linux avec des dizaines de nœuds d&#8217;un seul coup?</p></div>
<div class="paragraph"><p>Répéter la même tâche encore et encore est ennuyeux&#8201;&#8212;&#8201;et conduira
certainement à des erreurs. Aussi beaucoup de temps pourrait être sauvé
si les installations étaient faites automatiquement. Un processus
d’installation avec interaction manuelle ne peut pas passer à l&#8217;échelle. Mais les
grappes (clusters) ont l’habitude de croître au fil des ans. Pensez à long terme
plutôt que de planifier seulement quelques mois dans l’avenir.</p></div>
<div class="paragraph"><p>En 1999, j’ai dû effectuer une installation d’un cluster Linux avec un
serveur et 16 clients. Puisque j’ai eu beaucoup d’expérience en faisant
des installations automatiques des systèmes d’exploitation de Solaris
sur le matériel de SUN SPARC, l’idée de construire une installation
automatique pour Debian est née. Solaris dispose d’une fonctionnalité
d’installation automatique appelée JumpStart
<span class="footnote"><br />[Solaris 8 Advanced Installation Guide at "https://docs.oracle.com/cd/E19455-01/806-0957/806-0957.pdf]<br /></span>.
En conjonction avec les scripts d’auto-installation de Casper Dik
<span class="footnote"><br />[<a href="http://www.science.uva.nl/pub/solaris/auto-install">http://www.science.uva.nl/pub/solaris/auto-install</a>]<br /></span>,
Je pouvais épargner beaucoup de temps non seulement pour chaque nouvel
ordinateur de SUN, mais aussi pour la réinstallation des postes de
travail existants. Par exemple, j’ai dû construire un LAN temporaire
avec quatre stations de travail SUN pour une conférence, qui a duré
seulement quelques jours. J’ai retiré ces postes de travail de notre
réseau de recherche habituel et mis en place une nouvelle installation
pour la conférence. Quand elle a été terminée, j’ai simplement réintégré les
postes de travail dans le réseau de recherche, redémarré une seule fois,
et après une demi-heure, tout était opérationnel comme avant. La
configuration de tous les postes de travail était exactement la même
qu’avant la conférence, car tout était effectué par le même processus
d’installation. J’ai également utilisé l’installation automatique pour
réinstaller un poste de travail après qu&#8217;un disque dur endommagé ait été
remplacé. Il m’a fallu deux semaines pour recevoir le nouveau disque
dur, mais seulement quelques minutes après l’installation du nouveau
disque, le poste de travail fonctionnait comme avant. Et c’est pourquoi
j’ai choisi d’adapter cette technique à un cluster de PC sous Linux.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_work_a_comment_fonctionne_fai"><a id="work"></a>Comment fonctionne FAI</h3>
<div class="paragraph"><p>Le client d’installation qui sera installé à l’aide de FAI, est démarré
via une carte réseau ou à partir d’un CD ou d’une clé USB. Il obtient
une adresse IP et démarre un noyau Linux qui monte son système de
fichiers racine via NFS (nfsroot) du serveur d’installation. Une fois le
noyau démarré, le script de démarrage FAI exécute l’installation
automatique qui n’a pas besoin d’interaction. Tout d’abord, les disques
durs seront partitionnés, les systèmes de fichiers seront créés et des
paquets logiciels seront ensuite installés. Après cela, le nouveau système
d’exploitation installé est configuré selon vos besoins locaux en
utilisant quelques scripts. Enfin, le nouveau système d’exploitation
sera démarré à partir du disque local.</p></div>
<div class="paragraph"><p>Les détails sur la façon d’installer l’ordinateur (la configuration)
sont stockés dans l’espace de configuration sur le serveur d’installation.
Les fichiers de configuration sont répartis entre des groupes
d’ordinateurs s’ils sont similaires, en utilisant le concept de classe.
Vous n’avez donc pas besoin de créer une configuration pour chaque
nouvel hôte. Ainsi, FAI est une méthode évolutive pour
installer un gros cluster avec un grand nombre de nœuds même si leur
configuration n’est pas identique.</p></div>
<div class="paragraph"><p>FAI peut également être utilisé comme un système de sauvetage ou pour
l’inventaire matériel. Vous pouvez démarrer votre ordinateur, mais il
n’effectuera pas une installation. Au lieu de cela, il exécutera un
Debian GNU / Linux entièrement fonctionnel sans utiliser les disques
durs locaux. Ensuite, vous pouvez effectuer une connexion à distance et
sauvegarder ou restaurer une partition de disque, vérifier un système de
fichiers, inspecter le matériel ou effectuer toute autre tâche.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_features_a_caractéristiques"><a id="features"></a>Caractéristiques</h3>
<div class="ulist"><ul>
<li>
<p>
On peut faire une installation entièrement automatisée.
</p>
</li>
<li>
<p>
Installation très rapide sans surveillance.
</p>
</li>
<li>
<p>
Système flexible grâce à un concept de classe simple.
</p>
</li>
<li>
<p>
Mise à jour des systèmes en cours d’exécution sans réinstallation.
</p>
</li>
<li>
<p>
Images « Cloud » pour un environnement de virtualisation.
</p>
</li>
<li>
<p>
Les hôtes peuvent démarrer à partir d’une carte réseau, d’un CD, d’une clé USB.
</p>
</li>
<li>
<p>
Création simple d’une image ISO vive ou pour l&#8217;installation.
</p>
</li>
<li>
<p>
Prise en charge  de PXE avec la méthode de démarrage DHCP.
</p>
</li>
<li>
<p>
Support des systèmes de fichiers ReiserFS, ext3/ext4, btrfs et XFS.
</p>
</li>
<li>
<p>
Support logiciel RAID et LVM. Support LUKS.
</p>
</li>
<li>
<p>
Détection automatique du matériel.
</p>
</li>
<li>
<p>
On peut déployer Debian, Ubuntu, Rocky Linux, CentOS, AlmaLinux, SuSE
</p>
</li>
<li>
<p>
Possibilité de connexion à distance via ssh lors du processus d’installation.
</p>
</li>
<li>
<p>
Toutes les configurations similaires sont partagées entre tous les les clients d’installation.
</p>
</li>
<li>
<p>
Les fichiers journaux de toutes les installations sont enregistrés sur le serveur d’installation.
</p>
</li>
<li>
<p>
Prise en charge des scripts Shell, Perl, Python, Ruby, expect et CFEngine lors de l&#8217;étape de personnalisation.
</p>
</li>
<li>
<p>
Prise en charge de nombreux protocoles comme NFS, FTP, HTTP, git.
</p>
</li>
<li>
<p>
Peut être utilisé comme un système de sauvetage et pour l’inventaire matériel.
</p>
</li>
<li>
<p>
Prise en charge de clients sans disque.
</p>
</li>
<li>
<p>
Prise en charge trans-architecture, par exemple pour des appareils embarqués (embedded devices).
</p>
</li>
<li>
<p>
Ajoutez facilement vos propres fonctions via des hooks ou modifiez le comportement par défaut.
</p>
</li>
<li>
<p>
Prise en charge du clonage de machines utilisant des images de disque.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_la_durée_d_8217_installation">La durée d&#8217;installation</h3>
<div class="paragraph"><p>La durée d’installation est déterminée par la quantité de logiciel et la
vitesse du disque dur. Voici quelques exemples de durée. Tous les
clients d’installation avaient une carte réseau 1Gbit installée.</p></div>
<div class="tableblock">
<table rules="all"
width="80%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="26%" />
<col width="13%" />
<col width="20%" />
<col width="26%" />
<col width="13%" />
<thead>
<tr>
<th align="left" valign="top"> CPU  </th>
<th align="center" valign="top">  RAM </th>
<th align="left" valign="top">   Disque    </th>
<th align="right" valign="top">   Logiciels installés  </th>
<th align="right" valign="top"> durée</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">i7-3770T 2.50GHz</p></td>
<td align="center" valign="top"><p class="table">8GB</p></td>
<td align="left" valign="top"><p class="table">SSD</p></td>
<td align="right" valign="top"><p class="table">6 GB logiciel</p></td>
<td align="right" valign="top"><p class="table">8.5 min</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Core-i7 3.2GHz</p></td>
<td align="center" valign="top"><p class="table">6GB</p></td>
<td align="left" valign="top"><p class="table">SATA disk</p></td>
<td align="right" valign="top"><p class="table">4.3GB logiciel</p></td>
<td align="right" valign="top"><p class="table">7 min</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Core-i7 3.2GHz</p></td>
<td align="center" valign="top"><p class="table">6GB</p></td>
<td align="left" valign="top"><p class="table">SATA disk</p></td>
<td align="right" valign="top"><p class="table">471 MB logiciel</p></td>
<td align="right" valign="top"><p class="table">77sec</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Intel Core2 Duo</p></td>
<td align="center" valign="top"><p class="table">2GB</p></td>
<td align="left" valign="top"><p class="table">SATA disk</p></td>
<td align="right" valign="top"><p class="table">3 GB logiciel</p></td>
<td align="right" valign="top"><p class="table">14 min</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_id_impatient_a_quickstart_pour_l_8217_utilisateur_impatient"><a id="impatient"></a>Quickstart - Pour l&#8217;utilisateur impatient</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_a_id_first_a_ma_première_installation"><a id="first"></a>Ma première installation</h3>
<div class="paragraph"><p>Sans plus tarder, cette section fournira une démonstration rapide et
facile d’une installation entièrement automatique à l’aide du CD FAI et
d’une machine virtuelle.</p></div>
<div class="paragraph"><p>Il suffit de télécharger l' image ISO du CD à partir de
<a href="https://fai-project.org/fai-cd">https://fai-project.org/fai-cd</a> et de démarrer votre VM à l’aide de ce CD.
Vous verrez un menu grub où vous pouvez choisir parmi différents types
d’installation.</p></div>
<div class="paragraph"><p>Cette installation s’exécutera sans serveur d’installation.
L’installation à partir du CD est identique à celle exécutée dans un
environnement réseau à l’aide du serveur d’installation FAI, et peut être aussi
effectuée à l&#8217;aide d&#8217;une clé USB sur un ordinateur physique.</p></div>
<div class="paragraph"><p>On peut aussi créer soi-même une image FAI (installation entièrement automatique)
à la page web <a href="https://fai-project.org/FAIme">https://fai-project.org/FAIme</a> sans avoir besoin d&#8217;installer
FAI sur son ordinateur.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_cdserver_a_ma_première_installation_à_l_8217_aide_d_8217_un_serveur"><a id="cdserver"></a>Ma première installation à l&#8217;aide d&#8217;un serveur</h3>
<div class="paragraph"><p>Nous allons créer un réseau privé et lancer deux machines vituelles. L&#8217;une
deviendra votre propre serveur FAI, l&#8217;autre sera un client d&#8217;installation.</p></div>
<div class="paragraph"><p>Si vous avez l’intention d’utiliser VMware ou VirtualBox, assurez-vous
que votre client utilise une connexion réseau pontée (bridged network).
On trouve une description détaillée dans le wiki FAI
<span class="footnote"><br />[<a href="https://wiki.fai-project.org/index.php/VirtualBox_for_your_first_FAI_installation">https://wiki.fai-project.org/index.php/VirtualBox_for_your_first_FAI_installation</a>]<br /></span>.
on ne peut pas utiliser des interfaces réseau pontées via le réseau sans
fil, car la plupart des cartes réseau WiFi ne prennent pas en charge
cette fonctionnalité.</p></div>
<div class="paragraph"><p>Quand on utilise Qemu/KVM et le script <code>fai-kvm</code> on peut créer le réseau à l&#8217;aide de
la commande <code>fai-mk-network</code>. Il faut commencer par installer quelques paquets logiciels</p></div>
<div class="listingblock">
<div class="content">
<pre><code># apt-get install qemu-system-gui qemu-kvm qemu-utils</code></pre>
</div></div>
<div class="paragraph"><p>La commande ci-dessous met en place un réseau privé avec un pont logiciel et plusieurs
TAPs réseau
<span class="footnote"><br />[<a href="https://fr.wikipedia.org/wiki/TAP_r%C3%A9seau">https://fr.wikipedia.org/wiki/TAP_r%C3%A9seau</a>]<br /></span>
appartenant à l&#8217;utilisateur <code>&lt;nom_d_utilisateur&gt;</code>.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>fai-mk-network &lt;nom_d_utilisateur&gt;</code></pre>
</div></div>
<div class="paragraph"><p>Après cela, vous pouvez utiliser fai-kvm (-h vous aidera) pour démarrer
des machines virtuelles en utilisant KVM qui sont connectés à ce réseau
privé. Faites attention. Par défaut, fai-kvm créera les images de disque
pour les machines virtuelles dans <code>+/tmp+</code>, qui est un disque RAM sur la plupart des
systèmes. Il n’y a aucun problème à créer une image de disque vide de
20G dans /tmp (même si cette partition est de 4 Go de taille), mais
alors que la VM écrit des données sur son disque, cela commencera à
consommer de l’espace dans <code>+/tmp+</code>.</p></div>
<div class="paragraph"><p>Démarrez le premier hôte virtuel, qui deviendra le serveur FAI
<span class="footnote"><br />[Cette installation utilisera environ 2GB d&#8217;espace dans <code>/tmp</code>.]<br /></span> :</p></div>
<div class="listingblock">
<div class="content">
<pre><code>fai-kvm -Vn -s20 -u 1 cd faicd64-small.iso</code></pre>
</div></div>
<div class="paragraph"><p>Dans le menu grub; sélectionnez <code>faiserver, using internal DHCP and a fixed IP</code>.
Cela va installer
un hôte appelé faiserver avec IP 192.168.33.250 qui contient tous les
logiciels nécessaires pour un serveur FAI. Il configurera également un
cache de paquets local (en utilisant apt-cacher-ng). Une fois
l’installation terminée, redémarrez la machine. Lors du premier
démarrage du nouveau système, il configurera automatiquement le nfsroot.
Cela peut prendre quelques minutes.</p></div>
<div class="paragraph"><p>Après cela, vous pouvez démarrer des hôtes supplémentaires en utilisant
un démarrage réseau. Pour chaque nouvel hôte, vous devez utiliser une
valeur différente pour <code>+-u+</code>, qui sera utilisée pour générer des
adresses MAC différentes et utiliser des noms de fichier d’image de
disque différents.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>fai-kvm -Vn -u 2 pxe</code></pre>
</div></div>
<div class="paragraph"><p>Ces clients d’installation vous montreront un menu, où vous pouvez
sélectionner le type d’installation que vous souhaitez effectuer. Si le
client d’installation ne trouve pas le serveur, c’est généralement parce
que fai-monitor n&#8217;y fonctionne plus. Cela peut se produire si vous
redémarrez le faiserver après l’installation. Pour remédier à cela,
exécutez simplement fai-monitor sur le faiserver et relancez le
démarrage du client.</p></div>
<div class="paragraph"><p>Un autre client pourrait être lancé avec:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>fai-kvm -Vn -u 3 pxe</code></pre>
</div></div>
<div class="paragraph"><p>Vous pouvez démarrer autant de machines dans le réseau que de TAPs réseau
disponibles. Toutes ces machines peuvent se
connecter à l’Internet extérieur, mais sont seulement accessibles à
partir de votre machine hôte.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_id_overview_a_vue_d_8217_ensemble_et_concepts"><a id="overview"></a>Vue d&#8217;ensemble et Concepts</h2>
<div class="sectionbody">
<div class="paragraph"><p>FAI est un système non interactif permettant d’installer, de
personnaliser et de gérer les configurations de systèmes et de logiciels
Linux sur les ordinateurs ainsi que sur les machines virtuelles et les
environnements chroot, des petits réseaux aux grandes infrastructures et
clusters. Vous pouvez prendre un ou plusieurs PC vierges, mettre sous
tension et après quelques minutes, Linux est installé, configuré et
fonctionnel sur l’ensemble du cluster, sans aucune interaction nécessaire.
Ainsi, il s’agit d’une méthode évolutive pour installer et mettre à jour
un cluster sans surveillance impliquant peu d’efforts. FAI utilise
le système d’exploitation Linux et une collection de scripts shell et
Perl pour le processus d’installation. Les modifications apportées aux
fichiers de configuration du système d’exploitation peuvent être
effectuées par des scripts CFEngine, shell (bash et zsh), Perl, Python, Ruby et
expect.</p></div>
<div class="paragraph"><p>Les personnes intéressées par FAI sont des administrateurs système qui doivent
installer Linux sur une ou même des centaines d’ordinateurs. Parce qu’il
s’agit d’un outil d’installation à usage général, il peut être utilisé
pour l’installation d’un cluster Beowulf, d’une ferme de rendu ou
d’un laboratoire Linux ou d’une salle de classe. De plus, des réseaux
Linux de grande envergure avec différents matériels ou différentes
exigences d’installation sont faciles à établir à l’aide de FAI. Mais
n’oubliez pas de planifier votre installation. Le chapitre
<a href="#plan">[plan]</a> contient quelques conseils utiles à ce sujet.</p></div>
<div class="sect2">
<h3 id="_a_id_terms_a_terminologie"><a id="terms"></a> Terminologie</h3>
<div class="paragraph"><p>Commençons par décrire quelques termes utilisés dans ce manuel.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Le serveur d&#8217;installation 
</dt>
<dd>
<p>
Il fournit les services DHCP, TFTP et NFS ainsi que les données de
configuration pour tous les clients d’installation. Dans les exemples
de ce manuel, cet hôte s’appelle <em>faiserver</em>. C&#8217;est l’hôte où le paquet
<em>faiserver</em> est installé.
</p>
</dd>
<dt class="hdlist1">
Le client d&#8217;installation 
</dt>
<dd>
<p>
Un hôte qui sera installé à l’aide de FAI et une configuration fournie
par le serveur d’installation. Aussi appelé client pour faire court. Dans
ce manuel, les hôtes d’exemple sont appelés demohost, xfcehost,
gnomehost … Cet ordinateur doit démarrer à partir de son interface
réseau à l’aide de PXE.
</p>
</dd>
<dt class="hdlist1">
Espace de configuration
</dt>
<dd>
<p>
Une structure de sous-répertoire contenant plusieurs fichiers. Ces
fichiers décrivent les détails de la manière dont l’installation des
clients sera effectuée. Toutes les données de configuration sont
stockées là. Il est également appelé <em>config space</em> pour faire court. Il
comprend des informations sur :
</p>
<div class="ulist"><ul>
<li>
<p>
Organisation du disque dur dans un format similaire à fstab
</p>
</li>
<li>
<p>
Systèmes de fichiers locaux, leurs types, points de montage et options de montage
</p>
</li>
<li>
<p>
Paquets logiciels
</p>
</li>
<li>
<p>
Disposition du clavier, fuseau horaire, configuration Xorg, systèmes de fichiers distants, comptes utilisateurs, imprimantes …
</p>
</li>
</ul></div>
<div class="paragraph"><p>Le package <em>fai-doc</em> inclut un exemple d’espace de configuration
incluant des exemples pour les hôtes utilisant l’environnement XFCE et
GNOME entre autres. En invoquant <code>fai-mk-configspace</code> on copie ces exemples vers
<em>/srv/fai/config</em>. Il est recommandé d&#8217;étudier ces fichiers de configuration et
ces scripts pour mieux comprendre comment FAI fonctionne.</p></div>
</dd>
<dt class="hdlist1">
nfsroot, NFS-Root 
</dt>
<dd>
<p>
Un système de fichiers situé sur le serveur d’installation. Pendant le
processus d’installation, c’est le système de fichiers complet pour
les clients d’installation. Tous les clients partagent le même
nfsroot, qu’ils montent en lecture seule. Le nfsroot a besoin
d’environ 1.1Go d’espace disque libre.
</p>
</dd>
<dt class="hdlist1">
TFTP 
</dt>
<dd>
<p>
Sert aux clients le fichier initrd et le noyau utilisés pour le processus
d’installation. Avec le système de fichiers servi par NFS, ces deux
composent un système d&#8217;exploitation temporaire dans lequel les installations sont
réalisées.
</p>
</dd>
<dt class="hdlist1">
Classes FAI 
</dt>
<dd>
<p>
Les classes sont des noms qui déterminent quel fichier de
configuration est sélectionné. Si un client appartient à la classe
WEBSERVER, il sera configuré en tant que serveur Web, la classe
DESKTOP pour, par exemple, déterminer les paquets logiciels qui seront
installés.
</p>
</dd>
<dt class="hdlist1">
profil 
</dt>
<dd>
<p>
Un profil FAI est juste une liste de classes FAI assignées à un nom de
profil, qui est étendu par une description de ce profil. C’est-à-dire
que l’on peut avoir deux profils "Webserver", l’un incluant la classe
APACHE, et un autre incluant la classe NGINX, pour ensuite installer la solution
de serveur web correspondante.
</p>
</dd>
<dt class="hdlist1">
les tâches 
</dt>
<dd>
<p>
L’installation d’un client se compose de plusieurs parties, appelées
tâches. Les tâches sont des sous-programmes prédéfinis qui effectuent
une certaine partie de la FAI. Les tâches FAI suivantes sont exécutées
au cours d’une installation sur les clients d’installation.
</p>
</dd>
</dl></div>
<div class="quoteblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre><code>confdir               # trouver l'espace de configuration
setup                 # quelques initialisations, lancement de sshd à la demande
defclass              # définition des classes FAI
defvar                # définition de variables
action                # évaluer FAI_ACTION
install               # Démarrer l'installation
partition             # partitionner les disques durs, créer les systèmes de fichiers
mountdisks            # monter les systèmes de fichiers
extrbase              # extraire le fichier base.tar.xz
debconf               # pré-ensemencer le deconf de Debian
repository            # préparer l'accès aux dépôts de paquets
updatebase            # mettre en place les outils de gestion de paquets et mettre les paquets à jour
instsoft              # installer les paquets logiciels
configure             # lancer les scripts de personnalisation
finish                # faire un peu de ménage, afficher les statistiques d'installation
tests                 # appeler des tests s'il y en a
chboot                # lancer fai-chboot sur le serveur d'installation
savelog               # enregistrer les fichiers de journalisation localement et à distance
faiend                # redémarrage de l'hôte, éjection du CD si nécessaire</code></pre>
</div></div>
</div>
<div class="attribution">
</div></div>
<div class="quoteblock">
<div class="content">
<div class="paragraph"><p>Voilà des tâches qui sont exécutées seulement lorsqu’on fait une action différente</p></div>
<div class="literalblock">
<div class="content">
<pre><code>dirinstall           # installer un environnement chroot
softupdate           # ne faire que la configuration du système
sysinfo              # imprimer une information système détaillée
inventory            # imprimer un inventaire court du matériel</code></pre>
</div></div>
</div>
<div class="attribution">
</div></div>
<div class="paragraph"><p>Pour une description plus détaillée des <em>tâches</em> , voir <a href="#tasks">[tasks]</a>.</p></div>
<div class="paragraph"><p>Notez que vous n&#8217;êtes pas limité aux tâches FAI. Vous pouvez également
définir des programmes ou des scripts supplémentaires qui seront
exécutés à certaines occasions. On les appelle des <em>hooks</em>.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
hooks
</dt>
<dd>
<p>
Les Hooks sont des plugins, ils peuvent ajouter des fonctionnalités
supplémentaires au processus d’installation ou même remplacer des
tâches entières de FAI. Les Hooks sont expliqués en détail dans
<a href="#hooks">[hooks]</a>.
</p>
</dd>
</dl></div>
</div>
<div class="sect2">
<h3 id="_a_id_classc_a_le_concept_de_classe"><a id="classc"></a>Le concept de classe</h3>
<div class="paragraph"><p>Les classes sont utilisées dans presque toutes les tâches de
l’installation. Les classes déterminent quels fichiers de configuration
choisir parmi une liste d’alternatives disponibles. Pour déterminer les
fichiers de configuration à utiliser, FAI recherche dans la liste des classes
définies et utilise tous les fichiers de configuration correspondant à
un nom de classe <span class="footnote"><br />[on peut aussi seulement utiliser le fichier de configuration
qui a la priorité la plus élevée, comme l&#8217;ordre des classes définit une
priorité de la plus basse à la plus élevée dans la liste des classes.  ]<br /></span>. La boucle suivante
implémente cette fonction en pseudo-code shell :</p></div>
<div class="listingblock">
<div class="content">
<pre><code>for class in $all_classes; do
   if [ -r $config_dir/$class ]; then      # s'il exite un fichier nommé $class
      your_command $config_dir/$class      # invoquer une commande avec ce nom de fichier
      # sortir si on n'a besoin que du premier fichier qui convient
   fi
done</code></pre>
</div></div>
<div class="paragraph"><p>La beauté de ceci c&#8217;est qu&#8217;on peut ajouter
une nouvelle alternative de configuration et qu&#8217;elle sera automatiquement
utilisée par FAI sans modifier le code, si le fichier de configuration
utilise un nom de classe.</p></div>
<div class="paragraph"><p>C’est parce que la boucle détecte automatiquement les nouveaux fichiers
de configuration qui doivent être utilisés. L’idée d’utiliser des
classes en général et d’utiliser certains fichiers correspondant à un
nom de classe pour une configuration est adoptée à partir des scripts
d’installation par Casper Dik pour Solaris. Cette technique s’est avérée
très utile et facile.</p></div>
<div class="paragraph"><p>Vous pouvez regrouper plusieurs hôtes partageant les mêmes fichiers de
configuration en utilisant la même classe. Vous pouvez également diviser
l’ensemble des données de configuration pour tous les clients en
plusieurs classes et les utiliser comme des briques de lego et
construire la configuration entière pour un seul client en assemblant
les briques.</p></div>
<div class="paragraph"><p>Si un client appartient à la classe <em>A</em>, on dit que la classe <em>A</em>
est définie pour ce client. Une classe n’a pas de valeur, elle est juste
définie ou indéfinie.</p></div>
<div class="paragraph"><p>Les classes déterminent comment l’installation est effectuée. Par
exemple, un client d’installation peut être configuré pour obtenir le
bureau XFCE en y ajoutant simplement la classe <em>XFCE</em> . Naturellement,
des configurations plus granulaires sont également possibles. Par
exemple, les classes peuvent décrire comment le disque dur doit être
partitionné, elles peuvent définir quels paquets logiciels seront
installés, ou quelles étapes de personnalisation seront exécutées.</p></div>
<div class="paragraph"><p>Souvent, une configuration client est juste créée en modifiant ou en ajoutant
les classes auxquelles ce client appartient, ce qui rend
l’installation d’un nouveau client très facile. Ainsi, aucune
information supplémentaire ne doit être ajoutée à l’espace de
configuration si les classes existantes suffisent à vos besoins.</p></div>
<div class="paragraph"><p>Comme vous pouvez le voir, les classes sont un pilier central de la
personnalisation de votre espace de configuration et de celui de
de votre client d&#8217;installation. Pour définir vos propres classes, reportez-vous à
<a href="#defining classes">[defining classes]</a>.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_id_setup_a_configurer_votre_faiserver"><a id="setup"></a>Configurer votre faiserver</h2>
<div class="sectionbody">
<div class="paragraph"><p>Voici comment configurer le serveur d’installation en quelques minutes.
Les étapes suivantes sont nécessaires :</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Configurer le serveur d’installation
</p>
<div class="olist loweralpha"><ol class="loweralpha">
<li>
<p>
Installer les paquets de FAI
</p>
</li>
<li>
<p>
Créer le nfsroot
</p>
</li>
<li>
<p>
Copier les exemples dans l’espace de configuration
</p>
</li>
<li>
<p>
Configurer les démons réseau
</p>
</li>
<li>
<p>
Créer les configurations PXELINUX
</p>
</li>
</ol></div>
</li>
<li>
<p>
Démarrage et installation des clients
</p>
</li>
</ol></div>
<div class="sect2">
<h3 id="_installer_les_paquets_fai">Installer les paquets FAI</h3>
<div class="ulist"><ul>
<li>
<p>
Installer la clé du dépôt de paquets du projet FAI.
</p>
</li>
<li>
<p>
Ajouter l’URL du dépôt de paquets du projet FAI.
</p>
</li>
<li>
<p>
Installer le paquet <em>fai-quickstart</em> sur le serveur d&#8217;installation.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Utilisez ces commandes pour l&#8217;installation :</p></div>
<div class="listingblock">
<div class="content">
<pre><code># wget -O /etc/apt/trusted.gpg.d/fai-project.gpg https://fai-project.org/download/2BF8D9FE074BCDE4.gpg
# echo "deb http://fai-project.org/download bookworm koeln" &gt; /etc/apt/sources.list.d/fai.list</code></pre>
</div></div>
<div class="paragraph"><p>or</p></div>
<div class="listingblock">
<div class="content">
<pre><code># apt install extrepo ; extrepo enable fai</code></pre>
</div></div>
<div class="paragraph"><p>et ensuite :</p></div>
<div class="listingblock">
<div class="content">
<pre><code># apt-get update
# aptitude install fai-quickstart</code></pre>
</div></div>
<div class="paragraph"><p>Cela installera également les paquets pour les démons de serveur DHCP,
TFTP et NFS.</p></div>
</div>
<div class="sect2">
<h3 id="_créer_le_nfsroot">Créer le nfsroot</h3>
<div class="ulist"><ul>
<li>
<p>
Activez également le dépôt de paquets du projet FAI dans un
autre fichier <em>sources.list</em> qui est utilisé lors de la construction du
nfsroot. Ensuite, activez l’utilisateur de journal pour FAI.
</p>
</li>
</ul></div>
<div class="literalblock">
<div class="content">
<pre><code># sed -i -e 's/^#deb/deb/' /etc/fai/apt/sources.list
# sed -i -e 's/#LOGUSER/LOGUSER/' /etc/fai/fai.conf</code></pre>
</div></div>
<div class="ulist"><ul>
<li>
<p>
Par défaut, FAI utilise
<a href="http://httpredir.debian.org/">http://httpredir.debian.org/</a> comme miroir
de paquets, qui va tenter de trouver un dépôt de paquets
rapide pour vous.
<span class="footnote"><br />[Si vous voulez un miroir plus rapide, ajustez l&#8217;URL dans
<em>/etc/fai/apt/sources.list</em> et <code>FAI_DEBOOTSTRAP</code> dans
<em>/etc/fai/nfsroot.conf</em> avant de lancer fai-setup.]<br /></span>
Ensuite, on peut lancer <code>fai-setup(8)</code>
<span class="footnote"><br />[Cela invoque <code>fai-make-nfsroot(8)</code> en interne.]<br /></span>
Et vérifiez si tout s’est bien passé. Le fichier de journal est écrit dans
/var/log/fai/fai-setup.log.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content">
<pre><code># fai-setup -v</code></pre>
</div></div>
<div class="ulist"><ul>
<li>
<p>
Voilà quelques-unes des lignes que vous verrez à la fin de fai-setup.
Un exemple complet de <em>fai-setup.log</em> est disponible sur la page web FAI
à  <a href="https://fai-project.org/logs/fai-setup.log">https://fai-project.org/logs/fai-setup.log</a>.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content">
<pre><code>FAI packages and related packages inside the nfsroot:
dracut             059-4
dracut-live        059-4
dracut-network     059-4
dracut-squash      059-4
fai-client         6.2
fai-nfsroot        6.2
fai-setup-storage  6.2
Waiting for background jobs to finish
fai-make-nfsroot finished properly.
Log file written to /var/log/fai/fai-make-nfsroot.log
Adding line to /etc/exports: /srv/fai/config 192.168.33.250/24(async,ro,no_subtree_check)
Adding line to /etc/exports: /srv/fai/nfsroot 192.168.33.250/24(async,ro,no_subtree_check,no_root_squash)
Reloading nfs-kernel-server configuration (via systemctl): nfs-kernel-server.service.

Your initial config space is now located in /srv/fai/config
Please don't forget to fill out the FAI questionnaire after you've finished your project with FAI.

FAI setup finished.
Log file written to /var/log/fai/fai-setup.log</code></pre>
</div></div>
<div class="ulist"><ul>
<li>
<p>
<code>fai-setup</code> a créé le LOGUSER, le nfsroot et a ajouté des lignes
supplémentaires à <em>/etc/exports</em>. Les sous-répertoires ajoutés à
<em>/etc/exports</em> sont exportés via NFS v3, de sorte que tous les clients
d’installation dans le même sous-réseau peuvent les monter via NFS.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_création_de_l_espace_de_configuration">Création de l’espace de configuration</h3>
<div class="paragraph"><p>Installez les exemples simples dans l’espace de configuration
<span class="footnote"><br />[Il n&#8217;est pas nécessaires que ces fichiers appartiennent au compte root.]<br /></span>.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ fai-mk-configspace</code></pre>
</div></div>
<div class="paragraph"><p>Ces exemples contiennent la configuration pour certains hôtes d’exemple.
Selon le nom d’hôte utilisé, votre ordinateur sera configuré comme suit :</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
demohost
</dt>
<dd>
<p>
Une machine qui n’a besoin que d’un petit disque dur. Cette machine
est configurée avec le réseau en tant que client DHCP, et une démo de
compte est créée.
</p>
</dd>
<dt class="hdlist1">
xfcehost
</dt>
<dd>
<p>
Un bureau XFCE est installé, utilisant LVM, et la démo du compte est
créée.
</p>
</dd>
<dt class="hdlist1">
gnomehost
</dt>
<dd>
<p>
  Un bureau GNOME est installé et la démo du compte est créée.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>ubuntuhost::\n"
Un bureau Ubuntu sera installé et la démo du compte est créée.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
autres noms d&#8217;hôtes
</dt>
<dd>
<p>
Les hôtes disposant d’un autre nom d’hôte utiliseront notamment les
classes FAIBASE, DHCPC et GRUB.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Tous les hôtes auront un compte appelé <em>demo</em> avec mot de passe <em>fai</em>. Le
compte root a également le mot de passe <em>fai</em>.</p></div>
<div class="paragraph"><p>Si l’indicateur FAI <code>menu</code> est ajouté, au lieu d’utiliser le nom
d’hôte pour déterminer le type d’installation, un menu est présenté et
l’utilisateur peut choisir un profil pour l’installation.</p></div>
</div>
<div class="sect2">
<h3 id="_configurer_les_démons_réseau">Configurer les démons réseau</h3>
<div class="paragraph"><p>Pour démarrer le client d’installation via PXE, le serveur
d’installation a besoin d’un démon DHCP et d’un démon TFTP fonctionnels.
Le paquet <em>fai-quickstart</em> a déjà installé les paquets logiciels
pour ces démons. En outre, le paquet du serveur NFS pour
l’exportation du nfsroot et de l’espace de configuration a été installé.</p></div>
<div class="sect3">
<h4 id="_a_id_bootdhcp_a_configuration_du_démon_dhcp"><a id="bootdhcp"></a>Configuration du démon DHCP</h4>
<div class="paragraph"><p>Idéalement, votre faiserver doit également être votre serveur DHCP. Si ce
n’est pas le cas, demandez à l’administrateur responsable du serveur
DHCP de le configurer conformément à cette section. Il est
possible d&#8217;éviter cela optionnellement en utilisant la fonctionnalité
<a href="#autodiscover">[autodiscover]</a> diffusée dans FAI 5.0.</p></div>
<div class="paragraph"><p>Un exemple pour <code>dhcpd.conf(5)</code> est fourni avec le paquet <em>fai-doc</em>.
Commencez à utiliser cet exemple et regardez toutes les options qui y
sont utilisées.</p></div>
<div class="listingblock">
<div class="content">
<pre><code># cp /usr/share/doc/fai-doc/examples/etc/dhcpd.conf /etc/dhcp/</code></pre>
</div></div>
<div class="paragraph"><p>Les seules informations spécifiques FAI contenues dans ce fichier de
configuration sont d&#8217;assigner <code>filename</code> (DHCP option 67) à la valeur <code>fai/pxelinux.0</code> et
d&#8217;assigner <code>next-server</code> (DHCP option 66, also aussi nommée TFTP server name) et <code>server-name</code>
à la valeur du nom de votre serveur d’install . Toutes les autres informations sont uniquement des
données liées au réseau, qui sont utilisées dans presque toutes les
configurations DHCP. Ajustez ces paramètres de réseau à vos besoins locaux.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>deny unknown-clients;
option dhcp-max-message-size 2048;
use-host-decl-names on;

subnet 192.168.33.0 netmask 255.255.255.0 {
   option routers 192.168.33.250;
   option domain-name "my.example";
   option domain-name-servers 192.168.33.250;
   option time-servers faiserver;
   option ntp-servers faiserver;
   server-name faiserver;
   next-server faiserver;
   filename "fai/pxelinux.0";
}</code></pre>
</div></div>
<div class="paragraph"><p>Si vous apportez des modifications à la configuration DHCP, vous devez
redémarrer le démon.</p></div>
<div class="listingblock">
<div class="content">
<pre><code># invoke-rc.d isc-dhcp-server restart</code></pre>
</div></div>
<div class="paragraph"><p>Si vous disposez de plusieurs interfaces réseau, vous pouvez définir
l’interface que le serveur écoutera dans <em>/etc/default/isc-dhcp-server</em>.
Par défaut, le démon DHCP écrit ses messages de journalisation dans
<em>/var/log/daemon.log</em>.</p></div>
</div>
<div class="sect3">
<h4 id="_ajout_d_une_entrée_d_hôte_au_dhcp">Ajout d’une entrée d’hôte au DHCP</h4>
<div class="paragraph"><p>L’adresse MAC est donnée par le matériel de la carte réseau. Pour chaque
client d’installation, vous collectez son adresse MAC et l&#8217;associez à une
adresse IP et à un nom d’hôte. Tout d’abord, nous ajoutons l’adresse IP
et le nom d’hôte à <em>/etc/hosts</em> <span class="footnote"><br />[On peut aussi ajouter cela dans son serveur de noms de domaine (DNS)]<br /></span>.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>192.168.33.100    demohost</code></pre>
</div></div>
<div class="paragraph"><p>L&#8217;association de l’adresse MAC à l’adresse IP est effectuée dans le fichier
<em>dhcpd.conf</em>. Ici, nous ajoutons une entrée d’hôte en utilisant la
commande <code>+dhcp-edit(8)+</code> . Ici, vous devez remplacer 01:02:03:AB:CD:EF
avec l&#8217;adresse MAC que vous avez trouvé.</p></div>
<div class="listingblock">
<div class="content">
<pre><code># dhcp-edit demohost 01:02:03:AB:CD:EF</code></pre>
</div></div>
<div class="paragraph"><p>Après l&#8217;invocation de cette commande, voici à quoi l&#8217;entrée d&#8217;hôte dans
<em>dhcpd.conf</em> ressemblera :</p></div>
<div class="listingblock">
<div class="content">
<pre><code>host demohost {hardware ethernet 01:02:03:AB:CD:EF;fixed-address demohost;}</code></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_tftp">TFTP</h4>
<div class="paragraph"><p>Normalement, vous n’avez pas besoin d’apporter de modifications à la
configuration démon TFTP. Les fichiers fournis par TFTP sont situés
dans <em>/srv/tftp/fai</em>.</p></div>
</div>
<div class="sect3">
<h4 id="_nfs">NFS</h4>
<div class="paragraph"><p>La commande <code>fai-setup</code> a déjà configuré le démon NFS et ajouté
quelques lignes au fichier de configuration <em>/etc/exports</em>. Il exporte
les répertoires en utilisant NFS v3.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_création_de_la_configuration_pxelinux">Création de la configuration PXELINUX</h3>
<div class="paragraph"><p>La dernière étape avant de démarrer votre client pour la première fois
est de spécifier quelle configuration le client doit démarrer lors de
l’amorçage PXE. Nous utilisons la commande <code>fai-chboot(8)</code> pour
créer une configuration pxelinux pour chaque client d’installation. Cela
comprend des informations sur le noyau, le fichier initrd, l’espace de
configuration et certains paramètres d’amorçage. Vous devriez lire la
page de manuel, qui vous donne quelques bons exemples. Voici la commande
pour démarrer l’installation de l’hôte demohost.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ fai-chboot -IFv -u nfs://faiserver/srv/fai/config demohost

Booting kernel vmlinuz-4.19.0-5-amd64
 append initrd=initrd.img-4.19.0-5-amd64 ip=dhcp
   FAI_FLAGS=verbose,sshd,createvt FAI_CONFIG_SRC=nfs://faiserver/srv/fai/config

demohost has 192.168.33.100 in hex C0A82164
Writing file /srv/tftp/fai/pxelinux.cfg/C0A82164 for demohost</code></pre>
</div></div>
<div class="paragraph"><p>À ce stade, vous devriez avoir une configuration faiserver de travail et
vos clients devraient démarrer dans FAI et être en mesure d’installer
l’un des exemples.</p></div>
<div class="paragraph"><p>Dans la section suivante, vous pouvez lire la planification de votre
installation, adapter votre espace de configuration à vos besoins
particuliers et étendre FAI à l’aide de hooks.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_custom_server_a_serveur_personnalisé"><a id="custom server"></a>Serveur personnalisé</h3>
<div class="paragraph"><p>Le faiserver et sa configuration n’est nullement statique. Il est possible
de personnaliser et d&#8217;étendre votre serveur. Pour cela, reportez-vous à
la section<a href="#Customizing your install server setup">[Customizing your install server setup]</a> dans <a href="#advanced">[advanced]</a>."</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_id_plan_a_planifiez_votre_installation"><a id="plan"></a>Planifiez votre installation</h2>
<div class="sectionbody">
<div class="paragraph"><p>Avant de commencer votre installation, vous devriez investir beaucoup de
temps dans la planification de votre installation. Une fois que vous
êtes satisfait de votre concept d’installation, FAI peut faire toutes
les tâches ennuyeuses et répétitives pour transformer vos plans en
réalité. FAI ne peut pas faire de bonnes installations si votre concept
est imparfait ou qu&#8217;il y manque quelques détails importants. Commencez à
planifier l’installation en répondant aux questions suivantes :</p></div>
<div class="ulist"><ul>
<li>
<p>
Est-ce que je vais créer un cluster Beowulf ou dois-je installer des machines de bureau ?
</p>
</li>
<li>
<p>
À quoi ressemble ma topologie LAN ?
</p>
</li>
<li>
<p>
Ai-je un matériel uniforme ? Le matériel sera-t-il uniforme à l’avenir ?
</p>
</li>
<li>
<p>
Le matériel a-t-il besoin d’un noyau spécial ?
</p>
</li>
<li>
<p>
Comment nommer les hôtes ?
</p>
</li>
<li>
<p>
Comment les disques durs locaux doivent-ils être partitionnés ?
</p>
</li>
<li>
<p>
Quelles applications seront lancées par les utilisateurs ?
</p>
</li>
<li>
<p>
Les utilisateurs ont-ils besoin d’un système de mise en file d’attente ?
</p>
</li>
<li>
<p>
Quels logiciels faut-il installer ?
</p>
</li>
<li>
<p>
Quels démons devraient être lancés, et à quoi devrait ressembler leur configuration ?
</p>
</li>
<li>
<p>
Quels systèmes de fichiers distants doivent être montés ?
</p>
</li>
<li>
<p>
Comment effectuer les sauvegardes ?
</p>
</li>
</ul></div>
<div class="paragraph"><p>Vous devez également penser à des comptes d’utilisateur, des
imprimantes, un système de courrier, des travaux de cron, des cartes
graphiques, au double amorçage, au NIS, au NTP, au fuseau horaire,
à la disposition de clavier, à l’exportation et au montage des annuaires via
NFS et à beaucoup d’autres choses. Donc, il ya beaucoup à faire avant de
commencer une installation. Et rappelez-vous que la connaissance est le
pouvoir, et c’est à vous de l’utiliser. L’installation et
l’administration sont un processus et non un produit. FAI ne peut pas
faire les choses que vous ne lui dites pas de faire.</p></div>
<div class="paragraph"><p>Mais vous ne devez pas commencer à partir de zéro. Examinez les fichiers
et les scripts dans l’espace de configuration. Il ya beaucoup de choses
que vous pouvez utiliser pour votre propre installation. Un bon article
intitulé « Bootstrapping an Infrastructure » avec d’autres aspects de la
construction d’une infrastructure est disponible sur
<a href="http://www.infrastructures.org/papers/bootstrap/bootstrap.html">http://www.infrastructures.org/papers/bootstrap/bootstrap.html</a></p></div>
<div class="sect2">
<h3 id="_a_id_c3_a_l_espace_de_configuration_et_ses_sous_répertoires"><a id="c3"></a>L’espace de configuration et ses sous-répertoires</h3>
<div class="paragraph"><p>The configuration space is the collection of information about how exactly
to install a client. The central configuration space for all install
clients is located on the install server in <em>/srv/fai/config</em> and its
subdirectories. This will be mounted by the install clients to
<em>/var/lib/fai/config</em>. The main installation command <code>fai(8)</code> uses all
these subdirectories in the order listed except for hooks.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<em>class/</em>
</dt>
<dd>
<p>
Scripts et fichiers pour définir des classes et des variables.
</p>
</dd>
<dt class="hdlist1">
<em>disk_config/</em>
</dt>
<dd>
<p>
Fichiers de configuration pour le partitionnement de disque, RAID
logiciel, LVM et création de système de fichiers.
</p>
</dd>
<dt class="hdlist1">
<em>basefiles/</em>
</dt>
<dd>
<p>
Normalement , le fichier <em>base.tar.xz</em> (situé à l&#8217;intérieur du
nfsroot) est extrait sur le client d’installation après la création
des nouveaux systèmes de fichiers et avant l’installation des paquets.
Il s’agit d’une image de base minimale, créée juste après avoir appelé
debootstrap lors de la création du nfsroot sur le serveur
d’installation. Si vous voulez installer une autre distribution que celle
du nfsroot, vous pouvez mettre un fichier tar dans le sous-répertoire
<em>basefiles/</em> et le nommer selon une classe. Ensuite, la commande
<code>ftar(8)</code> est utilisée pour extraire le fichier tar en fonction des
classes définies. Ainsi, le fichier doit être nommé <em>CLASS.tar.xz</em>
et non <em>CLASS.base.tar.xz</em>. Cela se fait dans la tâche <em>extrbase</em>.
Utilisez cette option si vous souhaitez installer une autre
distribution ou une version différente de celle exécutée pendant
l’installation.
</p>
<div class="paragraph"><p>Ce fichier de base peut également être reçu en fonction des classes
FAI via HTTP/HTTPS ou FTP en définissant la variable <code>FAI_BASEFILEURL</code>. FAI
téléchargera un fichier CLASSNAME.tar.xz (ou tgz, ou tar.gz, …) à
partir de cette URL, si <code>CLASSNAME</code> correspond à une classe FAI.</p></div>
<div class="paragraph"><p>Exemple :</p></div>
</dd>
</dl></div>
<div class="listingblock">
<div class="content">
<pre><code>FAI_BASEFILEURL=https://fai-project.org/download/basefiles/</code></pre>
</div></div>
<div class="paragraph"><p>Le dossier doit prendre en charge la liste des répertoires. FAI ne
recherchera pas de fichiers potentiellement correspondants.</p></div>
<div class="paragraph"><p>Voir le chapitre <a href="#otherdists">[otherdists]</a> pour savoir comment
installer différentes distributions.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<em>debconf/</em>
</dt>
<dd>
<p>
Ce répertoire contient toutes les données <code>debconf(7)</code>. Le format
est le même que celui utilisé par <code>debconf-set-selections(1)</code>.
</p>
</dd>
<dt class="hdlist1">
<em>package_config/</em>
</dt>
<dd>
<p>
Les fichiers avec des noms de classe contiennent des listes de
paquets à installer ou à désinstaller par
<code>install_packages(8)</code>. Les fichiers nommés <em>&lt;CLASS&gt;.gpg</em> sont ajoutés à la liste des clés utilisées par apt
pour les dépôts de paquets approuvés.
</p>
</dd>
<dt class="hdlist1">
<em>pkgs/</em>
</dt>
<dd>
<p>
Ce répertoire peut avoir des sous-répertoires nommés selon des classes. Vous pouvez
mettre des fichiers <em>.deb</em> ou <em>.rpm</em> dans ces sous-répertoires. FAI installera
ces paquets sans qu&#8217;il soit besoin de créer les métadonnées d&#8217;un dépôt de paquets.
</p>
</dd>
<dt class="hdlist1">
<em>scripts/</em>
</dt>
<dd>
<p>
Scripts pour la personnalisation de votre site local. Utilisé par
<code>fai-do-scripts(1)</code>.
</p>
</dd>
<dt class="hdlist1">
<em>files/</em>
</dt>
<dd>
<p>
Les Fichiers utilisés par les scripts de personnalisation. La plupart
des fichiers se trouvent dans un sous-répertoire qui
reflète l’arborescence de répertoires ordinaire. Par exemple, les
modèles de <code>_nsswitch.conf_</code> se trouvent dans
<em>$FAI/files/etc/nsswitch.conf</em> et sont nommés en fonction des classes
auxquelles ils doivent correspondre :
<em>$FAI/files/etc/nsswitch.conf/NIS</em> est la version de
<em>/etc/nsswitch.conf</em> à utiliser pour la classe NIS. Notez que le
contenu du répertoire n’est pas automatiquement copié sur la machine
cible, mais qu’il doit être explicitement copié par des scripts de
personnalisation à l’aide de la commande <code>fcopy(8)</code>.
</p>
</dd>
<dt class="hdlist1">
<em>hooks/</em>
</dt>
<dd>
<p>
Les hooks sont des programmes ou des scripts définis par
l’utilisateur, qui sont lancés pendant le processus d’installation.
Ils peuvent étendre ou remplacer les tâches par défaut. Le nom du
fichier doit être de format <em>taskname.CLASSNAME[.sh]</em>. Un hook appelé
<code>updatebase.DEBIAN</code> est exécuté avant la tâche
<code>updatebase</code> et seulement si l’installation du client fait partie de
la classe DEBIAN.
</p>
</dd>
</dl></div>
</div>
<div class="sect2">
<h3 id="_a_id_defining_classes_a_définition_des_classes"><a id="defining classes"></a>Définition des classes</h3>
<div class="paragraph"><p>Il existe différentes possibilités pour définir des classes :</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Certaines classes par défaut sont définies pour chaque hôte : DEFAULT, LAST et son nom d’hôte.
</p>
</li>
<li>
<p>
Les classes peuvent être répertoriées dans un fichier (par défaut dans <em>class/&lt;hostname&gt;</em>).
</p>
</li>
<li>
<p>
Les classes peuvent être dynamiquement définies par des scripts.
</p>
</li>
</ol></div>
<div class="paragraph"><p>La dernière option est une fonctionnalité très intéressante, puisque ces
scripts définiront des classes d&#8217;une façon très souple. Par exemple,
plusieurs classes peuvent être définies uniquement si certains matériels
sont identifiés ou si une classe est définie en fonction des
informations du sous-réseau.</p></div>
<div class="paragraph"><p>Tous les noms de classes, sauf le nom d’hôte, sont écrits en
majuscules. Ils ne doivent pas contenir de trait d’union, de dièse, de
point-virgule ni de point, mais peuvent contenir des caractères de
soulignement et des chiffres.</p></div>
<div class="paragraph"><p>La tâche <em>defclass</em> appelle la commande <code>fai-class(1)</code> pour définir
les classes. Tous les scripts correspondant à l&#8217;expression <em>^[0-9][0-9]*</em> (qui
commencent avec deux chiffres) Dans le sous-repertoire <em>$FAI/class</em> sont
exécutés afin de définir les classes. Tout ce qui is affiché sur STDOUT
est automatiquement defini comme une classe. Pour plus d’informations
sur Les définitions de classe , lire les pages de manuel de
<code>fai-class(1)</code>. Le script <em>50-host-classes</em> (voir ci - dessous la
version allégée) est utilisé pour les définir des classes en fonction du
nom d’hôte.</p></div>
<div class="listingblock">
<div class="content">
<pre><code># use a list of classes for our demo machines
case $HOSTNAME in
    demohost)
        echo "FAIBASE GRUB DEMO" ;;
    xfcehost)
        echo "FAIBASE GRUB DEMO XORG XFCE LVM";;
    faiserver)
        echo "FAIBASE DEBIAN DEMO FAISERVER" ;;
    ubuntuhost)
        echo "FAIBASE DEBIAN DEMO UBUNTU JAMMY JAMMY64 XORG";;
    *)
        echo "FAIBASE DEBIAN DEMO" ;;
esac</code></pre>
</div></div>
<div class="paragraph"><p>Les noms d’hôtes doivent rarement être utilisé pour les fichiers de
configuration dans l’espace de configuration. Au lieu de ça, une classe doit
être définie et ensuite ajoutée pour un hôte donné. En effet, la plupart
du temps les données de configuration ne sont pas spécifiques à un nom
d&#8217;hôte, mais peuvent être partagées entre différents hôtes.</p></div>
<div class="paragraph"><p>L’ordre des classes est important car celui-ci définit la priorité des
classes de faible à élevée.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_classvariables_a_définition_des_variables"><a id="classvariables"></a>Définition des Variables</h3>
<div class="paragraph"><p>La tâche <em>defvar</em> definit les variables pour le client d&#8217;installation.
Les variables sont définies par les scripts dans <em>class/*.var</em>.
Toutes les variables globales peuvent être définies dans <em>DEFAULT.var</em>.
Pour un groupe d’hôtes utiliser un fichier de classe. Pour un
hôte seul, utiliser le Fichier <code>$HOSTNAME</code> <em>.var</em>. Ici aussi, il est
utile d&#8217;étudier tous les exemples.</p></div>
<div class="paragraph"><p>Les variables suivantes sont utilisées dans les exemples et peuvent aussi être
utiles pour votre installation :</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
FAI_ACTION
</dt>
<dd>
<p>
Set the action FAI should perform. Normally this is done by
<code>fai-chboot(8)</code>. If you can&#8217;t use this command, define this variable
i.e. in the script <em>LAST.var</em>.
</p>
</dd>
<dt class="hdlist1">
FAI_ALLOW_UNSIGNED
</dt>
<dd>
<p>
Si cette variable vaut 1, FAI permet l’installation de paquets à partir de
dépôts non signés.
</p>
</dd>
<dt class="hdlist1">
CONSOLEFONT
</dt>
<dd>
<p>
La police de caractères qui est chargée lors de l’installation par
<code>setfont(8)</code>.
</p>
</dd>
<dt class="hdlist1">
KEYMAP
</dt>
<dd>
<p>
Définit les fichiers de disposition du clavier dans <em>/usr/share/keymaps</em>
et <em>$FAI/files</em>. Vous n&#8217;avez pas besoin de spécifier le chemin complet,
car ce fichier sera localisé automatiquement.
</p>
</dd>
<dt class="hdlist1">
ROOTPW
</dt>
<dd>
<p>
Le mot de passe root chiffré pour le nouveau système. Vous pouvez
utiliser
<code>crypt(3)</code>, md5 et d’autres types de hachage pour le mot de passe. Utilisez 'mkpasswd(1)+`
pour créer le hachage d’un mot de passe donné. Par exemple, pour
générer le hachage MD5 un mot de passe, utilisez :
</p>
</dd>
</dl></div>
<div class="literalblock">
<div class="content">
<pre><code>$ echo "votre_mot_secret" | mkpasswd -m yescrypt -s</code></pre>
</div></div>
<div class="dlist"><dl>
<dt class="hdlist1">
UTC
</dt>
<dd>
<p>
Règle l’horloge matérielle à UTC si <em>UTC=yes</em>. Sinon, règle
l’horloge à l’heure locale. Voir <code>clock(8)</code> pour plus
d’informations.
</p>
</dd>
<dt class="hdlist1">
TIMEZONE
</dt>
<dd>
<p>
C&#8217;est le fichier sous <em>/usr/share/zoneinfo/</em> qui indique votre
fuseau horaire. Par exemple : <em>TIMEZONE=Europe/Berlin</em>.
</p>
</dd>
<dt class="hdlist1">
MODULESLIST
</dt>
<dd>
<p>
Une liste des modules du noyau qui sont chargés pendant le démarrage
du nouveau système (écrits dans /etc/modules).
</p>
</dd>
</dl></div>
</div>
<div class="sect2">
<h3 id="_a_id_diskconfig_a_configuration_du_disque_dur"><a id="diskconfig"></a>Configuration du disque dur</h3>
<div class="paragraph"><p>L’outil <code>setup-storage(8)</code> lit un fichier dans <em>$FAI/disk_config</em> pour
la configuration du disque. Ce fichier décrit comment tous les disques
Locaux seront partitionnés, quels types de systèmes de fichiers
doivent etre créés (comme ext3/4, xfs, btrfs), et où ils seront montés.
Vous pouvez aussi créer des configurations RAID logiciel et LVM en
utilisant ce fichier de configuration. Il est aussi possible de préserver
le partitionnement du disque ou de préserver les
données sur certaines partitions.</p></div>
<div class="paragraph"><p>Pendant le processus d’installation, tous les systèmes de fichiers
locaux sont montés sous le répertoire <em>/target</em>. Par exemple, si vous
spécifiez le point de montage <em>/home</em> dans un fichier de configuration
de disque, ce sera le répertoire <em>/target/home</em> pendant le processus
d’installation et ça deviendra <em>/home</em> pour le nouveau système installé.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_extrbase_a_extraction_du_fichier_de_base"><a id="extrbase"></a>Extraction du fichier de base</h3>
<div class="paragraph"><p>Un fichier de base n&#8217;est nécessaire que si on installe une distribution qui est
défférente de celle dans le nfsroot.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_debconf_a_pré_ensemencement_debconf"><a id="debconf"></a>Pré-ensemencement Debconf</h3>
<div class="paragraph"><p>On peut utiliser le fomat décrit dans <code>debconf-set-selections(1)</code>.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_repository_a_accès_au_dépôt_de_paquets"><a id="repository"></a>Accès au dépôt de paquets</h3>
<div class="paragraph"><p>FAI supporte http, https, et NFS pour l&#8217;accès au miroir de paquets. Réglez
la variable <em>$FAI_DEBMIRROR</em> pour l&#8217;utilisation de NFS.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_packageconfig_a_configuration_des_paquets_logiciels"><a id="packageconfig"></a>Configuration des paquets logiciels</h3>
<div class="paragraph"><p>Avant l’installation de paquets, FAI va ajouter le contenu de tous
les fichiers nommés <em>package_config/class.gpg</em> à la liste des clés apt.
Si votre dépôt local est signé par votre keyid AB12CD34 vous pouvez
facilement ajouter cette clé, ainsi FAI l’utilisera pendant
l’installation. Utilisez cette commande pour créer le fichier
<em>CLASS.gpg</em> :</p></div>
<div class="listingblock">
<div class="content">
<pre><code>faiserver$ gpg --export AB12CD34 &gt; /srv/fai/config/package_config/MYCLASS.gpg</code></pre>
</div></div>
<div class="paragraph"><p>Le script <code>install_packages(8)</code> installe les logiciels sélectionnés.
Il lira tous les fichiers de configuration Dans <em>$FAI/package_config</em>
dont le nom correspond à une classe définie. La syntaxe est très simple.</p></div>
<div class="listingblock">
<div class="content">
<pre><code># an example package class

PACKAGES taskinst
german

PACKAGES install-norec
adduser nmap
less zstd

PACKAGES remove
gpm xdm

PACKAGES install GRUB_PC
grub-pc</code></pre>
</div></div>
<div class="paragraph"><p>Les commentaires commencent par une dièse (#) et se terminent à la fin de la
ligne. Chaque commande de paquet commence par le mot <em>PACKAGES</em> suivi
par un nom de commande, qui correspond à gestionnaire de paquets
distinct comme apt-get, aptitude ou dnf par exemple. la commande définit quelle
commande sera utilisé pour installer les paquets nommés après
cette commande. La liste de toutes les commandes disponibles peut
être listée en utilisant <em>install_packages -H</em>. Les gestionnaires de paquets pris
en charges sont <em>aptitude, apt-get, smart, yast, dnf, rpm, zypper</em></p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
hold
</dt>
<dd>
<p>
Mettre un paquet en attente. Ce paquet ne sera pas pris en charge par
dpkg, pas exemple il ne sera pas mis à niveau.
</p>
</dd>
<dt class="hdlist1">
install
</dt>
<dd>
<p>
Pour installer tous les paquets (en utilisant <code>apt-get</code>) qui sont précisés
dans les lignes suivantes. Si un tiret est ajouté au nom du paquet
(sans espace intermédiaire), le paquet sera supprimé, pas installé.
Tous les noms de paquets sont vérifiées pour les fautes de frappe.
Tout paquet qui n’existe pas, sera retiré de la liste des paquets à
installer. Soyez donc attentif à ne pas mal orthographier les
noms de paquets.
</p>
</dd>
<dt class="hdlist1">
install-norec
</dt>
<dd>
<p>
Comme install, mais sans installer les paquets recommandés.
</p>
</dd>
<dt class="hdlist1">
remove
</dt>
<dd>
<p>
Supprimer tous les paquets qui sont pécisés dans les lignes suivantes.
Si on ajoute un + au nom du paquet, le paquet doit être installé.
</p>
</dd>
<dt class="hdlist1">
taskinst
</dt>
<dd>
<p>
Installer tous les paquets appartenant aux tâches qui sont spécifiées
dans les lignes suivantes à l’aide de <code>tasksel(1)</code>. Vous pouvez
aussi utiliser <em>aptitude</em> pour installer les tâches.
</p>
</dd>
<dt class="hdlist1">
aptitude
</dt>
<dd>
<p>
Installer tous les paquets avec la commande <code>aptitude</code>. Ce sera la
valeur par défaut à l’avenir et pourra remplacer apt-get et taskinst.
Aptitude peut aussi installer les tâches de paquets.
</p>
</dd>
<dt class="hdlist1">
aptitude-r
</dt>
<dd>
<p>
Idem aptitude avec l’option <em>--with-recommends</em>.
</p>
</dd>
<dt class="hdlist1">
unpack
</dt>
<dd>
<p>
Télécharger les paquets et les décompresser seulement. Ne pas configurer les
paquets.
</p>
</dd>
<dt class="hdlist1">
dselect-upgrade
</dt>
<dd>
<p>
Definir des sélections des paquets en utilisant les lignes suivantes puis
installer ou supprimer les paquets précisés. Ces lignes sont le résultat
de la commande <em>dpkg --get-selections</em>. Il est recommandé de ne pas
utiliser ce format, puisque cela spécifie aussi tous les
paquets qui sont installés seulement en raison d’une dépendance ou
d&#8217;une recommandation. Il vaut mieux juste spécifier le paquet que vous
voulez avoir, et de laisser FAI (et apt-get) résoudre les dépendances.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Plusieurs lignes avec des listes de noms de paquets séparés par des
espaces suivent les directive PACKAGES. Toutes les dépendances sont
résolues. Les paquets avec suffixe <em>-</em> (par exemple, <em>lilo-</em>) seront
supprimés au lieu d&#8217;être installés. L’ordre des paquet n’a pas
d’importance. Si vous souhaitez installer des paquets d’une autre
version que la valeur par défaut, vous pouvez ajouter le nom de la
version au nom du paquet comme dans <em>openoffice.org/etch-backports</em>.
Vous pouvez également spécifier une certaine version comme <em>apt=0.3.1</em>.
Plus d’informations sur ces fonctionnalités sont décrites dans
<code>aptitude(8)</code>.</p></div>
<div class="paragraph"><p>On peut spécifier des paramètres supplémentaires pour le gestionnaire de paquets
en ajoutant des paires <em>cle=valeur</em> après <em>PACKAGES &lt;commande&gt;</em>. les paires clé, valeur
actuellement supportées sont <em>release=&lt;nom&gt;</em> qui ajoute <em>-t &lt;nom&gt;</em> durant
l&#8217;installation des paquets.</p></div>
<div class="paragraph"><p>Exemple:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>PACKAGES install-norec release=testing
nvidia-smi</code></pre>
</div></div>
<div class="paragraph"><p>Cela installerait le paquet nvidia-smi  de la distribution testing,
en incluant les dépendances. N&#8217;oubliez pas d&#8217;ajouter une entrée dans
<em>sources.list</em>. Vous pouvez aussi vouloir ajuste l&#8217;épinglage apt (apt pinning)
(voir <em>apt_references(5)</em>)</p></div>
<div class="paragraph"><p>Une ligne qui contient la commande <em>PRELOADRM</em>, télécharge un fichier à
l’aide de <code>wget(1)</code> dans un répertoire avant d’installer les paquets.
À l’aide d&#8217;une URL de type <em>file:</em>, ce fichier est copié de <code>$FAI_ROOT</code> vers le
répertoire de téléchargement. Par exemple, le paquet <code>realplayer</code> a
besoin d’une archive pour installer le logiciel, donc cette archive est
téléchargée dans le répertoire <em>/root</em>. Après l’installation des
paquets, ce fichier sera supprimé. Si le fichier ne doit pas être
supprimé, utilisez plutôt la commande <em>PRELOAD</em>.</p></div>
<div class="paragraph"><p>On peut ajouter une expression booléenne arbitraire qui utilise des classes FAI pour
définir quand la liste des paquets devrait être installée. Ici, les
paquets seront installés seulement si la classe XORG est définie mais la classe
MINT n&#8217;est pas définie.</p></div>
<div class="paragraph"><p>Exemple:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>PACKAGES install UBUNTU &amp;&amp; XORG &amp;&amp; ! MINT
ubuntu-standard
ubuntu-desktop</code></pre>
</div></div>
<div class="paragraph"><p>L&#8217;ancienne façon d&#8217;ajouter des expressions logiques dans les lignes PACKAGES est encore valable :
Il est possible d&#8217;ajouter une liste de noms de classes après la commande pour
apt-get. Ainsi une telle commande <em>PACKAGES</em> sera exécutée seulement au moins
une des classes correspondantes est définie (OU logique). On peut donc combiner
plusieurs petits fichiers dans le fichier DEFAULT.</p></div>
<div class="paragraph"><p>Si vous souhaitez supprimer un nom de paquet d’une certaine classe
faisait partie de cette classe précédemment, vous ne devez pas supprimer le
nom du paquet classe, mais plutôt de lui ajouter un tiret (-). Cela
garantira que le paquet soit enlevé pendant une mise a jour sur des hôtes
qui étaient installés en utilisant l’ancienne définition de classe qui
comprenait ce nom de paquet.</p></div>
<div class="paragraph"><p>Si vous spécifiez un paquet qui n’existe pas, ce paquet sera supprimé
automatiquement de la liste d’installation uniquement si la commande
<em>install</em> est utilisée.</p></div>
<div class="paragraph"><p>Le concept de priorité des classes permet à une classe de priorité plus élevée (qui
arrive plus tard dans la séquence des classes) d&#8217;écraser les sélections des
paquets de priorité plus basse. Pour que cela fonctionne correctement,
les classes de priorité plus élevée doivent utiliser les mêmes commandes <em>PACKAGES</em> (par exemple
<em>PACKAGES install-norec</em> au lieu de seulement <em>PACKAGES install</em>) que celles qu&#8217;utilisent
la classe qu&#8217;on essaie d&#8217;écraser. Cela est utile pour supprimer
l&#8217;installation d&#8217;un paquet, par exemple, pour éviter d&#8217;installer le paquet
<em>linuxlogo</em> installé par la classe FAIBASE :</p></div>
<div class="listingblock">
<div class="content">
<pre><code># exemple montrant comment écraser :
#
# Dans FAIBASE il y a :
#    PACKAGES install-norec
#    linuxlogo
#
# On veut _ne pas_ installer linuxlogo, et il se trouve dans
# une section install-norec, donc il faut aussi utiliser install-norec.

PACKAGES install-norec
linuxlogo-</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_a_id_cscripts_a_scripts_de_personnalisation"><a id="cscripts"></a>Scripts de personnalisation</h3>
<div class="paragraph"><p>La commande <code>fai-do-scripts(1)</code> est lancée pour exécuter tous les
scripts dans ce répertoire. Si un répertoire avec un nom de classe
existe, tous les scripts correspondant à l&#8217;expression <em>^[0-9][0-9]*</em> sont exécutés
par ordre alphabétique. Il est donc possible d’utiliser des scripts de
différentes langages (shell, cfengine, Perl, Python, Ruby, expect,..)
pour une classe.</p></div>
<div class="paragraph"><p>Ces scripts écrivent leur sortie standard dans scripts.log. Le fichier status.log
contient les noms de tous les scripts exécutés et leur statut de terminaison.</p></div>
<div class="sect3">
<h4 id="_a_id_shell_a_scripts_shell"><a id="shell"></a>Scripts shell</h4>
<div class="paragraph"><p>La plupart des scripts sont des scripts Bourne shell. Les scripts shell
sont utiles si la tâche de configuration n&#8217;a besoin d&#8217;appeler que
quelques commandes shell ou créer un fichier à partir de zéro. Afin d&#8217;éviter
d&#8217;écrire beaucoup de scripts courts, il est possible d’utiliser la
commande <code>ifclass</code> pour tester si certaines classes sont définies.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>ifclass -o A B C</code></pre>
</div></div>
<div class="paragraph"><p>Vérifie si l’une des classes A, B ou C est définie. L’utilisation de -a
(ET, AND logique) vérifie si toutes les classes d’une liste sont définies.
La commande <em>ifclass C</em> vérifie si seule la classe C est définie.</p></div>
<div class="paragraph"><p>Pour copier des fichiers avec des classes, utilisez la commande
<code>fcopy(8)</code>. Si vous voulez extraire une archive à l’aide de classes,
utilisez <code>ftar(8)</code>. Pour ajouter des lignes à un fichier de
configuration, utilisez <code>ainsl(1)</code> au lieu de simplement
<code>echo string &gt;&gt; filename</code>.</p></div>
<div class="paragraph"><p>FAI prend également en charge les scripts <em>zsh(1)</em> pendant la tâche de
personnalisation. Dans les scripts, la variable <code>$classes</code> contient
une liste séparée par des espaces avec les noms de toutes les classes
définies.</p></div>
</div>
<div class="sect3">
<h4 id="_a_id_cfengine_a_cfengine_scripts"><a id="cfengine"></a>Cfengine scripts</h4>
<div class="paragraph"><p>CFEngine has a rich set of functions to edit existing configuration
files, e.g <em>LocateLineMatching, ReplaceAll, InsertLine,
AppendIfNoSuchLine, HashCommentLinesContaining</em>. But it can&#8217;t handle
variables which are undefined. If a variable is undefined, the whole
cfengine script will abort.</p></div>
<div class="paragraph"><p>More information can be found in the manual page <code>cfengine(8)</code> or at
the cfengine homepage <a href="https://www.cfengine.com">https://www.cfengine.com</a>.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_a_id_hooks_a_hooks"><a id="hooks"></a>Hooks</h3>
<div class="paragraph"><p>Hooks let you specify functions or programs which are run at certain
steps of the installation process. Before a task is called,
FAI searches for existing hooks for this task and executes them. As
you might expect, classes are also used when calling hooks. Hooks are
executed for every defined class. You only have to create the hook
with the name for the desired class and it will be used.  If several
hooks for a task exists, they are called in the order defined by the
classes.  If <em>debug</em> is included in <code>$FAI_FLAG</code> the option <em>-d</em> is
passed to all hooks, so you can debug your own hooks.  If some default
tasks should be skipped, use the subroutine <em>skiptask</em> and a list of
default tasks as parameters. In the examples provided, the hooks of
the class CENTOS skips some Debian specific tasks.</p></div>
<div class="paragraph"><p>The directory <em>$FAI/hooks/</em> contains all hooks. A hook is an executable
file following the naming scheme <em>taskname.CLASSNAME[.sh]</em> (e.g.
<em>repository.CENTOS</em> or 'savelog.LAST.sh). The
task name specifies which task to precede executing this hook, if the
specified class is defined for the installing client.  See section
<a href="#tasks">[tasks]</a> for a complete list of default tasks that can be used.</p></div>
<div class="paragraph"><p>A hook of the form <em>hookprefix.classname</em> can&#8217;t define variables for
the installation script, because it&#8217;s a subprocess. But you can use
any binary executable or any script you wrote. Hooks that have the
suffix <em>.sh</em> (e.g. <em>partition.DEFAULT.sh</em>) must be Bourne
shell scripts and are sourced. So it&#8217;s possible to redefine variables
for the installation scripts.</p></div>
<div class="paragraph"><p>In the first part of FAI, all hooks with prefix <em>confdir</em> are called.
Those hooks can not be located in the config space, since it&#8217;s not yet
available. Therefore these hooks are the only hooks located in
<code>$nfsroot</code><em>/$FAI/hooks</em> on the install server. All other hooks are
found in <em>$FAI_CONFIGDIR/hooks</em> on the install server.</p></div>
<div class="paragraph"><p>All hooks that are called before classes are defined can only use the
following classes: <em>DEFAULT $HOSTNAME LAST</em>. If a hook for class
<em>DEFAULT</em> should only be called if no hook for class <code>$HOSTNAME</code> is
available, insert these lines to the default hook:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>hookexample.DEFAULT:

#! /bin/sh

# skip DEFAULT hook if a hook for $HOSTNAME exists
scriptname=$(basename $0 .DEFAULT)
[-f $FAI/hooks/$scriptname.$HOSTNAME ] &amp;&amp; exit
# here follows the actions for class DEFAULT
.
.</code></pre>
</div></div>
<div class="paragraph"><p>Some examples for what hooks could be used:</p></div>
<div class="ulist"><ul>
<li>
<p>
Load kernel modules before classes are defined in <em>$FAI/class</em>.
</p>
</li>
<li>
<p>
Send an email to the administrator if the installation is finished.
</p>
</li>
<li>
<p>
Install a diskless client and skip local disk partitioning.
</p>
</li>
<li>
<p>
Have a look at <code>hooks/debconf.IMAGE</code> for how to clone a machine using a file system image.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_a_id_faiflags_a_fai_flags"><a id="faiflags"></a>FAI flags</h3>
<div class="paragraph"><p>The variable <code>$FAI_FLAGS</code> contains a space separated list of
flags. Flags are normally defined in the pxelinux.cfg file which
should be created by <em>fai-chboot(1)</em>. The following flags are known:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
verbose
</dt>
<dd>
<p>
Create verbose output during installation. This should always be the
first flag, so consecutive definitions of flags will be verbosely
displayed.
</p>
</dd>
<dt class="hdlist1">
debug
</dt>
<dd>
<p>
Create debug output. No unattended installation is performed. During
package installation you have to answer all questions of the
postinstall scripts on the client&#8217;s console. A lot of debug
information will be printed out. This flag is only useful for FAI
developers.
</p>
</dd>
<dt class="hdlist1">
sshd
</dt>
<dd>
<p>
Start the ssh daemon to enable remote logins.
You can then log in as <em>root</em> to all install clients during the
installation. The default password is <em>fai</em> and can be changed by
setting <code>FAI_ROOTPW</code> in <code>nfsroot.conf(5)</code>. To log in from your server
to the install client (named demohost in this example) use:
</p>
</dd>
</dl></div>
<div class="listingblock">
<div class="content">
<pre><code>$ ssh root@demohost
Warning: Permanently added 'demohost,192.168.33.100' to the list of known hosts.
root@demohost's password:</code></pre>
</div></div>
<div class="paragraph"><p>This is only the root password during the
installation process, not for the new installed system. You can also
log in without a password when using <code>$SSH_IDENTITY</code>.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
createvt
</dt>
<dd>
<p>
Create two virtual terminals and execute a bash if <em>ctrl-c</em> is typed
in the console terminal. The additional terminals can be accessed by
typing <em>Alt-F2</em> or <em>Alt-F3</em>. Otherwise, no terminals are available and
typing <em>ctrl-c</em> will reboot the install client. Setting this flag is
useful for debugging. If you want an installation which should not be
interruptible, do not set this flag.
</p>
</dd>
<dt class="hdlist1">
menu
</dt>
<dd>
<p>
This enables a user menu for selecting a profile. All files
<code>class/*.profile</code> are read and a curses based menu will be created.
</p>
</dd>
<dt class="hdlist1">
screen
</dt>
<dd>
<p>
Run FAI inside a <code>screen(1)</code> session. The session is called FAI.
If you log in via ssh from remote you can attach to the session using:
</p>
</dd>
</dl></div>
<div class="listingblock">
<div class="content">
<pre><code>$ screen -x</code></pre>
</div></div>
<div class="dlist"><dl>
<dt class="hdlist1">
tmux
</dt>
<dd>
<p>
Run FAI inside a <code>tmux(1)</code> session. The session is called FAI.
If you log in via ssh from remote you can attach to the session using:
</p>
</dd>
</dl></div>
<div class="listingblock">
<div class="content">
<pre><code>$ tmux attach</code></pre>
</div></div>
<div class="dlist"><dl>
<dt class="hdlist1">
reboot
</dt>
<dd>
<p>
Reboot the install client after installation is finished without
typing RETURN on the console. If this flag is not set, and error.log
contains anything, the install client will stop and wait that you
press RETURN. If no errors occurred, the client will always reboot
automatically.
</p>
</dd>
<dt class="hdlist1">
halt
</dt>
<dd>
<p>
Halt the install client at the end of the installation, instead of
rebooting into the new system.
</p>
</dd>
<dt class="hdlist1">
initial
</dt>
<dd>
<p>
Used by <code>setup-storage(8)</code>. Partitions marked with <code>preserve_reinstall</code>
are preserved unless this flag is set. Often, this flag is set in a
file <em>class/*.var</em> by using setting <em>flag_initial=1</em>.
</p>
</dd>
</dl></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_id_install_a_fai_installs_your_plan"><a id="install"></a> FAI installs your plan</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_the_early_part_of_an_installation">The early part of an installation</h3>
<div class="paragraph"><p>After the kernel has booted, it mounts the root file system via NFS
from the install server and starts the script
<em>/usr/sbin/fai</em> <span class="footnote"><br />[Since the root file system on the clients is mounted via
NFS, <code>fai</code> is located in
<em>/srv/fai/nfsroot/usr/sbin</em> on the install
server.]<br /></span>. This script controls the sequence of the
installation. No other scripts in <em>/etc/init.d/</em> are used.</p></div>
<div class="paragraph"><p>The configuration space is made available via the configured method
(an NFS mount by default) from the install server to the path defined
in <em>$FAI</em> <span class="footnote"><br />[<em>$FAI</em> is an internal variable used by the FAI
scripts. By default the path is <em>/var/lib/fai/config</em>.]<br /></span></p></div>
</div>
<div class="sect2">
<h3 id="_a_id_bootmesg_a_boot_messages"><a id="bootmesg"></a>Boot messages</h3>
<div class="paragraph"><p>When booting the install client from network card with PXE you will see some
messages like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Managed PC Boot Agent (MBA) v4.00
Pre-boot eXecution Environment (PXE) v2.00
DHCP MAC ADDR: 00 A2 A3 04 05 06
DHCP.../

CLIENT MAC ADDR: 00 A2 A3 04 05 06  GUID: 3D6C4552
CLIENT IP: 192.168.33.100 MASK: 255.255.255.0  DHCP IP: 192.168.33.250
GATEWAY IP: 192.168.33.1

!PXE entry point found (we hope) at 9854:0106 via plan A
UNDI code segment at: 9854 len 5260
UNDI data segment at: 921D len 63A2
Getting cached packet  01 02 03
My Ip address seems to be C0A82164 192.168.33.100
ip=192.168.33.100:192.168.33.250:192.168.33.1:255.255.255.0
BOOTIF=01-00-A2-A3-04-05-06
SYSUUID=
TFTP prefix: fai/
Trying to load pxelinux.cfg/C0A82164

Loading vmlinuz-6.1.0-17-amd64..................
Loading initrd.img-6.1.0-17-amd64......................ready.</code></pre>
</div></div>
<div class="paragraph"><p>At this point the install client has successfully received the network
config via DHCP and the kernel and initrd via TFTP. It now boots the
Linux kernel and the initrd. If everything went right, the initrd
mounts the nfsroot <span class="footnote"><br />[<em>/srv/fai/nfsroot</em> from the install
server via NFS]<br /></span> and the FAI scripts are started. The first
thing you see is the red FAI copyright message.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>             -------------------------------------------------
                   Fully Automatic Installation  -  FAI

                   6.2           (c) 1999-2024
                   Thomas Lange  &lt;lange@cs.uni-koeln.de&gt;
             -------------------------------------------------

Calling task_confdir
Kernel currently running: Linux 6.1.0-17-amd64 x86_64 GNU/Linux
Kernel parameters: BOOT_IMAGE=vmlinuz-6.1.0-17-amd64 initrd=initrd.img-6.1.0-17-amd64 \
  ip=dhcp rw root=192.168.33.250:/srv/fai/nfsroot rootovl FAI_FLAGS=verbose,sshd,createvt
  FAI_ACTION=install FAI_CONFIG_SRC=nfs://faiserver/srv/fai/config
Reading /tmp/fai/boot.log
FAI_FLAGS: verbose sshd createvt
Monitoring to server faiserver enabled.
FAI_CONFIG_SRC is set to nfs://faiserver/srv/fai/config
Configuration space faiserver:/srv/fai/config mounted to /var/lib/fai/config
Source hook: setup.DEFAULT.sh
setup.DEFAULT.sh     OK.
Calling task_setup
FAI_FLAGS: verbose sshd createvt
Press ctrl-c to interrupt FAI and to get a shell
Starting FAI execution - 20240117_194012
Calling task_defclass
fai-class: Defining classes.
Executing /var/lib/fai/config/class/01-classes.
01-classes           OK.
Executing /var/lib/fai/config/class/10-base-classes.
10-base-classes      OK.
Executing /var/lib/fai/config/class/20-hwdetect.sh.
ens3             UP             52:54:00:11:23:01 &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;
ens3             UP             192.168.33.101/24 fe80::5054:ff:fe11:2301/64
New disklist: vda
20-hwdetect.sh       OK.
Executing /var/lib/fai/config/class/40-parse-profiles.sh.
40-parse-profiles.sh OK.
Executing /var/lib/fai/config/class/41-warning.sh.
41-warning.sh        OK.
Executing /var/lib/fai/config/class/50-host-classes.
50-host-classes      OK.
Executing /var/lib/fai/config/class/60-misc.
60-misc              OK.
Executing /var/lib/fai/config/class/85-efi-classes.
85-efi-classes       OK.
List of all classes:  DEFAULT LINUX AMD64 DHCPC FAIBASE DEBIAN DEMO GRUB_PC demohost2 LAST</code></pre>
</div></div>
<div class="paragraph"><p>You can also see the list of FAI classes, that are defined for this
host. This list is very important for the rest of the installation.</p></div>
<div class="paragraph"><p>The first task is called <em>confdir</em>, which is responsible for getting
access to the config space. Here, we use an NFS mount from the install
server as you can see on the console (and later in the logs).</p></div>
<div class="listingblock">
<div class="content">
<pre><code>FAI_CONFIG_SRC is set to nfs://faiserver/srv/fai/config
Configuration space faiserver:/srv/fai/config mounted to /var/lib/fai/config</code></pre>
</div></div>
<div class="paragraph"><p>Before the installation is started (<code>$FAI_ACTION=install</code>) the computer
beeps three times. So, be careful when you hear three beeps but you do
not want to perform an installation and let FAI erase all yout data on
the local disk!</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_reboot_a_rebooting_the_computer_into_the_new_system"><a id="reboot"></a>Rebooting the computer into the new system</h3>
<div class="paragraph"><p>For rebooting the computer during or at the end of the installation you
should use the command <code>faireboot</code> in favour of the normal reboot command.
Use <code>faireboot</code> also if logged in from remote. If the installation
hasn&#8217;t finished, use <em>faireboot -s</em>, so the log files are also copied
to the install server.</p></div>
<div class="paragraph"><p>If the installation has finished successfully, the computer should boot a
small Debian system. You can login as user <em>demo</em> or <em>root</em> with password <em>fai</em>.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_isetup_a_starting_fai_task_confdir"><a id="isetup"></a>Starting FAI (task confdir)</h3>
<div class="paragraph"><p>After the install client has booted only the script <em>/usr/sbin/fai</em> is
executed. It will do some minimal initialization. The variable
<code>$FAI_CONFIG_SRC</code> <span class="footnote"><br />[It is defined on the kernel command line]<br /></span>
is used to get access to the FAI configuration space which is then
available in the directory <code>$FAI</code> <span class="footnote"><br />[/var/lib/fai/config]<br /></span>. FAI
will not proceed without the config space.</p></div>
<div class="paragraph"><p>You can access the config space using different methods. Supported
methods are: nfs:, file:, cvs:, svn: git:, hg:, http: and detect:.
See <code>fai.conf(5)</code> for a detailed description of these methods.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_iclass_a_defining_classes_and_variables_tasks_defclass_and_defvar"><a id="iclass"></a>Defining classes and variables (tasks defclass and defvar)</h3>
<div class="paragraph"><p>The command <code>fai-class(1)</code> executes scripts in <em>$FAI/class</em> for defining
classes. If the scripts write a string to stdout, this will be defined
as a class. Read all the details in the man page of <code>fai-class(1)</code>.</p></div>
<div class="paragraph"><p>After defining the classes, every file matching <em>.var</em> with a prefix
which matches a defined class is sourced to define variables. It must
contain valid shell code.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_ipartition_a_partitioning_local_disks_creating_file_systems_task_partition"><a id="ipartition"></a>Partitioning local disks, creating file systems (task partition)</h3>
<div class="paragraph"><p>For the disk partitioning exactly one disk configuration file from
<em>$FAI/disk_config</em> is selected using classes.</p></div>
<div class="paragraph"><p>The format of the disk configuration is similar to a fstab file.</p></div>
<div class="paragraph"><p>The partitioning tool <code>setup-storage(8)</code> performs all commands
necessary for creating the disk partition layout, software RAID, LVM
and for creating the file systems. Disks and partitions may easily be
referenced by disk1.1, disk2.4 etc. Read the manual page of
<code>setup-storage(8)</code> for a detailed description and some examples of the
format.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_ipreseed_a_debconf_preseeding_task_debconf"><a id="ipreseed"></a>Debconf preseeding (task debconf)</h3>
<div class="paragraph"><p>Files in <em>$FAI/debconf</em> are used for the usual <code>debconf(7)</code> preseeding
if the file names match a class name.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_ipackages_a_installing_software_packages_task_instsoft"><a id="ipackages"></a>Installing software packages (task instsoft)</h3>
<div class="paragraph"><p>The command <code>install_packages(8)</code> reads the config files from
<em>$FAI/package_config</em> in a class based manner and installs software
packages on the new file system.</p></div>
<div class="paragraph"><p>It installs the packages using <code>apt-get(8)</code>, <code>aptitude(1)</code>, <code>yum</code> or other
package tools without any manual interaction needed. Package
dependecies are also resolved by the package tools.</p></div>
<div class="paragraph"><p>The format of the configuration files is described in <a href="#packageconfig">[packageconfig]</a>.</p></div>
<div class="paragraph"><p>Additionaly FAI will install packages (<em>.deb</em> or .rpm') from the
directories <em>$FAI/pkgs/&lt;CLASSNAME&gt;</em>.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_icscripts_a_site_specific_customization_task_configure"><a id="icscripts"></a>Site specific customization (task configure)</h3>
<div class="paragraph"><p>Often the default configurations of the software packages will not
meet your site-specific needs. You can call arbitrary scripts which
adjust the system configuration. Therefore the command
<code>fai-do-scripts(1)</code> executes scripts in <em>$FAI/scripts</em> in a class
based manner. It is possible to have several scripts of different
types (shell, cfengine, &#8230;) to be executed for one class.</p></div>
<div class="paragraph"><p>The default set of scripts in <em>$FAI/scripts</em> include examples for
installing Debian and Rocky Linux machines. They set the root password, add
a user account (set by '$username, default to demo), set the timezone, configure the network for DHCP
or using a fixed IP address, setup grub and more.
They should do a reasonable job for your installation. You can edit
them or add new scripts to match your local needs.</p></div>
<div class="paragraph"><p>More information about these scripts are described in <a href="#cscripts">[cscripts]</a>.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_isavelog_a_saving_log_files_task_savelog"><a id="isavelog"></a>Saving log files (task savelog)</h3>
<div class="paragraph"><p>When all tasks are finished, the log files are written to
<em>/var/log/fai/$HOSTNAME/install/</em>
<span class="footnote"><br />[<em>/var/log/fai/localhost/install/</em> is a link to this
directory.]<br /></span> on the new system and to the account on the install server
if <code>$LOGUSER</code> is defined (you have to enable this in
<em>/srv/fai/config/class/FAIBASE.var</em>). It is also possible to specify
another host as log saving destination through the variable
<code>$LOGSERVER</code>. If <code>$LOGSERVER</code> is not defined, FAI uses the variable
<code>$SERVER</code> which is only defined during an initial installation (by
get-boot-info).</p></div>
<div class="paragraph"><p>Additionally, two symlinks will be created to indicated the last
directory written to. The symlink <em>last</em> points to the log directory
of the last FAI action performed. The symlinks <em>last-install</em> and
<em>last-sysinfo</em> point to the directory of the last corresponding
action. By default log files will be copied to the log
server using scp. You can use the variable <code>$FAI_LOGPROTO</code> in file
<em>fai.conf(5)</em> to choose another method for saving logs to the remote
server. Here&#8217;s an example of the symlink structure:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>lrwxrwxrwx   1 fai fai   23 Dec  2  2013 last-sysinfo -&gt; sysinfo-20131202_161237
drwxr-xr-x   2 fai fai 4096 Dec  2  2013 sysinfo-20131202_161237
drwxr-xr-x   2 fai fai 4096 Feb 14  2014 install-20140214_142150
drwxr-xr-x   2 fai fai 4096 Dec  2 11:47 install-20141202_113918
lrwxrwxrwx   1 fai fai   23 Dec  4 13:22 last-install -&gt; install-20141204_131351
lrwxrwxrwx   1 fai fai   23 Dec  4 13:22 last -&gt; install-20141204_131351
drwxr-xr-x   2 fai fai 4096 Dec  4 13:22 install-20141204_131351</code></pre>
</div></div>
<div class="paragraph"><p>Examples of the log files can be found at <a href="https://fai-project.org/logs">https://fai-project.org/logs</a>.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_ireboot_a_reboot_the_new_installed_system"><a id="ireboot"></a>Reboot the new installed system</h3>
<div class="paragraph"><p>Before rebooting, the install client calls <code>fai-chboot -d &lt;hostname&gt;</code>
on the install server, to disable its own PXELINUX
configuration. Otherwise, it would restart the installation during the
next boot. Normally this should boot the new installed system from
its second boot device, the local hard disk.</p></div>
<div class="paragraph"><p>At the end, the system is automatically rebooted if "reboot" was added to
<code>$FAI_FLAGS</code>.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_id_advanced_a_advanced_fai_topics"><a id="advanced"></a>Advanced FAI topics</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_a_id_checkbootp_a_checking_parameters_received_from_dhcp_servers"><a id="checkbootp"></a>Checking parameters received from DHCP servers</h3>
<div class="paragraph"><p>If the install client boots you can check
if all information from the DHCP daemon are received
correctly. The received information is written to
<em>/tmp/fai/boot.log</em>. An example of the result of a DHCP request can be
found in the sample log files.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_fai_monitor_a_monitoring_multiple_client_installations"><a id="fai-monitor"></a>Monitoring multiple client installations</h3>
<div class="paragraph"><p>You can monitor the installation of all install clients with the
command <code>fai-monitor(8)</code>. All clients check if this daemon is running
on the install server (or the machine defined by the variable
<code>$monserver</code>). Each time a task starts or ends, a message is sent. The
FAI monitor daemon prints this messages to standard output. There&#8217;s
also a graphical frontend available, called <code>fai-monitor-gui(1)</code>.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$  fai-monitor | fai-monitor-gui - &amp;</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_a_id_mac_a_collecting_ethernet_addresses_for_multiple_hosts"><a id="mac"></a>Collecting Ethernet addresses for multiple hosts</h3>
<div class="paragraph"><p>You have to collect all Ethernet (MAC) addresses of the install
clients and assign a host name and IP address to each client. To
collect the MAC addresses, boot your install clients.
You can already do this before any DHCP daemon is running in your
subnet. They will fail to boot (because of the missing DHCP or missing TFTP),
but you can still collect the MAC addresses.</p></div>
<div class="paragraph"><p>While the install clients are booting, they send broadcast packets to the
LAN. You can log the MAC addresses of these hosts by running the
following command simultaneously on the server:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>faiserver# tcpdump -qtel broadcast and port bootpc &gt;/tmp/mac.list</code></pre>
</div></div>
<div class="paragraph"><p>After the hosts have been sent some broadcast packets abort <code>tcpdump</code>
by typing <em>ctrl-c</em>. You get a list of all
unique MAC addresses with these commands:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>faiserver$ perl -ane 'print "\U$F[0]\n"' /tmp/mac.list|sort|uniq</code></pre>
</div></div>
<div class="paragraph"><p>After that, you only have to assign these MAC addresses to host names
and IP addresses (<em>/etc/ethers</em> and <em>/etc/hosts</em> or corresponding NIS
maps). With this information you can configure your <code>DHCP</code>
daemon (see the section <a href="#bootdhcp">[bootdhcp]</a>). <span class="footnote"><br />[I recommend to write the MAC
addresses (last three bytes will suffice if you have network cards
from the same vendor) and the host name in the front of each chassis.]<br /></span></p></div>
<div class="sect3">
<h4 id="_debugging_the_network_traffic">Debugging the network traffic</h4>
<div class="paragraph"><p>If the client can&#8217;t successfully boot from the network card, use
<code>tcpdump(8)</code> to look for Ethernet packets between the install server
and the client. Search also for entries in several log files made by
<code>tftpd(8)</code> and <code>dhcpd(8)</code> :</p></div>
<div class="listingblock">
<div class="content">
<pre><code>faiserver$ egrep "tftpd|dhcpd" /var/log/*</code></pre>
</div></div>
</div>
</div>
<div class="sect2">
<h3 id="_a_id_pxeboot_a_details_of_pxe_booting"><a id="pxeboot"></a>Details of PXE booting</h3>
<div class="paragraph"><p>Here we describe the details of PXE booting, which are only needed if
you have problems when booting your install clients.</p></div>
<div class="paragraph"><p>Almost all modern bootable network cards support the PXE boot environment.
PXE is the Preboot Execution Environment.
This requires the PXELINUX bootloader and a special version of the <em>TFTP</em>
daemon, which is available in the Debian packages <code>pxelinux</code> and
<code>tftpd-hpa</code>. PXE booting also needs a DHCP server, so that the network
card can configure its IP parameters. This is the sequence of a PXE boot:</p></div>
<div class="ulist"><ul>
<li>
<p>
Network card of the client sends its MAC address
</p>
</li>
<li>
<p>
DHCP server replies with IP configuration for the client
</p>
</li>
<li>
<p>
Network card configures IP
</p>
</li>
<li>
<p>
Install client gets the pxelinux.0 binary via TFTP
</p>
</li>
<li>
<p>
Get the pxelinux.cfg/C0A8210C configuration file via TFTP
</p>
</li>
<li>
<p>
C0A8210C is the IP address of the client in hexadecimal
</p>
</li>
<li>
<p>
This configuration contains kernel, initrd and additional kernel
command line parameters, which was created by <code>fai-chboot</code>.
</p>
</li>
<li>
<p>
Get the kernel and initrd via TFTP.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Example of a pxelinux.cfg file:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>default fai-generated

label fai-generated
kernel vmlinuz-6.1.0-17-amd64
append initrd=initrd.img-6.1.0-17-amd64 ip=dhcp root=/srv/fai/nfsroot rootovl FAI_FLAGS=verbose,sshd,createvt FAI_CONFIG_SRC=nfs://faiserver/srv/fai/config FAI_ACTION=install</code></pre>
</div></div>
<div class="paragraph"><p>See <em>/usr/share/doc/syslinux/pxelinux.doc</em> for more detailed
information about PXELINUX. FAI uses the lpxelinux.0 binary which also
supports loading the kernel and initrd via FTP or HTTP. The command
<em>fai-chboot(8)</em> supports this with the option <em>-U</em>.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_customizing_your_install_server_setup_a_customizing_your_install_server_setup"><a id="Customizing your install server setup"></a>Customizing your install server setup</h3>
<div class="ulist"><ul>
<li>
<p>
local/faster package mirror
</p>
</li>
<li>
<p>
different loguser
</p>
</li>
<li>
<p>
local root pw inside nfsroot
</p>
</li>
</ul></div>
<div class="paragraph"><p>The configuration for the FAI package (not the configuration data for
the install clients) is defined in <em>fai.conf(5)</em>. Definitions that are
only used for creating the nfsroot are located in
<em>nfsroot.conf(5)</em>. Check these important variables in <em>nfsroot.conf</em>
before calling <em>fai-setup</em> or <em>fai-make-nfsroot</em>.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
FAI_DEBOOTSTRAP
</dt>
<dd>
<p>
Building the nfsroot uses the command <code>debootstrap(8)</code>. It needs the location of a Debian mirror and the
name of the distribution (like bullsseye, bookworm, sid) for which the basic Debian
system should be built. Do not use different distributions here and in
<em>/etc/fai/apt/sources.list</em>. This will create a broken nfsroot.
</p>
</dd>
<dt class="hdlist1">
NFSROOT_ETC_HOSTS
</dt>
<dd>
<p>
This variable is only needed if the clients do not have access to a DNS server.
This multiline variable is added to /etc/hosts inside the
nfsroot. Then the install clients can access those hosts by name
without using DNS.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>The content of <em>/etc/fai/apt/sources.list</em> is
used by the install server and also by the clients. If your install
server has multiple network cards and different host names for each
card (as for a Beowulf server), use the install server name which is
known by the install clients.</p></div>
<div class="paragraph"><p>If you have problems running <code>fai-setup</code>, they usually stem from
<code>fai-make-nfsroot(8)</code> which is called by former command. Adding <em>-v</em>
gives you a more verbose output which helps you pinpoint the
error. The output is written to
<em>/var/log/fai/fai-make-nfsroot.log</em>. <span class="footnote"><br />[For debugging purpose
it may help to enter the chroot environment manually using this
command.  <em>faiserver# chroot /srv/fai/nfsroot bash</em>]<br /></span></p></div>
<div class="paragraph"><p>The setup also creates the account <em>fai</em> (defined by <code>$LOGUSER</code>) if
not already available. So you can add a user before calling
<code>fai-setup(8)</code> using the command <code>adduser(8)</code> and use this as your
local account for saving log files. The log files of all install
clients are saved to the home directory of this account. You should
change the primary group of this
account, so this account has write permissions to <em>/srv/tftp/fai</em> in
order to call fai-chboot for creating the PXE configuration for the hosts.</p></div>
<div class="paragraph"><p>When you make changes to <em>fai.conf</em>, <em>nfsroot.conf</em> the
nfsroot has to be rebuilt by calling <code>fai-make-nfsroot(8)</code>. If you
only like to install a new kernel package to the nfsroot add the flags <em>-k</em> or
<em>-K</em> to <code>fai-make-nfsroot</code>. This will not recreate your nfsroot, but
only updates your kernel and kernel modules inside the nfsroot or add
additional packages into the nfsroot.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_cdboot_a_creating_a_fai_cd_or_and_usb_stick"><a id="cdboot"></a>Creating a FAI CD or and USB stick</h3>
<div class="paragraph"><p>You can easily create an installation CD (or USB stick) of your
network installation setup. This will perform the same installation
and configuration from CD without the need of the install server.
Therefore you need to create a partial mirror of all Debian packages
needed for your FAI classes (using <code>fai-mirror(1)</code>). Then the command
<code>fai-cd(8)</code> will put this mirror, the nfsroot and the config space
onto a bootable CD. That&#8217;s it!</p></div>
<div class="paragraph"><p>To easily create the installation CD, you can use the following command
(for more tuning details see <code>fai-cd(8)</code>):</p></div>
<div class="listingblock">
<div class="content">
<pre><code> faiserver# fai-cd -m &lt;partialMirrorDir&gt; fai-cd.iso</code></pre>
</div></div>
<div class="paragraph"><p>This installation CD contains all data needed for the
installation. The command <code>fai-cd(8)</code> puts the nfsroot, the
configuration space and a subset of the Debian mirror onto a
CD-ROM. A partial package mirror is created using the command
<code>fai-mirror(1)</code> which contains all packages that are used by the
classes used in your configuration space.  A sample ISO image is
available at <a href="https://fai-project.org/fai-cd">https://fai-project.org/fai-cd</a>.</p></div>
<div class="paragraph"><p>Using the command <code>dd(1)</code> you can also create a bootable USB
stick by just writing the content of the ISO file to your USB stick
(here the stick is <em>/dev/sdf</em>).</p></div>
<div class="listingblock">
<div class="content">
<pre><code> faiserver# dd if=fai-cd.iso of=/dev/sdf bs=1M</code></pre>
</div></div>
<div class="paragraph"><p><code>mk-data-partition</code> is a tool that extends an ISO (that will be copied
to an USB stick) or an USB stick containing an ISO with
an ext4 or exFAT partition and sets the file system label to MY-DATA.
This partition is automatically mounted to <em>/media/data</em> by FAI.
You can copy your own <em>.deb</em> packages into this data partition und the
subdiretories <em>pkgs/&lt;CLASSNAME&gt;</em>. FAI will then install these packages
if the equivalent class is defined.</p></div>
<div class="paragraph"><p>Example how to use <code>mk-data-partition</code>:</p></div>
<div class="listingblock">
<div class="content">
<pre><code># mk-data-partition -s 1G -c faicd-large.iso A B</code></pre>
</div></div>
<div class="paragraph"><p>The former command creates the data partition of size 1 Gbytes inside
the ISO file and copy directories A and B to it. You can then copy the modified ISO
onto an USB stick.</p></div>
<div class="paragraph"><p>If the ISO is already on the USB stick and if it&#8217;s available as
<em>dev/sdf</em>, you can add a data partition of type exFAT will will use
the whole remaining part of the USB stick by using this command:</p></div>
<div class="listingblock">
<div class="content">
<pre><code># mk-data-partition -F /dev/sdf</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_a_id_diskimage_a_creating_vm_disk_images_using_fai"><a id="diskimage"></a>Creating VM disk images using FAI</h3>
<div class="paragraph"><p>The command <code>fai-diskimage(8)</code> creates disk
images, which can be used with a virtual machine like KVM, VMware,
VirtualBox or a cloud service like OpenStack, GCE, EC2 and others. The
installation process performs the normal FAI tasks on a raw disk
image. After the installation you can boot the disk image and have a
running system. The disk image can also be converted to qcow2 format.
You do not need to setup the FAI nfsroot when only using
fai-diskimage. But you need a basefile in your configuration
space. Setting the variable <code>$FAI_BASEFILEURL</code> will automatically
download an appropriate base file into your config space.</p></div>
<div class="paragraph"><p>Here&#8217;s an example how to create a raw disk image for a host called
cloud3, with a small set of software packages:</p></div>
<div class="listingblock">
<div class="content">
<pre><code># export FAI_BASEFILEURL=https://fai-project.org/download/basefiles/
# fai-diskimage -vu cloud3 -S2G -cDEBIAN,BOOKWORM64,AMD64,FAIBASE,GRUB_PC,DHCPC,DEMO,CLOUD,LAST disk.raw</code></pre>
</div></div>
<div class="paragraph"><p>This command will create a disk image called ubuntu.qcow2 for a Ubuntu 16.04 desktop
with hostname set to foobar.</p></div>
<div class="listingblock">
<div class="content">
<pre><code># export FAI_BASEFILEURL=https://fai-project.org/download/basefiles/
# cl=DHCPC,UBUNTU,JAMMY,JAMMY64,AMD64,XORG,LAST
# fai-diskimage -Nvu foobar -S5G -c$cl ubuntu.qcow2</code></pre>
</div></div>
<div class="paragraph"><p>You can give disk images a try without installing FAI, if you visit
<a href="https://fai-project.org/FAIme/cloud">https://fai-project.org/FAIme/cloud</a></p></div>
</div>
<div class="sect2">
<h3 id="_a_id_live_image_a_creating_a_bootable_live_image"><a id="live-image"></a>Creating a bootable live image</h3>
<div class="paragraph"><p>Creating a bootable live ISO is easy with FAI. You only need two
steps. First, create your live environment using the command <em>fai
dirinstall</em>. Don&#8217;t forget to add the class <code>LIVEISO</code>.
Then create the live ISO using <em>fai-cd</em>:</p></div>
<div class="listingblock">
<div class="content">
<pre><code># cl="DEBIAN,BOOKWORM64,AMD64,FAIBASE,XFCE,XORG,DHCPC,DEMO,LIVEISO,LAST"
# LC_ALL=C fai -v dirinstall -u xfce33 -c $cl \
    -s file:///srv/fai/config /srv/xfce
# fai-cd -s500 -MH -d none -g /etc/fai/grub.cfg.live \
    -n /srv/xfce live.iso</code></pre>
</div></div>
<div class="paragraph"><p>The nfsroot is not needed for a live ISO.
Currently there&#8217;s no live ISO of the install server available.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_cross_arch_a_building_cross_architecture_disk_images"><a id="cross-arch"></a>Building cross-architecture disk images</h3>
<div class="paragraph"><p>Starting FAI 5.4 it&#8217;s now possible to build a disk image for
different architectures than the host is running. For example you can
build an image for 64-bit ARM architecture (aarch64) on a host running on amd64
architecture. Here are the steps do to:</p></div>
<div class="listingblock">
<div class="content">
<pre><code># apt install qemu-system-arm qemu-user-static fai-server fai-setup-storage fai-doc qemu-utils
# fai-mk-configspace

# export FAI_BASEFILEURL=https://fai-project.org/download/basefiles/
# fai-diskimage -vu armhost -S2G -cDEFAULT,DHCPC,DEBIAN,ARM64,BUSTER_ARM64,FAIBASE,DEMO,CLOUD,LAST arm64.raw
# chown your_user_id arm64.raw
# cp /var/log/fai/armhost/last/vmlinuz* vmlinuz
# cp /var/log/fai/armhost/last/initrd.img* initrd</code></pre>
</div></div>
<div class="paragraph"><p>Then you can run qemu as a normal user:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&gt; qemu-system-aarch64 -m 1000 -M virt,gic_version=3 -cpu cortex-a57 -drive file=arm64.raw,if=virtio,index=1 -no-reboot -nographic -name ARM64 -net nic,name=eth0,model=virtio -net user,name=eth0,-kernel vmlinuz -initrd initrd -append "console=ttyAMA0 rw ip=dhcp root=/dev/vda1 net.ifnames=0"</code></pre>
</div></div>
<div class="paragraph"><p>This works similar for other architectures.
Keep in mind, that qemu network setup will have poor performance if
not using the virtio driver as above or tap devices.</p></div>
<div class="paragraph"><p>You can find the base files for many architectures at
<a href="https://fai-project.org/download/basefiles/">https://fai-project.org/download/basefiles/</a>, or use <code>mk-basefile</code> to
create your own.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_sysinfo_a_fai_rescue_system"><a id="sysinfo"></a>FAI rescue system</h3>
<div class="paragraph"><p>If you set the variable <code>$FAI_ACTION</code> to <em>sysinfo</em> (for e.g. by using
<code>fai-chboot -S</code>), the client will not install a new system, but will
collect a lot of system information.
If you set <code>$FAI_ACTION</code> to <em>inventory</em> you will only get a few
hardware information.
Both actions can be used for FAI as a rescue system.</p></div>
<div class="paragraph"><p>Type <em>ctrl-c</em> to get a shell or use <em>Alt-F2</em> or <em>Alt-F3</em> and you will get
another console terminal, if you have added <em>createvt</em> to <code>$FAI_FLAGS</code>.</p></div>
<div class="paragraph"><p>You now have a running Linux system on the install client without
using the local hard disk. Use this as a rescue system if your local
disk is damaged or the computer can&#8217;t boot properly from hard
disk. You will get a shell and you can execute various commands
(<code>dmesg</code>, <code>lsmod</code>, <code>df</code>, <code>lspci</code>, &#8230;). Look at the log file in
<em>/tmp/fai</em>. There you can find much information about the boot
process.</p></div>
<div class="paragraph"><p>FAI mounts all file systems it finds on the local disks read only. It
also tells you on which partition a file <em>/etc/fstab</em> exists. When
only one file system table is found, the partitions are mounted
according to this information. Here&#8217;s an example:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>demohost:~# df -h

Filesystem                Size  Used Avail Use% Mounted on
devtmpfs                  4.0M     0  4.0M   0% /dev
tmpfs                     2.0G     0  2.0G   0% /dev/shm
tmpfs                     783M   18M  766M   3% /run
tmpfs                     5.0M     0  5.0M   0% /run/lock
LiveOS_rootfs             783M   18M  766M   3% /
192.168.33.250:/srv/fai/config   59G   23G   24G  49% /var/lib/fai/config
/dev/mapper/vg1-root      7.3G  1.8G  5.2G  26% /target
/dev/vda1                 459M   53M  378M  13% /target/boot
/dev/mapper/vg1-home      1.4G   72K  1.3G   1% /target/home</code></pre>
</div></div>
<div class="paragraph"><p><strong>This method can be used as a rescue environment!</strong> If you need a file
system with read-write access use the <code>rwmount</code> command:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>demohost# rwmount /target/home</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_a_id_nonfs_a_fai_without_nfs"><a id="nonfs"></a>FAI without NFS</h3>
<div class="paragraph"><p>To boot into FAI and begin the installation sequence
without using the NFS protocol, you boot the client machine using PXE as
usual and then retrieve an image containing the nfsroot via http.</p></div>
<div class="paragraph"><p>To create an image, use fai-cd&#8217;s -S argument and -M to avoid setting up
a partial mirror within the image.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>faiserver# fai-cd -M -S squash.img</code></pre>
</div></div>
<div class="paragraph"><p>Move this image to a directory from which it can be requested via http
(usually a directory served by the webserver)</p></div>
<div class="paragraph"><p>To now request the squashfs image, add the following to your kernel
command line, e.g. in your pxelinux configuration file for the client
with fai-chboot.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>root=live:http://faiserver/cskoeln/squash.img FAI_CONFIG_SRC=file:///var/lib/fai/config</code></pre>
</div></div>
<div class="paragraph"><p>Replace faiserver with the domain name or IP of the machine your
squash image is served from.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_otherdists_a_installing_other_distributions_using_a_debian_nfsroot"><a id="otherdists"></a>Installing other distributions using a Debian nfsroot</h3>
<div class="paragraph"><p>You can install all sorts of Linux distributions from a single Debian
nfsroot. Therefore you have to create a base.tar.xz of the distribution
you like to install and place it into the <code>basefiles</code> directory. Then
name it UBUNTU2204.tar.xz for example. An install client which belongs
to the class UBUNTU2204 then extracts this base file into its empty
file system. Additionally you have to adjust the <em>sources.list</em> or
similar configuration files which are needed for specifying the
location of the package repository.</p></div>
<div class="paragraph"><p>The tool <code>rinse(8)</code> is used for creating base files for distribution
like Rocky Linux, CentOS, openSUSE  or Fedora.
Some basefiles can be downloaded from
<a href="https://fai-project.org/download/basefiles/">https://fai-project.org/download/basefiles/</a>.</p></div>
<div class="paragraph"><p>The script <code>mk-basefile</code> in
<em>/usr/share/doc/fai-doc/examples/simple/basefiles/</em> helps creating
this base files.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_dirinstall_a_creating_chroot_and_virtualization_environments"><a id="dirinstall"></a>Creating chroot and virtualization environments</h3>
<div class="paragraph"><p>If you have to create some chroot environments, or a virtualization
environment where you neither can nor want to run a normal Debian
Installer in to get to a working system (for example, Xen guest
domains), there is the FAI action <em>dirinstall</em>.
By calling</p></div>
<div class="listingblock">
<div class="content">
<pre><code>faiserver# fai &lt;options&gt; dirinstall &lt;target-directory&gt;</code></pre>
</div></div>
<div class="paragraph"><p>and using either the option <em>-c &lt;classes&gt;</em> or <em>-N</em> you get a FAI
installation, without the partitioning action, right into the target
directory. The host name for the target installation can be specified
using <em>-u &lt;host-name&gt;</em></p></div>
<div class="paragraph"><p>This, for example, can be used to combine FAI with the tool
<em>xen-tools</em>, which helps you to build Xen guest domains. <em>xen-tools</em>
are very nice for generating configuration files and block devices for
new guests based on simple commands and/or configuration files, but
they can only assign one role per installation for customization.
FAI-users need and want more, as they are used to have the class
system.  They get them even in xen-tools installations, by using the
following code as a xen-tools role script:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>#!/bin/sh
TARGET=$1
CMD="fai -N  -v -u ${hostname} dirinstall $TARGET"
echo running $CMD
$CMD</code></pre>
</div></div>
<div class="paragraph"><p>Then, you should set the variable <em>install=0</em> in the config of
xen-tools for that host.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_softupdate_a_using_fai_for_updates"><a id="softupdate"></a>Using FAI for updates</h3>
<div class="paragraph"><p>FAI can also do updates of already running systems, without a
re-installation from scratch.
This is called softupdate. A FAI softupdate skips the tasks which are
not suitable for updating a running system, like partitioning the
hard disks and creating file systems. Instead, it only executes the
tasks for updating and installing software packages and calling the
customization scripts.</p></div>
<div class="paragraph"><p>To run a softupdate call:</p></div>
<div class="listingblock">
<div class="content">
<pre><code># fai -v -s nfs://faiserver/srv/fai/config softupdate</code></pre>
</div></div>
<div class="paragraph"><p>By default, a softupdate uses the list of classes defined during the
initial installation. Make sure to set the variable <code>$LOGSERVER</code> (done
in a <em>class/*.var</em> file) if FAI should save the log files to a remote
machine.</p></div>
<div class="paragraph"><p>It&#8217;s up to you, how to start a softupdate on a bigger number of hosts.
You may do the softupdate on a regular basis via cron or you can use tools
like <code>clusterssh(1)</code> to start a softupdate via a push on a list of
hosts.</p></div>
<div class="paragraph"><p>Keep in mind, that the customization scripts are run every time you do
a softupdate. That means, they have to be <strong>idempotent</strong> i.e. the result
of their operation should always produce the same result, even when
they run more than once.</p></div>
<div class="paragraph"><p>For example appending a line to a file must not done via this code:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ echo "some strings" &gt;&gt; /etc/fstab</code></pre>
</div></div>
<div class="paragraph"><p>Instead use the command <code>ainsl(1)</code> in a shell script or use cfengine&#8217;s
function <em>AppendIfNoSuchLine</em>.</p></div>
<div class="paragraph"><p>All commands in the customization script must be capable of modifying
the target file system wether it&#8217;s available in <em>/target</em> during the
initial installation or wether it&#8217;s the normal file system relative to
<em>/</em> during softupdate.</p></div>
<div class="paragraph"><p>Here are some variable that help writing these scripts:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<code>$target</code>
</dt>
<dd>
<p>
Points to the root directory of the client, which
is <em>/target</em> during installation and <em>/</em> during a softupdate.
</p>
</dd>
<dt class="hdlist1">
<code>$FAI_ROOT</code>
</dt>
<dd>
<p>
It&#8217;s the same value as <code>$target</code>. For historic reasons
we have both these variables in FAI.
</p>
</dd>
<dt class="hdlist1">
<code>$ROOTCMD</code>
</dt>
<dd>
<p>
In case of the installation this is an alias for <em>chroot $target</em> in case of
softupdate it&#8217;s just empty. You can prepend this to commands if you need to run a
command inside the clients target file system via chroot.
</p>
</dd>
<dt class="hdlist1">
<code>$FAI_ACTION</code>
</dt>
<dd>
<p>
If you need to call code depending on the FAI action performed, you
can use this variable. It contains the currently executed action:
<em>install</em>, <em>softupdate</em>, <em>dirinstall</em>, <em>sysinfo</em>, <em>inventory</em> or your
own defined action.
</p>
</dd>
</dl></div>
</div>
<div class="sect2">
<h3 id="_a_id_archcross_a_how_to_install_32_bit_os_from_a_64_bit_os"><a id="archcross"></a>How to install 32-bit OS from a 64-bit OS</h3>
<div class="paragraph"><p>To install a computer with a 32-bit OS, you need an i386 nfsroot.
Creating this 32-bit nfsroot on an install server running amd64 is
quite simple. Install and set up the FAI packages. Then copy your FAI
config files to a new subdirectory.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>faiserver# cp -a /etc/fai /etc/fai-i386</code></pre>
</div></div>
<div class="paragraph"><p>Edit the variable <code>$FAI_DEBOOTSTRAP_OPTS</code> in
<em>/etc/fai-i386/nfsroot.conf</em> and add the option <code>--arch
i386</code>. Also choose a different directory for your new nfsroot. Here
are the two lines after editing.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>NFSROOT=/srv/fai/nfsroot-i386
FAI_DEBOOTSTRAP_OPTS="--arch i386 --exclude=info --include=aptitude""</code></pre>
</div></div>
<div class="paragraph"><p>Now call fai-make-nfsroot which creates the 32-bit nfsroot in
<em>/srv/fai/nfsroot-i386</em></p></div>
<div class="listingblock">
<div class="content">
<pre><code>faiserver# fai-make-nfsroot -v -C/etc/fai-i386</code></pre>
</div></div>
<div class="paragraph"><p>Creating a partial mirror using <code>fai-mirror(1)</code> that is needed for
a bootable CD or USB stick is also possible on a different architecture.
You have to specify the architecture when calling fai-mirror.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ fai-mirror -m800 -B -a i386 -v -cDEFAULT,DEBIAN,FAIBASE,I386 /srv/mirror-i386</code></pre>
</div></div>
<div class="paragraph"><p>That&#8217;s all!</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_error_a_aborting_the_installation_when_an_error_occurs"><a id="error"></a>Aborting the installation when an error occurs</h3>
<div class="paragraph"><p>Every task and hook can call the function <code>task_error</code>
to send an error value to the installation. This error will appear in
the log file and can be shown in the <code>fai-monitor-gui(1)</code>.
The error value is also checked against the variable <code>$STOP_ON_ERROR</code>
which is set to 700 by default. If the error value
is greater than <code>$STOP_ON_ERROR</code>  the installation will stop
immediately. In a hook, just add a call like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>task_error &lt;value&gt;</code></pre>
</div></div>
<div class="paragraph"><p>It is comfortable to call task_error with $? as second parameter, for
e.g. if you want to set an error value of 123 use this</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;some command&gt;
task_error 123 $?</code></pre>
</div></div>
<div class="paragraph"><p>Then the task error is only set if the preceding command failed with
some error. The same syntax can be used by the scripts in the class
subdirectory ending in .sh.</p></div>
<div class="paragraph"><p>A special case are scripts inside the class/ subdirectory that does
not end in .sh. In those scripts you have to call task_error with 1 as
third parameter. As an example you can use those two variants for
setting the value to 123</p></div>
<div class="listingblock">
<div class="content">
<pre><code>task_error 123 $? 1</code></pre>
</div></div>
<div class="paragraph"><p>or</p></div>
<div class="listingblock">
<div class="content">
<pre><code>task_error 123 1 1</code></pre>
</div></div>
<div class="paragraph"><p>The latter command always sets the task error to 123 regardless of
the value of <code>$?</code>. If the error value is greater than <code>$STOP_ON_ERROR</code>,
the installation will abort immediately.</p></div>
<div class="paragraph"><p>The error values are grouped into four categories</p></div>
<div class="listingblock">
<div class="content">
<pre><code>normal or info messages:       1xx, 2xx
warnings:                      3xx, 4xx
minor errors:                  5xx, 6xx
errors:                        7xx, 8xx</code></pre>
</div></div>
<div class="paragraph"><p>The fai-monitor-gui has 4 different icons for these error categories.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_id_hints_a_various_hints_and_details"><a id="hints"></a>Various hints and details</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_a_id_tasks_a_the_list_of_tasks"><a id="tasks"></a>The list of tasks</h3>
<div class="paragraph"><p>Most tasks of the installation are defined as subroutines which are
defined in <em>/usr/lib/fai/subroutines</em> (e.g. <code>task_instsoft</code>).
Some are external shell scripts located in <em>/usr/lib/fai/</em>.
They are called via a superior subroutine called <em>task</em>.
This subroutine calls hooks if available and then calls the task (defined as
<em>task_&lt;name&gt;</em>). A task and its hooks can be
skipped on demand by using the command <em>skiptask()</em>.</p></div>
<div class="paragraph"><p>Now follows the description of all tasks, listed in the order
they are executed.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
confdir
</dt>
<dd>
<p>
The kernel appended parameters may define variables, the syslog daemon is
started. Network parameters are fetched from a DHCP
server and are stored in <code>boot.log</code>. The DNS resolver configuration file is created.
</p>
<div class="paragraph"><p>The location of the configuration space is defined by the variable
<code>$FAI_CONFIG_SRC</code>.</p></div>
<div class="paragraph"><p>After that, the file <em>$FAI/hooks/subroutines</em> is sourced if it
exists. Using this file, you can define your own subroutines or
override the definition of FAI&#8217;s subroutines.</p></div>
</dd>
<dt class="hdlist1">
setup
</dt>
<dd>
<p>
This task sets the system time, all <code>$FAI_FLAGS</code> are defined and two
additional virtual terminals are opened on demand. A secure shell
daemon is started on demand for remote logins.
</p>
</dd>
<dt class="hdlist1">
defclass
</dt>
<dd>
<p>
Calls <code>fai-class(1)</code> to define classes using scripts and files in
<em>$FAI/class</em> and classes from <em>/tmp/fai/additional-classes</em> and the
variable <code>$ADDCLASSES</code>. The list of all defined classes is stored in
the variable <code>$classes</code> and saved to <em>/tmp/fai/FAI_CLASSES</em>.
</p>
</dd>
<dt class="hdlist1">
defvar
</dt>
<dd>
<p>
Sources all files <em>$FAI/class/*.var</em> for every defined class. If a
hook has written some variable definitions to the file
<em>$LOGDIR/additional.var</em>, this file is also sourced.
</p>
</dd>
<dt class="hdlist1">
action
</dt>
<dd>
<p>
Depending on the value of <code>$FAI_ACTION</code> this subroutine decides which
action FAI should perform. The default available actions are:
<em>sysinfo</em>, <em>install</em>, <em>inventory</em>, <em>dirinstall</em> and <em>softupdate</em>.  If <code>$FAI_ACTION</code> has another
value, a user defined action is called if a file
<em>$FAI/hooks/$FAI_ACTION</em> exists. So you can easily define your own
actions.
</p>
</dd>
<dt class="hdlist1">
sysinfo
</dt>
<dd>
<p>
Called when no installation is performed but the action is
<em>sysinfo</em>. It shows information about the detected hardware and mounts
the local hard disks read only to <em>/target/<code>partitionname</code></em> or with
regard to a <em>fstab</em> file found inside a partition. Log files are
stored to the install server.
</p>
</dd>
<dt class="hdlist1">
inventory
</dt>
<dd>
<p>
A short list of system information is printed.
</p>
</dd>
<dt class="hdlist1">
install
</dt>
<dd>
<p>
This task controls the installation sequence. You will hear three
beeps before the installation starts. The major work is to call other
tasks and to save the output to <em>/tmp/fai/fai.log</em>. If you have any
problems during installation, look at all files in <em>/tmp/fai/</em>. You
can find examples of the log files
at <a href="https://fai-project.org/logs/">https://fai-project.org/logs/</a>.
</p>
</dd>
<dt class="hdlist1">
dirinstall
</dt>
<dd>
<p>
Install into a directory, not onto a local disk. Use this for creating
chroot environments.
</p>
</dd>
<dt class="hdlist1">
softupdate
</dt>
<dd>
<p>
This task, executed inside a running system via the <code>fai(8)</code> command
line interface, performs a softupdate.  See chapter <a href="#softupdate">[softupdate]</a> for
details.
</p>
</dd>
<dt class="hdlist1">
partition
</dt>
<dd>
<p>
Calls <code>setup-storage(8)</code> to partition the hard
disks and to create file systems. The task writes variable definitions
for the root and boot partition and device (<code>$ROOT_PARTITION,
$BOOT_PARTITION, $BOOT_DEVICE</code>) to <em>/tmp/fai/disk_var.sh</em> and creates
a <em>fstab</em> file for the new system.
</p>
</dd>
<dt class="hdlist1">
mountdisks
</dt>
<dd>
<p>
Mounts the created partitions according to the created
<em>/tmp/fai/fstab</em> file relative to <code>$FAI_ROOT</code>.
</p>
</dd>
<dt class="hdlist1">
extrbase
</dt>
<dd>
<p>
Extracts a minimal system after that a chroot can be made into it. By
default the base tar file <em>/var/tmp/base.tar.xz</em> will be
extracted. Also files matching a class name in <code>$FAI/basefiles/</code> are used for unpacking a
different tar file depending on classes defined. This can be used for
installing different Linux distributions than the one used for
creating the nfsroot. The default file <em>base.tar.xz</em> is a snapshot of a
basic Debian system created by <code>debootstrap(8)</code>.
This task uses the variable <code>FAI_BASEFILEURL</code> for fetching the base
file via FTP, HTTPS or HTTP if it&#8217;s defined.
</p>
</dd>
<dt class="hdlist1">
debconf
</dt>
<dd>
<p>
Calls <code>fai-debconf(1)</code> to set the values for the debconf preseeding database.
</p>
</dd>
<dt class="hdlist1">
repository
</dt>
<dd>
<p>
Prepare access to the package repository by preparing the apt
configuration. This can also add repository keys
in a class based manner from files like <em>CLASSNAME.gpg</em>
in the directory <em>package_config</em>.
</p>
</dd>
<dt class="hdlist1">
updatebase
</dt>
<dd>
<p>
Updates the base packages of the new system and updates the list of
available packages. It also fakes some commands (called diversions)
inside the new installed system using <code>dpkg-divert(8)</code>, so no daemons
will be started during the installation.
</p>
</dd>
<dt class="hdlist1">
instsoft
</dt>
<dd>
<p>
Installs the desired software packages using class files in
<em>$FAI/package_config/</em>.
</p>
</dd>
<dt class="hdlist1">
configure
</dt>
<dd>
<p>
Calls scripts in <em>$FAI/scripts/</em> and its subdirectories for every
defined class.
</p>
</dd>
<dt class="hdlist1">
tests
</dt>
<dd>
<p>
Calls test scripts in <em>$FAI/tests/</em> and its subdirectories for every
defined class.
</p>
</dd>
<dt class="hdlist1">
finish
</dt>
<dd>
<p>
Unmounts all file systems in the new installed system and removes
diversions of files using the command <code>fai-divert</code>.
</p>
</dd>
<dt class="hdlist1">
chboot
</dt>
<dd>
<p>
Changes the PXE configuration for a host on the install server which
indicates which PXELINUX configuration to load on the next boot from network
card via TFTP. Therefore the <code>fai-chboot(8)</code> command is executed
remotely on the install server.
</p>
</dd>
<dt class="hdlist1">
savelog
</dt>
<dd>
<p>
Saves log files to local disk and to the account <code>$LOGUSER</code> on
<code>$LOGSERVER</code> (defaults to the install server).
</p>
</dd>
<dt class="hdlist1">
faiend
</dt>
<dd>
<p>
Wait for background jobs to finish (e.g. emacs compiling lisp files)
and automatically reboots the install clients or waits for manual
input before reboot.
</p>
</dd>
</dl></div>
</div>
<div class="sect2">
<h3 id="_a_id_itests_a_automated_tests"><a id="itests"></a>Automated tests</h3>
<div class="paragraph"><p>After the customization scripts are executed, FAI will execute some
tests if available. Using these test, you can check for errors of the
installation. Test scripts are called via
<code>fai-do-scripts(1)</code> and should append its messages to
<em>$LOGDIR/test.log</em>. A Perl module including some useful subroutines
can be found in <em>Faitest.pm</em>. A test can also define a new class for
executing another tests during next boot via the variable
<code>$ADDCLASSES</code>.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_autodiscover_a_autodiscover"><a id="autodiscover"></a> Autodiscover</h3>
<div class="paragraph"><p>In FAI 5.0 we released a feature that allows clients to search for the
faiserver in their respective subnetwork. This lifts the necessity of
having to collect every client&#8217;s MAC address and configuring the DHCP
daemon.</p></div>
<div class="paragraph"><p>This is done by booting from a small FAI autodiscover bootmedium (CD,
USB, etc.), which can be created via the command:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>faiserver# fai-cd -A autodiscover.iso</code></pre>
</div></div>
<div class="paragraph"><p>The image is roughly 25MB in size and scans the  subnet  for
a  FAI server. By  default it shows a menu with all profiles available
in the configuration space in the same manner as the <em>menu</em> flag
does. From this menu, you can select the installation type you wish to
perform.</p></div>
<div class="paragraph"><p>For the clients to find the faiserver, the faiserver must run
fai-monitor.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_changeboot_a_changing_the_boot_device"><a id="changeboot"></a>Changing the boot device</h3>
<div class="paragraph"><p>Changing the boot sequence is normally done in the BIOS setup. But you
can&#8217;t change the BIOS from a running Linux system.</p></div>
<div class="paragraph"><p>So, the boot sequence of the BIOS will remain unchanged and
your computer should always boot first from its network card and the
second boot device should be the local disk. Then you can
change the boot device of the client by creating different PXELINUX
configurations. This will define if an installation
should be performed, or if the client should to boot from local
disk. This is done using <code>fai-chboot(8)</code>.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_debian_mirror_a_how_to_create_a_local_debian_mirror"><a id="debian-mirror"></a>How to create a local Debian mirror</h3>
<div class="paragraph"><p>The utility <code>mkdebmirror</code> <span class="footnote"><br />[You can find the script in
<em>/usr/share/doc/fai-doc/examples/utils/</em>]<br /></span> can be used for creating
your own local Debian mirror. This script uses <code>debmirror(1)</code>. A partial Debian mirror for amd64 architecture for
Debian 11 and 12 (aka bullseye and bookworm) without the source packages needs about
180GB of disk space.
Accessing the mirror via HTTP will be the
default way in most cases. To see more output from the script call
<code>mkdebmirror -v</code>. A root account is not necessary to create and
maintain the Debian mirror.</p></div>
<div class="paragraph"><p>To use HTTP access to the local Debian mirror, install a web server
and create a symlink to the local directory where your mirror is
located:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>faiserver# apt-get install apache2
faiserver# ln -s /files/scratch/debmirror /var/www/html/debmirror</code></pre>
</div></div>
<div class="paragraph"><p>Create a file <code>sources.list(5)</code> in <em>/etc/fai/apt</em> which gives access
to your Debian mirror. Also add the IP-address of the
HTTP server to the variable <code>$NFSROOT_ETC_HOSTS</code> in
<em>nfsroot.conf</em> if the install clients have no DNS resolving.</p></div>
</div>
<div class="sect2">
<h3 id="_small_hints">Small hints</h3>
<div class="ulist"><ul>
<li>
<p>
When using HTTP access to a Debian mirror, the local <em>/var</em> partition
on all install clients must be big enough to keep the downloaded
Debian packages. Do not try with less than 250 Mbytes unless you know
why. You can limit the number of packages installed at a time with the
variable <code>$MAXPACKAGES</code>.
</p>
</li>
<li>
<p>
You can remove the red logo on the install client by simply calling
<code>reset</code> once. If will also not appear if you create a file using this
command on the install server:
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content">
<pre><code>touch /srv/fai/nfsroot/.nocolorlogo</code></pre>
</div></div>
<div class="ulist"><ul>
<li>
<p>
A list of variables used by FAI can be found at
<a href="https://wiki.fai-project.org/index.php/Variables">https://wiki.fai-project.org/index.php/Variables</a>.
</p>
</li>
<li>
<p>
You can shorten some customization scripts by using one single fcopy
command <em>fcopy -r /</em>.
</p>
</li>
<li>
<p>
If you rebuild the nfsroot, you will create a new ssh host key inside
the nfsroot. Then logging in to an install client may fail, because
the host key changes. You can use this:
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content">
<pre><code>$ ssh -o StrictHostKeyChecking=no root@installclient</code></pre>
</div></div>
<div class="ulist"><ul>
<li>
<p>
You can also delete the host entry on your install client in your
<em>~/.ssh/known_hosts</em> file by using the <em>ssh-keygen -R</em> command.
</p>
</li>
<li>
<p>
In the tasks chboot and savelog, a connection using secure shell is
opened to the FAI server (see <a href="#isavelog">[isavelog]</a>). To ensure that this works
non-interactively, a proper entry in <em>NFSROOT/root/.ssh/known_hosts</em>
must be created. When using fai-setup, this is done automatically, but
it may require manual editing in case the name of your FAI server was
not determined correctly.  If you stumble over ssh connections that
require typing "yes" to accept the host key during installation,
please check the contents of your <em>NFSROOT/root/.ssh/known_hosts file</em>
</p>
</li>
<li>
<p>
A list of all local hard disks is
stored in <code>$disklist</code>. It&#8217;s defined after <code>set_disk_info</code> is called.
</p>
</li>
<li>
<p>
There are multiple functions for generating a customized disk
list. See <code>fai-disk-info</code> for an example.
</p>
<div class="ulist"><ul>
<li>
<p>
set_bootstick()
</p>
</li>
<li>
<p>
grepv_disks()
</p>
</li>
<li>
<p>
grep_disks()
</p>
</li>
<li>
<p>
notmatchdisks()
</p>
</li>
<li>
<p>
matchdisks()
</p>
</li>
<li>
<p>
smallestdisk()
</p>
</li>
<li>
<p>
largestdisk()
</p>
</li>
<li>
<p>
all_disks_by_size()
</p>
</li>
<li>
<p>
all_disks_and_size()
</p>
</li>
<li>
<p>
once_only()
</p>
</li>
<li>
<p>
checkdisk()
</p>
</li>
<li>
<p>
disks_by_id()
</p>
</li>
</ul></div>
</li>
<li>
<p>
Use <code>fai-divert -a</code> if a postinst script calls a configuration
program, e.g. the postinst script for package apache calls
apacheconfig, which needs manual input. You can fake the configuration
program so the installation can be fully automatic.
</p>
</li>
<li>
<p>
Sometimes the installation seems to stop, but often there&#8217;s only a
postinstall script of a software package that requires manual input
from the console. Change to another virtual terminal and look which
process is running with tools like <code>top(1)</code> and <code>pstree(1)</code>. You can
add <em>debug</em> to <em>FAI_FLAGS</em> to make the installation process show all
output from the postinst scripts on the console and get its input also
from the console.
</p>
</li>
<li>
<p>
How can I define classes on the kernel command line?
</p>
<div class="paragraph"><p>Read the man page of <code>fai-class(8)</code>. If you like to define some
additional classes (for e.g. A,B,C) on the kernel command line add this: <em>ADDCLASSES=A,B,C</em></p></div>
</li>
<li>
<p>
How to use a custom kernel inside the nfsroot?
</p>
<div class="paragraph"><p>Build your customized kernel by building a kernel package using
<code>make-kpkg(8)</code> and use the option <code>--initrd</code>. Copy this Debian package
to a local repository and add it to /etc/fai/sources.list. Add the
name of your package to /etc/fai/NFSROOT. Then call</p></div>
<div class="listingblock">
<div class="content">
<pre><code># fai-make-nfsroot -k</code></pre>
</div></div>
</li>
<li>
<p>
How to use the nfsroot as system for diskless clients?
</p>
<div class="paragraph"><p><a href="https://wiki.fai-project.org/index.php/Use_nfsroot_for_diskless_clients">https://wiki.fai-project.org/index.php/Use_nfsroot_for_diskless_clients</a></p></div>
</li>
<li>
<p>
How to serve multiple nfsroot directories on one FAI server?
</p>
<div class="paragraph"><p>If you want to serve multiple nfsroot directories,
you need to create specific config directories in <em>/etc</em> for FAI, like
<em>/etc/fai-buster</em> and <em>/etc/fai-bookworm</em>. Then you need to set the
<code>$NFSROOT</code> variables to different directories and run</p></div>
</li>
</ul></div>
<div class="listingblock">
<div class="content">
<pre><code>faiserver#fai-make-nfsroot -C /etc/fai-buster</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_flag_reboot_fai_flags">flag_reboot (FAI_FLAGS)</h3>
<div class="paragraph"><p>If flag_reboot is set, by adding "reboot" to <code>$FAI_FLAGS</code>, your client
machine will reboot after the task faiend has finished. This is true
for network as well as bootmedium installations.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_logfiles_a_log_files"><a id="logfiles"></a>Log files</h3>
<div class="paragraph"><p>FAI is creating several log files. During installation they are stored
in <em>/tmp/fai</em> on the install client itself. At the end of the
installation they will be copied to the install server (see
<a href="#isavelog">[isavelog]</a>). After the install client rebooted into his newly
installed system, you can find the FAI logs in <em>/var/log/fai</em>.
Log files are also created when doing the softupdate or dirinstall
action.</p></div>
<div class="paragraph"><p>On the faiserver, you can find the (remote) log files under the ~fai
directory.</p></div>
<div class="paragraph"><p>Sample log files from successfully installed computers are
available on <a href="https://fai-project.org/logs">https://fai-project.org/logs</a>.
These a some log files which are created by FAI.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
FAI_CLASSES
</dt>
<dd>
<p>
Contains a list of all classes defined.
</p>
</dd>
<dt class="hdlist1">
dmesg.log
</dt>
<dd>
<p>
Output of the <code>dmesg</code> command. Contains useful messages of the kernel
ring buffer.
</p>
</dd>
<dt class="hdlist1">
fai.log
</dt>
<dd>
<p>
The main log file. Contains all important information. You should
<strong>always</strong> read this file.
</p>
</dd>
<dt class="hdlist1">
boot.log
</dt>
<dd>
<p>
A list of variables of network parameters, mostly defined by the DHCP daemon.
</p>
</dd>
<dt class="hdlist1">
format.log
</dt>
<dd>
<p>
Output of the partition tool <code>setup-storage(8)</code>.
</p>
</dd>
<dt class="hdlist1">
scripts.log
</dt>
<dd>
<p>
Output of all scripts, that are used for customization.
</p>
</dd>
<dt class="hdlist1">
variables.log
</dt>
<dd>
<p>
A list of all shell variables which are available during an
installation.
</p>
</dd>
<dt class="hdlist1">
error.log
</dt>
<dd>
<p>
A summary of possible errors in all log files.
</p>
</dd>
<dt class="hdlist1">
disk_var.sh
</dt>
<dd>
<p>
A list of variables that contain information about devices and
partitions to boot from, the root partition and a list of swap
devices. These information is used by some customization scripts
(e.g. <em>GRUB_PC/10-setup</em>).
</p>
</dd>
</dl></div>
<div class="paragraph"><p>If the installation process finishes, the hook <em>savelog.LAST.sh</em>
searches all log files for common errors and writes them to the file
<em>error.log</em>. So, you should first look into this file for errors. Also
the file <em>status.log</em> give you the exit code of the last command
executed in a script. To be sure, you should look for more details in
all log files.</p></div>
</div>
<div class="sect2">
<h3 id="_how_to_use_http_for_pxe_boot">How to use HTTP for PXE boot</h3>
<div class="paragraph"><p>fai-make-nfsroot now uses the lpxelinux.0 binary which already
supports transfer of the kernel and initrd via http (additional to tftp).
You only have to enable HTTP access to the tftp directory:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>cd /var/www/html
ln -s /srv/tftp/fai</code></pre>
</div></div>
<div class="paragraph"><p>Add <em>-U URL</em> to the <em>fai-chboot</em> call. For example:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>fai-chboot -U http://faiserver/fai -IFv .......</code></pre>
</div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_id_troubleshoot_a_troubleshooting"><a id="troubleshoot"></a>Troubleshooting</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_a_id_booterror_a_boot_errors"><a id="booterror"></a>Boot errors</h3>
<div class="paragraph"><p>The following error message indicates that your install client doesn&#8217;t
get an answer from a DHCP server. Check your cables or start the
<code>dhcpd(8)</code> daemon with the debug flag enabled.</p></div>
<div class="quoteblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre><code>PXE-E51: No DHCP or BOOTP offers received
Network boot aborted</code></pre>
</div></div>
</div>
<div class="attribution">
</div></div>
<div class="paragraph"><p>If you do not see the following message, the install kernel could not
detect your network card, for example because of a missing driver:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Starting dhcp for interface eth0
dhcp: PREINIT eth0 up
dhcp: BOND setting eth</code></pre>
</div></div>
<div class="paragraph"><p>Check the initrd in the nfsroot (<code>lsinird</code>) if the kernel driver of your network
card is included there and check if you like to add the package
<em>firmware-linux-nonfree</em> in <code>/etc/fai/NFSROOT</code> and rebuild the initrd
by calling <code>fai-make-nfsroot -k</code>.
You may also add a driver to <code>/srv/fai/nfsroot/etc/dracut.conf</code> in
the line <code>add_drivers</code>+<code>=</code>.</p></div>
<div class="paragraph"><p>This is the error message you will see, when your network card is
working, but the install server does not export the nfsroot
directory to the install clients, This is often caused by missing
NFS permissions on the server side.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Starting dhcp for interface eth0
dhcp: PREINIT eth0 up
dhcp: BOND setting eth
mount.nfs: access denied by server while mounting 192.168.33.250:/srv/fai/nfsroot
.
.
dracut Warning: Could not boot
.
Dropping to debug shell
dracut:/#</code></pre>
</div></div>
<div class="paragraph"><p>Now, you are inside the emergency shell of the initrd which was created
by <em>dracut(8)</em>. You will get a shell prompt, and can look at the log files.
For more information about debugging the early boot process using
dracut see <code>dracut.cmdline(7)</code></p></div>
<div class="paragraph"><p>Use the following command on the install server to see which directories are exported
from the install server (named faiserver):</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ showmount -e faiserver</code></pre>
</div></div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Version 6.4<br />
Last updated
 2025-10-23 20:00:00 CEST
</div>
</div>
</body>
</html>
