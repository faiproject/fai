<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 10.2.1" />
<title>FAI Guide (Fully Automatic Installation)</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

pre {
  padding: 0;
  margin: 0;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #777777;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }


/*
 * xhtml11 specific
 *
 * */

tt {
  font-family: monospace;
  font-size: inherit;
  color: navy;
}

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overridden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

.monospaced {
  font-family: monospace;
  font-size: inherit;
  color: navy;
}

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}


/*
 * Theme specific overrides of the preceding (asciidoc.css) CSS.
 *
 */
body {
  font-family: Garamond, Georgia, serif;
  font-size: 17px;
  color: #3E4349;
  line-height: 1.3em;
}
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Garmond, Georgia, serif;
  font-weight: normal;
  border-bottom-width: 0;
  color: #3E4349;
}
div.title, caption.title { color: #596673; font-weight: bold; }
h1 { font-size: 240%; }
h2 { font-size: 180%; }
h3 { font-size: 150%; }
h4 { font-size: 130%; }
h5 { font-size: 115%; }
h6 { font-size: 100%; }
#header h1 { margin-top: 0; }
#toc {
  color: #444444;
  line-height: 1.5;
  padding-top: 1.5em;
}
#toctitle {
  font-size: 20px;
}
#toc a {
    border-bottom: 1px dotted #999999;
    color: #444444 !important;
    text-decoration: none !important;
}
#toc a:hover {
    border-bottom: 1px solid #6D4100;
    color: #6D4100 !important;
    text-decoration: none !important;
}
div.toclevel1 { margin-top: 0.2em; font-size: 16px; }
div.toclevel2 { margin-top: 0.15em; font-size: 14px; }
em, dt, td.hdlist1 { color: black; }
strong { color: #3E4349; }
a { color: #004B6B; text-decoration: none; border-bottom: 1px dotted #004B6B; }
a:visited { color: #615FA0; border-bottom: 1px dotted #615FA0; }
a:hover { color: #6D4100; border-bottom: 1px solid #6D4100; }
div.tableblock > table, table.tableblock { border: 3px solid #E8E8E8; }
th.tableblock, td.tableblock { border: 1px solid #E8E8E8; }
ul > li > * { color: #3E4349; }
pre, tt, .monospaced { font-family: Consolas,Menlo,'Deja Vu Sans Mono','Bitstream Vera Sans Mono',monospace; }
tt, .monospaced { font-size: 0.9em; color: black;
}
div.exampleblock > div.content, div.sidebarblock > div.content, div.listingblock > div.content { border-width: 0 0 0 3px; border-color: #E8E8E8; }
div.verseblock { border-left-width: 0; margin-left: 3em; }
div.quoteblock { border-left-width: 3px; margin-left: 0; margin-right: 0;}
div.admonitionblock td.content { border-left: 3px solid #E8E8E8; }


@media screen {
  body {
    max-width: 50em; /* approximately 80 characters wide */
    margin-left: 16em;
  }

  #toc {
    position: fixed;
    top: 0;
    left: 0;
    bottom: 0;
    width: 13em;
    padding: 0.5em;
    padding-bottom: 1.5em;
    margin: 0;
    overflow: auto;
    border-right: 3px solid #f8f8f8;
    background-color: white;
  }

  #toc .toclevel1 {
    margin-top: 0.5em;
  }

  #toc .toclevel2 {
    margin-top: 0.25em;
    display: list-item;
    color: #aaaaaa;
  }

  #toctitle {
    margin-top: 0.5em;
  }
}
</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install(3);
/*]]>*/
</script>
</head>
<body class="article">
<div id="header">
<h1>FAI Guide (Fully Automatic Installation)</h1>
<span id="author">Thomas Lange</span><br />
<span id="email"><code>&lt;<a href="mailto:lange@debian.org">lange@debian.org</a>&gt;</code></span><br />
<span id="revnumber">version 6.4,</span>
<span id="revdate">10 Apr 2025</span>
<div id="toc">
  <div id="toctitle">Table of Contents</div>
  <noscript><p><b>JavaScript must be enabled in your browser to display the table of contents.</b></p></noscript>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph"><p>An older French version of this guide is available at <a href="https://fai-project.org/fai-guide-fr">https://fai-project.org/fai-guide-fr</a>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_abstract">Abstract</h2>
<div class="sectionbody">
<div class="paragraph"><p>FAI is a non-interactive system to install, customize and manage Linux
systems and software configurations on computers as well as virtual
machines and chroot environments, from small networks to large
infrastructures and clusters.</p></div>
<div class="paragraph"><p>This manual describes the Fully Automatic Installation software. This
includes the installation of the packages, setting up the server, creating of the
configuration and how to deal with errors.</p></div>
<div class="paragraph"><p>(c) 2000-2025 Thomas Lange</p></div>
<div class="paragraph"><div class="title">Copyright</div><p>This manual is free software; you may redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.</p></div>
<div class="paragraph"><p>This is distributed in the hope that it will be useful, but <strong>without
any warranty</strong>; without even the implied warranty of merchantability or
fitness for a particular purpose. See the GNU General Public License
for more details.</p></div>
<div class="paragraph"><p>A copy of the GNU General Public License is available as
<em>/usr/share/common-licenses/GPL</em> in the Debian GNU/Linux distribution
or on the World Wide Web at <a href="https://www.gnu.org/copyleft/gpl.html">the
GNU website</a> You can also obtain it by writing to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.</p></div>
<div style="page-break-after:always"></div>
</div>
</div>
<div class="sect1">
<h2 id="_a_id_introduction_a_introduction"><a id="introduction"></a>Introduction</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_a_id_availability_a_availability"><a id="availability"></a>Availability</h3>
<div class="dlist"><dl>
<dt class="hdlist1">
Homepage
</dt>
<dd>
<p>
<a href="https://fai-project.org">https://fai-project.org</a>
</p>
</dd>
<dt class="hdlist1">
FAI wiki
</dt>
<dd>
<p>
<a href="https://wiki.fai-project.org">https://wiki.fai-project.org</a>
</p>
</dd>
<dt class="hdlist1">
Download
</dt>
<dd>
<p>
<a href="https://fai-project.org/download">https://fai-project.org/download</a>
</p>
</dd>
<dt class="hdlist1">
Entry for <em>sources.list</em>
</dt>
<dd>
<p>
<code>deb https://fai-project.org/download bookworm koeln</code>
</p>
</dd>
<dt class="hdlist1">
Manual pages
</dt>
<dd>
<p>
<a href="https://fai-project.org/doc/man/">https://fai-project.org/doc/man/</a>
</p>
</dd>
<dt class="hdlist1">
Mailing list
</dt>
<dd>
<p>
<a href="https://lists.uni-koeln.de/mailman/listinfo/linux-fai">https://lists.uni-koeln.de/mailman/listinfo/linux-fai</a>
</p>
</dd>
<dt class="hdlist1">
Feedback
</dt>
<dd>
<p>
Send feedback and comments to <a href="mailto:fai@fai-project.org">fai@fai-project.org</a> or
to the mailing list.
</p>
</dd>
<dt class="hdlist1">
Bugs
</dt>
<dd>
<p>
Use the Debian bug tracking system (BTS) <a href="https://bugs.debian.org/src:fai">https://bugs.debian.org/src:fai</a>
</p>
</dd>
<dt class="hdlist1">
User visible changes
</dt>
<dd>
<p>
<a href="https://fai-project.org/NEWS">https://fai-project.org/NEWS</a>
</p>
</dd>
<dt class="hdlist1">
Source tree via git
</dt>
<dd>
<p>
git clone git://github.com/faiproject/fai.git
</p>
</dd>
<dt class="hdlist1">
View source tree via https
</dt>
<dd>
<p>
<a href="https://github.com/faiproject/fai">https://github.com/faiproject/fai</a>
</p>
</dd>
</dl></div>
<div class="paragraph"><p>The man pages always include up-to-date information and a lot of
details of all FAI commands. So, don&#8217;t forget to read them carefully.
Now read this manual, then enjoy the fully automatic installation and
your saved time.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_motivation_a_motivation"><a id="motivation"></a>Motivation</h3>
<div class="paragraph"><p>Have you ever performed identical installations of an operating system
several times? Would you like to be able to install a Linux cluster
with dozens of nodes single handedly?</p></div>
<div class="paragraph"><p>Repeating the same task again and again is boring&#8201;&#8212;&#8201;and will surely
lead to errors. Also a whole lot of time could be saved if the
installations were done automatically. An installation process with
manual interaction does not scale. But clusters have the habit of
growing over the years. Think long-term rather than planning just a
few months into the future.</p></div>
<div class="paragraph"><p>In 1999, I had to perform an installation of a Linux cluster with one
server and 16 clients. Since I had much experience doing automatic
installations of Solaris operating systems on SUN SPARC hardware, the
idea to build an automatic installation for Debian was born. Solaris
has an automatic installation feature called JumpStart
<span class="footnote"><br />[Solaris 8 Advanced Installation Guide at
<a href="https://docs.oracle.com/cd/E19455-01/806-0957/806-0957.pdf">https://docs.oracle.com/cd/E19455-01/806-0957/806-0957.pdf</a>
]<br /></span>. In conjunction with the auto-install scripts
from Casper Dik
<span class="footnote"><br />[<a href="http://www.science.uva.nl/pub/solaris/auto-install">http://www.science.uva.nl/pub/solaris/auto-install</a>]<br /></span>, I could
save a lot of time not only for every new SUN computer, but also for
re-installation of existing workstations. For example, I had to build
a temporary LAN with four SUN workstations for a conference, which
lasted only a few days. I took these workstations out of our normal
research network and set up a new installation for the conference.
When it was over, I simply integrated the workstations back into the
research network, rebooted just once, and after half an hour,
everything was up and running as before. The configuration of all
workstations was exactly the same as before the conference, because
everything was performed by the same installation process. I also used
the automatic installation for reinstalling a workstation after a
damaged hard disk had been replaced. It took two weeks until I
received the new hard disk but only a few minutes after the new disk
was installed, the workstation was running as before. And this is why
I choose to adapt this technique to a PC cluster running Linux.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_work_a_how_does_fai_work"><a id="work"></a>How does FAI work</h3>
<div class="paragraph"><p>The install client which will be installed using FAI, is booted via
network card or from CD or USB stick. It gets an IP address and boots
a Linux kernel which mounts its root file system via NFS (the nfsroot)
from the
install server. After the kernel is started, the FAI startup script
performs the automatic installation which doesn&#8217;t need any
interaction. First, the hard disks will be partitioned, file systems
are created and then software packages are installed. After that, the
new installed operating system is configured to your local needs using
some scripts. Finally, the new operating system will be booted from the
local disk.</p></div>
<div class="paragraph"><p>The details of how to install the computer (the configuration) are
stored in the configuration space on the install server. Configuration
files are shared among groups of computers if they are similar using
the class concept. So you need not create a configuration for every
new host. Hence, FAI is a scalable method to install a big cluster
with a great number of nodes even if their configuration is not identical.</p></div>
<div class="paragraph"><p>FAI can also be used as a rescue system or for hardware inventory. You can boot your
computer, but it will not perform an installation. Instead it will run
a fully functional Debian GNU/Linux without using the local hard
disks. Then you
can do a remote login and backup or restore a disk partition, check a
file system, inspect the hardware or do any other task.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_features_a_features"><a id="features"></a>Features</h3>
<div class="ulist"><ul>
<li>
<p>
A fully automated installation can be performed.
</p>
</li>
<li>
<p>
Very quick unattended installation.
</p>
</li>
<li>
<p>
Flexible system through easy class concept.
</p>
</li>
<li>
<p>
Update of running systems without re-installation.
</p>
</li>
<li>
<p>
Cloud images for virtualization environment.
</p>
</li>
<li>
<p>
Hosts can boot from network card, CD, USB stick.
</p>
</li>
<li>
<p>
Simple creation of an installation or live ISO.
</p>
</li>
<li>
<p>
PXE with DHCP boot method is supported.
</p>
</li>
<li>
<p>
ReiserFS, ext3/ext4, btrfs and XFS file system support.
</p>
</li>
<li>
<p>
Software RAID and LVM support. LUKS support.
</p>
</li>
<li>
<p>
Automatic hardware detection.
</p>
</li>
<li>
<p>
You can deploy Debian, Ubuntu, Rocky Linux, CentOS, AlmaLinux, SuSE
</p>
</li>
<li>
<p>
Remote login via ssh during installation process possible.
</p>
</li>
<li>
<p>
All similar configurations are shared among all install clients.
</p>
</li>
<li>
<p>
Log files for all installations are saved to the installation server.
</p>
</li>
<li>
<p>
Shell, Perl, Python, Ruby, expect and CFEngine scripts are supported during the customization step.
</p>
</li>
<li>
<p>
Support for many protocols like NFS, FTP, HTTPS, git.
</p>
</li>
<li>
<p>
Can be used as a rescue system and for hardware inventory.
</p>
</li>
<li>
<p>
Diskless client support.
</p>
</li>
<li>
<p>
Cross-architecture support e.g. for embedded devices.
</p>
</li>
<li>
<p>
Easily add your own functions via hooks or change the default behavior.
</p>
</li>
<li>
<p>
Cloning machines using disk images is supported.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_installation_times">Installation times</h3>
<div class="paragraph"><p>The installation time is determined by the amount of software and
the speed of the hard disk. Here are some sample
times. All install clients had a 1Gbit network card installed.</p></div>
<div class="tableblock">
<table rules="all"
width="80%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="26%" />
<col width="13%" />
<col width="20%" />
<col width="26%" />
<col width="13%" />
<thead>
<tr>
<th align="left" valign="top"> CPU  </th>
<th align="center" valign="top">  RAM </th>
<th align="left" valign="top">   Disk    </th>
<th align="right" valign="top">   Software installed  </th>
<th align="right" valign="top"> time</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">i7-3770T 2.50GHz</p></td>
<td align="center" valign="top"><p class="table">8GB</p></td>
<td align="left" valign="top"><p class="table">SSD</p></td>
<td align="right" valign="top"><p class="table">6 GB software</p></td>
<td align="right" valign="top"><p class="table">8.5 min</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Core-i7 3.2GHz</p></td>
<td align="center" valign="top"><p class="table">6GB</p></td>
<td align="left" valign="top"><p class="table">SATA disk</p></td>
<td align="right" valign="top"><p class="table">4.3GB software</p></td>
<td align="right" valign="top"><p class="table">7 min</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Core-i7 3.2GHz</p></td>
<td align="center" valign="top"><p class="table">6GB</p></td>
<td align="left" valign="top"><p class="table">SATA disk</p></td>
<td align="right" valign="top"><p class="table">471 MB software</p></td>
<td align="right" valign="top"><p class="table">77sec</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Intel Core2 Duo</p></td>
<td align="center" valign="top"><p class="table">2GB</p></td>
<td align="left" valign="top"><p class="table">SATA disk</p></td>
<td align="right" valign="top"><p class="table">3 GB software</p></td>
<td align="right" valign="top"><p class="table">14 min</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_id_impatient_a_quickstart_for_the_impatient_user"><a id="impatient"></a>Quickstart - For the impatient user</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_a_id_first_a_my_first_installation"><a id="first"></a>My first installation</h3>
<div class="paragraph"><p>Without further ado, this section will provide a quick and easy demonstration of a fully automatic installation using the FAI CD and a virtual machine.</p></div>
<div class="paragraph"><p>Just download the CD ISO image from <a href="https://fai-project.org/fai-cd">https://fai-project.org/fai-cd</a> and boot
your VM using this CD. You will see a grub menu where you can select
from different installation types.</p></div>
<div class="paragraph"><p>This installation will run without an install server. The CD
installation is the same as when run in a network environment using
the FAI install server and can also be used from USB stick on a real
computer.</p></div>
<div class="paragraph"><p>You can also create yourself a custom fully automated installation
image on the webpage <a href="https://fai-project.org/FAIme">https://fai-project.org/FAIme</a> without the need of
installing FAI on your computer.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_cdserver_a_my_first_server_installation"><a id="cdserver"></a>My first server installation</h3>
<div class="paragraph"><p>We will create a private network and start two virtual machines. One
will become your own FAI server, the other will be an install client.</p></div>
<div class="paragraph"><p>If you intend to use VMware or VirtualBox, ensure that your client
uses a bridged network connection. A detailed description is in the
FAI wiki
<span class="footnote"><br />[<a href="https://wiki.fai-project.org/index.php/VirtualBox_for_your_first_FAI_installation">https://wiki.fai-project.org/index.php/VirtualBox_for_your_first_FAI_installation</a>]<br /></span>. Also,
it is not possible to use
bridged network interfaces over wireless, as most WiFi network cards
do not support this feature.</p></div>
<div class="paragraph"><p>When using Qemu/KVM and the <code>fai-kvm</code> wrapper you can create the
network using the command <code>fai-mk-network</code>. First install some packages</p></div>
<div class="listingblock">
<div class="content">
<pre><code># apt-get install qemu-system-gui qemu-kvm qemu-utils</code></pre>
</div></div>
<div class="paragraph"><p>The next command sets up a private network with a software bridge with several tap devices
that belong to the user <code>&lt;username&gt;</code>.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>fai-mk-network &lt;username&gt;</code></pre>
</div></div>
<div class="paragraph"><p>After that, you can use fai-kvm (-h will give you some help) for
starting virtual machines using KVM that are connected to this private
network. Be careful. By default, fai-kvm will create the disk images
for the virtual machines in <code>/tmp</code>, which is a RAM disk on most
systems. It&#8217;s no problem to create an empty 20G disk image in /tmp
(even if this partition is of 4GB size), but while the VM is writing
data to its disk, this will start to consume space in <code>/tmp</code>.</p></div>
<div class="paragraph"><p>Start the first virtual host, which will become the FAI server
<span class="footnote"><br />[This installation will consume about 2GB of space in
<code>/tmp</code>.]<br /></span>:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>fai-kvm -Vn -s20 -u 1 cd faicd64-small.iso</code></pre>
</div></div>
<div class="paragraph"><p>In the grub menu select <code>faiserver, using internal DHCP and a fixed IP</code>. This will install a host called
faiserver with IP 192.168.33.250 which contains all software needed
for a FAI server. It will also set up a local package cache (using
apt-cacher-ng). Once the installation is finished, reboot the
machine. During the first boot of the new system, it will
automatically set up the nfsroot. This may take some minutes.</p></div>
<div class="paragraph"><p>After that you can start additional hosts using network boot. For
every new host, you have to use a different value for <code>-u</code>, which will be used for
generating different MAC addresses and using different disk image file
names.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>fai-kvm -Vn -u 2 pxe</code></pre>
</div></div>
<div class="paragraph"><p>Those install clients will show you a menu, where you can select which
type of installation you like to perform. If the install client does
not find the server, it is usually because fai-monitor is no longer
running on it. This can happen, if you reboot the faiserver after the
installation. To remedy this, simply run fai-monitor on the faiserver
and re-attempt the client boot.</p></div>
<div class="paragraph"><p>Another client could be started with:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>fai-kvm -Vn -u 3 pxe</code></pre>
</div></div>
<div class="paragraph"><p>You can start as many machines in the network as tap devices are
available. All these machines can connect to the outside internet but are
only reachable from your host machine.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_id_overview_a_overview_and_concepts"><a id="overview"></a>Overview and Concepts</h2>
<div class="sectionbody">
<div class="paragraph"><p>FAI is a non-interactive system to install, customize and manage Linux
systems and software configurations on computers as well as virtual
machines and chroot environments, from small networks to large
infrastructures and clusters. You can take one or more virgin PCs,
turn on the power and after a few minutes Linux is installed,
configured and running on the whole cluster, without any interaction
necessary. Thus, it&#8217;s a scalable method for installing and updating a
cluster unattended with little effort involved. FAI uses the
Linux operating system and a collection of shell and Perl scripts for
the installation process. Changes to the configuration files of the
operating system can be made by CFEngine, shell (bash and zsh), Perl,
Python, Ruby and expect scripts.</p></div>
<div class="paragraph"><p>FAI&#8217;s target group are system administrators who have to install Linux
onto one or even hundreds of computers. Because it&#8217;s a general purpose
installation tool, it can be used for installing a Beowulf cluster, a
rendering farm or a Linux laboratory or a classroom. Also large-scale
Linux networks with different hardware or different installation
requirements are easy to establish using FAI. But don&#8217;t forget to plan
your installation. Chapter <a href="#plan">[plan]</a> has some useful hints for this
topic.</p></div>
<div class="sect2">
<h3 id="_a_id_terms_a_important_terms"><a id="terms"></a> Important Terms</h3>
<div class="paragraph"><p>First, some terms used in this manual are described.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
install server
</dt>
<dd>
<p>
It provides DHCP, TFTP and NFS services and the configuration data for
all install clients. In the examples of this manual this host is
called <em>faiserver</em>. The host where the package <em>fai-server</em> is installed.
</p>
</dd>
<dt class="hdlist1">
install client
</dt>
<dd>
<p>
A host which will be installed using FAI and a configuration provided
by the install server. Also called client for short. In this manual,
the example hosts are called <em>demohost, xfcehost, gnomehost &#8230;</em>
This computer should boot from its network interface using PXE.
</p>
</dd>
<dt class="hdlist1">
configuration space
</dt>
<dd>
<p>
A subdirectory structure containg several files. Those files describe
the details of how the installation of the clients will be
performed. All configuration data is stored here. It&#8217;s also called
config space for short. It includes information about:
</p>
<div class="ulist"><ul>
<li>
<p>
Hard disk layout in a format similar to fstab
</p>
</li>
<li>
<p>
Local file systems, their types, mount points and mount options
</p>
</li>
<li>
<p>
Software packages
</p>
</li>
<li>
<p>
Keyboard layout, time zone, Xorg configuration, remote file
  systems, user accounts, printers &#8230;
</p>
</li>
</ul></div>
<div class="paragraph"><p>The package <em>fai-doc</em> includes a sample configuration space including
examples for hosts using the XFCE and GNOME environment amongst other
examples. Calling <code>fai-mk-configspace</code> copies these examples to
<em>/srv/fai/config</em>. It&#8217;s recommended to study those config files and
scripts for easier understanding how FAI works.</p></div>
</dd>
<dt class="hdlist1">
nfsroot, NFS-Root
</dt>
<dd>
<p>
A file system located on the install server. During the installation
process it&#8217;s the complete file system for the install clients. All
clients share the same nfsroot, which they mount read only. The
nfsroot needs about 1.1GB of free disk space.
</p>
</dd>
<dt class="hdlist1">
TFTP
</dt>
<dd>
<p>
Serves clients the initrd and kernel that is used for the installation process.
Along with the file system served by NFS, these two make up a temporary
OS in which the installations are performed.
</p>
</dd>
<dt class="hdlist1">
FAI classes
</dt>
<dd>
<p>
Classes are names which determine which configuration file is
selected. If a client belongs to class WEBSERVER, it will be configured
as a webserver, the class DESKTOP for e.g. determines which software
packages will be installed.
</p>
</dd>
<dt class="hdlist1">
profile
</dt>
<dd>
<p>
A FAI profile is just a list of FAI classes assiged to a profile name,
which is extended by a description of this profile. I.e. one could have
two "Webserver" profiles, one including the APACHE class another including the NGINX class,
to then install the respective webserver solution.
</p>
</dd>
<dt class="hdlist1">
tasks
</dt>
<dd>
<p>
The installation of a client consists of several parts, which are called tasks.
Tasks are predefined subroutines which perform a certain part of the
FAI. The following FAI tasks are performed during an installation
on the install clients.
</p>
</dd>
</dl></div>
<div class="quoteblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre><code>confdir               # get the config space
setup                 # some initialization, start sshd on demand
defclass              # define FAI classes
defvar                # define variables
action                # evaluate FAI_ACTION
install               # Start the installation
partition             # partition the harddisks, create file systems
mountdisks            # mount the file systems
extrbase              # extract the base.tar.xz
debconf               # do the Debian debconf preseeding
repository            # prepare access to the package repository
updatebase            # Set up package tools and update packages
instsoft              # install software packages
configure             # call customization scripts
finish                # do some cleanup, show installation statistics
tests                 # call tests if defined
chboot                # call fai-chboot on the install server
savelog               # save log files to local and remote location
faiend                # reboot host, eject CD if needed</code></pre>
</div></div>
</div>
<div class="attribution">
</div></div>
<div class="quoteblock">
<div class="content">
<div class="paragraph"><p>These are tasks, which are only executed when a different action is performed</p></div>
<div class="literalblock">
<div class="content">
<pre><code>dirinstall           # install a chroot environment
softupdate           # only do the system configuration
sysinfo              # print detailed system information
inventory            # print short hardware inventory list</code></pre>
</div></div>
</div>
<div class="attribution">
</div></div>
<div class="paragraph"><p>For a more in-depth description of <em>tasks</em> , see <a href="#tasks">[tasks]</a>.</p></div>
<div class="paragraph"><p>Note that you are not limited to the FAI tasks. You can also define additional programs or scripts which will be run
on particular occasions. They are called <em>hooks</em>.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
hooks
</dt>
<dd>
<p>
Hooks are plugins, they can add additional functionality to the installation process
or even replace entire tasks of FAI. Hooks are explained in detail in
<a href="#hooks">[hooks]</a>.
</p>
</dd>
</dl></div>
</div>
<div class="sect2">
<h3 id="_a_id_classc_a_the_class_concept"><a id="classc"></a>The class concept</h3>
<div class="paragraph"><p>Classes are used in nearly all tasks of the installation. Classes
determine which configuration files to choose from a list of available
alternatives. To determine which config files to use, FAI searches the
list of defined classes and uses all configuration files that match a
class name <span class="footnote"><br />[It&#8217;s also possible to use only the configuration
file with the highest priority since the order of classes define a
priority from low to high within the list of classes.  ]<br /></span>. The following loop implements
this function in pseudo shell code:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>for class in $all_classes; do
   if [ -r $config_dir/$class ]; then      # if a file with name $class exists
      your_command $config_dir/$class      # call a command with this file name
      # exit if only the first matching file is needed
   fi
done</code></pre>
</div></div>
<div class="paragraph"><p>The very nice feature of this is that you can add a new configuration
alternative and it will automatically be used by FAI without changing
the code, if the configuration file uses a class name.</p></div>
<div class="paragraph"><p>This is because the loop automatically detects new configuration files
that should be used.
The idea of using classes in general and using certain files matching
a class name for a configuration is adopted from the installation
scripts by Casper Dik for Solaris. This technique proved to be very
useful and easy.</p></div>
<div class="paragraph"><p>You can group multiple hosts that share the same configuration
files by using the same class. You can also split the whole
configuration data for all clients into several classes and use them
like lego bricks and build the entire configuration for a single
client by assembling the bricks together.</p></div>
<div class="paragraph"><p>If a client belongs to class <em>A</em>, we say the class <em>A</em>
is defined for this client. A class has no value, it is just defined or
undefined.</p></div>
<div class="paragraph"><p>Classes determine how the installation is performed. For example, an install
client can be configured to get the XFCE desktop by just adding the
class <em>XFCE</em> to it. Naturally, also more granular configurations are possible. For instance, classes can describe how the hard disk should be partitioned, they can
define which software packages will be installed, or which
customization steps are performed.</p></div>
<div class="paragraph"><p>Often, a client configuration is created by only changing or appending the
classes to which this client belongs, making the installation of a new
client very easy. Thus no additional information needs to be added to
the configuration space if the existing classes suffice for your
needs.</p></div>
<div class="paragraph"><p>As you can see, classes are a central pillar of customizing your configuration space and with that your client installation. On how to define your own classes, refer to <a href="#defining classes">[defining classes]</a>.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_id_setup_a_setup_your_faiserver"><a id="setup"></a>Setup your faiserver</h2>
<div class="sectionbody">
<div class="paragraph"><p>Here&#8217;s how to set up the install server in a few minutes. Following
steps are needed:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Set up the install server
</p>
<div class="olist loweralpha"><ol class="loweralpha">
<li>
<p>
Install FAI packages
</p>
</li>
<li>
<p>
Create the nfsroot
</p>
</li>
<li>
<p>
Copy the examples to the config space
</p>
</li>
<li>
<p>
Configure network daemons
</p>
</li>
<li>
<p>
Create the PXELINUX configurations
</p>
</li>
</ol></div>
</li>
<li>
<p>
Boot and install clients
</p>
</li>
</ol></div>
<div class="sect2">
<h3 id="_install_the_fai_packages">Install the FAI packages</h3>
<div class="ulist"><ul>
<li>
<p>
Install the key of the FAI project package repository.
</p>
</li>
<li>
<p>
Add the URL of the package repository of the FAI project.
</p>
</li>
<li>
<p>
Install the package <em>fai-quickstart</em> on your install server.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Use these commands for installing:</p></div>
<div class="listingblock">
<div class="content">
<pre><code># wget -O /etc/apt/trusted.gpg.d/fai-project.gpg https://fai-project.org/download/2BF8D9FE074BCDE4.gpg
# echo "deb http://fai-project.org/download bookworm koeln" &gt; /etc/apt/sources.list.d/fai.list</code></pre>
</div></div>
<div class="paragraph"><p>or</p></div>
<div class="listingblock">
<div class="content">
<pre><code># apt install extrepo ; extrepo enable fai</code></pre>
</div></div>
<div class="paragraph"><p>and then</p></div>
<div class="listingblock">
<div class="content">
<pre><code># apt-get update
# aptitude install fai-quickstart</code></pre>
</div></div>
<div class="paragraph"><p>This will also install the packages for DHCP, TFTP and NFS server daemons.</p></div>
</div>
<div class="sect2">
<h3 id="_create_the_nfsroot">Create the nfsroot</h3>
<div class="ulist"><ul>
<li>
<p>
Also enable the package repository of the FAI project in a different
  <em>sources.list</em> file which is used when building the nfsroot. Then,
  enable the log user for FAI.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content">
<pre><code># sed -i -e 's/^#deb/deb/' /etc/fai/apt/sources.list
# sed -i -e 's/#LOGUSER/LOGUSER/' /etc/fai/fai.conf</code></pre>
</div></div>
<div class="ulist"><ul>
<li>
<p>
By default, FAI uses <a href="http://deb.debian.org">http://deb.debian.org</a> as package
  mirror, which should attempt to find a fast package repository for you. <span class="footnote"><br />[If you want to use a faster mirror, adjust the URL
  in <em>/etc/fai/apt/sources.list</em> and <code>FAI_DEBOOTSTRAP</code> in <em>/etc/fai/nfsroot.conf</em> before calling fai-setup.]<br /></span>
Now, we can run <code>fai-setup(8)</code> <span class="footnote"><br />[This will call <code>fai-make-nfsroot(8)</code> internally.]<br /></span>
and check if everything went well.
The log file is written to /var/log/fai/fai-setup.log.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content">
<pre><code># fai-setup -v</code></pre>
</div></div>
<div class="ulist"><ul>
<li>
<p>
These are some of the lines you will see at the end of
  <em>fai-setup</em>. A complete example of <em>fai-setup.log</em> is available on
  the FAI web page at <a href="https://fai-project.org/logs/fai-setup.log">https://fai-project.org/logs/fai-setup.log</a>.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content">
<pre><code>FAI packages and related packages inside the nfsroot:
dracut             059-4
dracut-live        059-4
dracut-network     059-4
dracut-squash      059-4
fai-client         6.2
fai-nfsroot        6.2
fai-setup-storage  6.2
Waiting for background jobs to finish
fai-make-nfsroot finished properly.
Log file written to /var/log/fai/fai-make-nfsroot.log
Adding line to /etc/exports: /srv/fai/config 192.168.33.250/24(async,ro,no_subtree_check)
Adding line to /etc/exports: /srv/fai/nfsroot 192.168.33.250/24(async,ro,no_subtree_check,no_root_squash)
Reloading nfs-kernel-server configuration (via systemctl): nfs-kernel-server.service.

Your initial config space is now located in /srv/fai/config
Please don't forget to fill out the FAI questionnaire after you've finished your project with FAI.

FAI setup finished.
Log file written to /var/log/fai/fai-setup.log</code></pre>
</div></div>
<div class="ulist"><ul>
<li>
<p>
fai-setup has created the LOGUSER, the nfsroot and has added
  additional lines to <em>/etc/exports</em>. The subdirectories added to
  <em>/etc/exports</em> are exported via NFS v3, so all install clients in the
  same subnet can mount them via NFS.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_creating_the_configuration_space">Creating the configuration space</h3>
<div class="paragraph"><p>Install the simple examples into the configuration space
<span class="footnote"><br />[These files need not belong to the root account.]<br /></span>.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ fai-mk-configspace</code></pre>
</div></div>
<div class="paragraph"><p>These examples contain configuration for some sample
hosts. Depending on the host name used, your computer will be
configured as follows:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
demohost
</dt>
<dd>
<p>
A machine which needs only a small hard disk. This machine is
configured with network as DHCP client, and an account demo is
created.
</p>
</dd>
<dt class="hdlist1">
xfcehost
</dt>
<dd>
<p>
A XFCE desktop is installed, using LVM, and the account demo is created.
</p>
</dd>
<dt class="hdlist1">
gnomehost
</dt>
<dd>
<p>
A GNOME desktop is installed, and the account demo is created.
</p>
</dd>
<dt class="hdlist1">
ubuntuhost
</dt>
<dd>
<p>
A Ubuntu desktop will be installed, and the account demo is created.
</p>
</dd>
<dt class="hdlist1">
other host names
</dt>
<dd>
<p>
Hosts with another host name will most notably use the classes FAIBASE,
DHCPC and GRUB.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>All hosts will have an account called <em>demo</em> with password <em>fai</em>. The
root account also has the password <em>fai</em>.</p></div>
<div class="paragraph"><p>If the FAI flag <code>menu</code> is added, instead of using the host name for
determing the type of installation, a menu is presented, and the user
can choose a profile for the installation.</p></div>
</div>
<div class="sect2">
<h3 id="_configure_the_network_daemons">Configure the network daemons</h3>
<div class="paragraph"><p>For booting the install client via PXE, the install server needs a DHCP and a
TFTP daemon running. The package <em>fai-quickstart</em> has already installed the
software packages for those daemons. Additionally the package of the NFS
server for exporting the nfsroot and the config space was installed.</p></div>
<div class="sect3">
<h4 id="_a_id_bootdhcp_a_configuration_of_the_dhcp_daemon"><a id="bootdhcp"></a>Configuration of the DHCP daemon</h4>
<div class="paragraph"><p>Ideally, your faiserver should also be your DHCP server. If that is
not the case, instruct the admin responsible of the DHCP server to
configure it according to this section. Optionally, it is possible to
avoid that by using the <a href="#autodiscover">[autodiscover]</a> feature released in FAI 5.0.</p></div>
<div class="paragraph"><p>An example for <code>dhcpd.conf(5)</code> is provided with the <em>fai-doc</em>
package. Start using this example and look at all options used therein.</p></div>
<div class="listingblock">
<div class="content">
<pre><code># cp /usr/share/doc/fai-doc/examples/etc/dhcpd.conf /etc/dhcp/</code></pre>
</div></div>
<div class="paragraph"><p>The only FAI specific information inside this configuration file is to
set <code>filename</code> (DHCP option 67) to <code>fai/pxelinux.0</code> and to set
<code>next-server</code> (DHCP option 66, also called TFTP server name) and
<code>server-name</code> to the name of your install server. All other
information is only network related data, which is used in almost all
DHCP configurations.  Adjust these network parameters to your local
needs.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>deny unknown-clients;
option dhcp-max-message-size 2048;
use-host-decl-names on;

subnet 192.168.33.0 netmask 255.255.255.0 {
   option routers 192.168.33.250;
   option domain-name "my.example";
   option domain-name-servers 192.168.33.250;
   option time-servers faiserver;
   option ntp-servers faiserver;
   server-name faiserver;
   next-server faiserver;
   filename "fai/pxelinux.0";
}</code></pre>
</div></div>
<div class="paragraph"><p>If you make any changes to the DHCP configuration, you must
restart the daemon.</p></div>
<div class="listingblock">
<div class="content">
<pre><code># invoke-rc.d isc-dhcp-server restart</code></pre>
</div></div>
<div class="paragraph"><p>If you have multiple network interfaces, you
can define on which interface the server will listen in
<em>/etc/default/isc-dhcp-server</em>. By default, the DHCP daemon writes its
log messages to <em>/var/log/daemon.log</em>.</p></div>
</div>
<div class="sect3">
<h4 id="_adding_a_host_entry_to_dhcp">Adding a host entry to DHCP</h4>
<div class="paragraph"><p>The MAC address is given by the hardware of the network card. For each
install client you collect its MAC address and to map it to an IP address and to a host
name. First, we add the IP address and the hostname to <em>/etc/hosts</em>
<span class="footnote"><br />[You may also add this into your Domain Name System (DNS)]<br /></span>.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>192.168.33.100    demohost</code></pre>
</div></div>
<div class="paragraph"><p>The mapping from the MAC address to the IP address is done in the
<em>dhcpd.conf</em> file. Here, we add a host entry using the command <code>dhcp-edit(8)</code>.
Here you have to replace 01:02:03:AB:CD:EF ith the MAC you have found.</p></div>
<div class="listingblock">
<div class="content">
<pre><code># dhcp-edit demohost 01:02:03:AB:CD:EF</code></pre>
</div></div>
<div class="paragraph"><p>After calling this command, this is what the host entry in
<em>dhcpd.conf</em> will look like:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>host demohost {hardware ethernet 01:02:03:AB:CD:EF;fixed-address demohost;}</code></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_tftp">TFTP</h4>
<div class="paragraph"><p>Normally, you do not need any changes to the TFTP dameon
configuration. The files which are provided by TFTP are located in
<em>/srv/tftp/fai</em>.</p></div>
</div>
<div class="sect3">
<h4 id="_nfs">NFS</h4>
<div class="paragraph"><p>The command <code>fai-setup</code> has already set up the NFS daemon and added
some lines to the configuration file <em>/etc/exports</em>.
It exports the directories using NFS v3.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_creating_the_pxelinux_configuration">Creating the PXELINUX configuration</h3>
<div class="paragraph"><p>The last step before booting your client for the first time
is to specify what configuration the client should boot when doing PXE
boot. We use the command <code>fai-chboot(8)</code> to create a pxelinux
configuration for each install client. This includes information about
the kernel, the initrd, the config space and some boot parameters. You
should read the manual page, which gives you some good examples.
Here&#8217;s the command for starting the installation for the host demohost.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ fai-chboot -IFv -u nfs://faiserver/srv/fai/config demohost

Booting kernel vmlinuz-4.19.0-5-amd64
 append initrd=initrd.img-4.19.0-5-amd64 ip=dhcp
   FAI_FLAGS=verbose,sshd,createvt FAI_CONFIG_SRC=nfs://faiserver/srv/fai/config

demohost has 192.168.33.100 in hex C0A82164
Writing file /srv/tftp/fai/pxelinux.cfg/C0A82164 for demohost</code></pre>
</div></div>
<div class="paragraph"><p>At this point, you should have a working faiserver setup and your clients should boot into FAI and be able to install one of the examples.</p></div>
<div class="paragraph"><p>In the following section, you can read about planning your installation, tailoring your configuration space to your particular needs and extending FAI using hooks.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_custom_server_a_custom_server"><a id="custom server"></a>Custom server</h3>
<div class="paragraph"><p>The faiserver and its setup is by no means static. It is possible to customize and extend your server. For this, please refer to the <a href="#Customizing your install server setup">[Customizing your install server setup]</a> section in <a href="#advanced">[advanced]</a>.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_id_plan_a_plan_your_installation"><a id="plan"></a>Plan your installation</h2>
<div class="sectionbody">
<div class="paragraph"><p>Before starting your installation, you should invest a lot of time into
planning your installation. Once you&#8217;re happy with your installation
concept, FAI can do all the boring and repetitive tasks to turn your
plans into reality. FAI can&#8217;t do good installations if your concept is
imperfect or lacks some important details. Start planning the
installation by answering the following questions:</p></div>
<div class="ulist"><ul>
<li>
<p>
Will I create a Beowulf cluster, or do I  have to install some desktop machines?
</p>
</li>
<li>
<p>
What does my LAN topology look like?
</p>
</li>
<li>
<p>
Do I have uniform hardware?  Will the hardware stay uniform in the future?
</p>
</li>
<li>
<p>
Does the hardware need a special kernel?
</p>
</li>
<li>
<p>
How should the hosts be named?
</p>
</li>
<li>
<p>
How should the local hard disks be partitioned?
</p>
</li>
<li>
<p>
Which applications will be run by the users?
</p>
</li>
<li>
<p>
Do the users need a queuing system?
</p>
</li>
<li>
<p>
What software should be installed?
</p>
</li>
<li>
<p>
Which daemons should be started, and what  should the configuration for these look like?
</p>
</li>
<li>
<p>
Which remote file systems should be mounted?
</p>
</li>
<li>
<p>
How should backups be performed?
</p>
</li>
</ul></div>
<div class="paragraph"><p>You also have to think about user accounts, printers, a mail system,
cron jobs, graphic cards, dual boot, NIS, NTP, timezone, keyboard
layout, exporting and mounting directories via NFS and many other
things. So, there&#8217;s a lot to do before starting an installation. And
remember that knowledge is power, and it&#8217;s up to you to use
it. Installation and administration is a process, not a product. FAI
can&#8217;t do things you don&#8217;t tell it to do.</p></div>
<div class="paragraph"><p>You don&#8217;t need to start from scratch. Look at the files and scripts in
the configuration space. There are a lot of things you can use for
your own installation. A good paper called "Bootstrapping an
Infrastructure" with more aspects of building an infrastructure is
available at <a href="http://www.infrastructures.org/papers/bootstrap/bootstrap.html">http://www.infrastructures.org/papers/bootstrap/bootstrap.html</a></p></div>
<div class="sect2">
<h3 id="_a_id_c3_a_the_configuration_space_and_its_subdirectories"><a id="c3"></a>The configuration space and its subdirectories</h3>
<div class="paragraph"><p>The configuration space is the collection of information about how exactly
to install a client. The central configuration space for all install
clients is located on the install server in <em>/srv/fai/config</em> and its
subdirectories. This will be mounted by the install clients to
<em>/var/lib/fai/config</em>. The main installation command <code>fai(8)</code> uses all
these subdirectories in the order listed except for hooks.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<em>class/</em>
</dt>
<dd>
<p>
Scripts and files to
define classes and variables.
</p>
</dd>
<dt class="hdlist1">
<em>disk_config/</em>
</dt>
<dd>
<p>
Configuration files for disk partitioning, software RAID, LVM and file system creation.
</p>
</dd>
<dt class="hdlist1">
<em>basefiles/</em>
</dt>
<dd>
<p>
Normally the file <em>base.tar.xz</em> (located inside the nfsroot) is extracted on the install
client after the new file systems are created and before package are
installed. This is a minimal base image, created right after calling
debootstrap during the creation of the nfsroot on the install
server. If you want to install another distribution than the nfsroot
is, you can put a tar file into the subdirectory <em>basefiles/</em> and name
it after a class. Then the command <code>ftar(8)</code> is used to extract the
tar file based on the classes defined. Thus the file has to be named <em>CLASS.tar.xz</em> not <em>CLASS.base.tar.xz</em>. This is done in task
<em>extrbase</em>. Use this if you want to install another distribution or
version than that running during the installation.
</p>
<div class="paragraph"><p>This basefile can also be received based on FAI classes via HTTP/HTTPS or FTP
by defining the variable <code>FAI_BASEFILEURL</code>. FAI will download a file
CLASSNAME.tar.xz (or tgz, or tar.gz,&#8230;) from this URL, if <code>CLASSNAME</code>
matches a FAI class.</p></div>
<div class="paragraph"><p>Example:</p></div>
</dd>
</dl></div>
<div class="listingblock">
<div class="content">
<pre><code>FAI_BASEFILEURL=https://fai-project.org/download/basefiles/</code></pre>
</div></div>
<div class="paragraph"><p>The folder must support directory listing. FAI will not probe for potentially matching files.</p></div>
<div class="paragraph"><p>See chapter <a href="#otherdists">[otherdists]</a> for how to install different distributions.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<em>debconf/</em>
</dt>
<dd>
<p>
This directory holds all <code>debconf(7)</code> data. The format is the same
that is used by <code>debconf-set-selections(1)</code>.
</p>
</dd>
<dt class="hdlist1">
<em>package_config/</em>
</dt>
<dd>
<p>
Files with class names contain lists of software packages to be
installed or removed by <code>install_packages(8)</code>. Files named
<em>&lt;CLASS&gt;.gpg</em> are added to the list of keys used by apt
for trusted package repositories.
</p>
</dd>
<dt class="hdlist1">
<em>pkgs/</em>
</dt>
<dd>
<p>
This directory can contain subdirectories named by classes. You can
put <em>.deb</em> or <em>.rpm</em> files into these subdirectories. FAI will then
install these packages without the need of creating the metadata of a
package repository.
</p>
</dd>
<dt class="hdlist1">
<em>scripts/</em>
</dt>
<dd>
<p>
Scripts for your local site customization. Used by <code>fai-do-scripts(1)</code>.
</p>
</dd>
<dt class="hdlist1">
<em>files/</em>
</dt>
<dd>
<p>
Files used by customization scripts.  Most files are located in a
subtree structure which reflects the ordinary directory tree. For
example, the templates for <em>nsswitch.conf</em> are located in
<em>$FAI/files/etc/nsswitch.conf</em> and are named according to the classes
that they should match: <em>$FAI/files/etc/nsswitch.conf/NIS</em> is the
version of <em>/etc/nsswitch.conf</em> to use for the NIS class. Note that
the contents of the files directory are not automatically copied to
the target machine, rather they must be explicitly copied by
customization scripts using the <code>fcopy(8)</code> command.
</p>
</dd>
<dt class="hdlist1">
<em>hooks/</em>
</dt>
<dd>
<p>
Hooks are user defined programs or scripts, which are called during
the installation process. They can extend or replace the default tasks.
The file name must be of format <em>taskname.CLASSNAME[.sh]</em>.
A hook called <code>updatebase.DEBIAN</code> is executed prior to the task <code>updatebase</code>
and only if the install client belongs to the class DEBIAN.
</p>
</dd>
</dl></div>
</div>
<div class="sect2">
<h3 id="_a_id_defining_classes_a_defining_classes"><a id="defining classes"></a>Defining classes</h3>
<div class="paragraph"><p>There are different possibilities to define classes:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Some default classes are defined for every host:     DEFAULT, LAST and its host name.
</p>
</li>
<li>
<p>
Classes may be listed within a file (by default in <em>class/&lt;hostname&gt;</em>)
</p>
</li>
<li>
<p>
Classes may be dynamically defined by scripts.
</p>
</li>
</ol></div>
<div class="paragraph"><p>The last option is a very nice feature, since these scripts will
define classes in a very flexible way. For example, several classes
may be defined only if certain hardware is identified or a class is
defined depending on the network subnet information.</p></div>
<div class="paragraph"><p>All names of classes, except the host name, are written in
uppercase. They must not contain a hyphen, a hash, a semicolon or a
dot, but may contain underscores and digits.</p></div>
<div class="paragraph"><p>The task <em>defclass</em> calls the command <code>fai-class(1)</code> to define
classes. All scripts matching <em>^[0-9][0-9]*</em> (they start with two
digits) in the subdirectory
<em>$FAI/class</em> are executed for defining classes. Everything that is printed
to STDOUT is automatically defined as a class. For more
information on defining class, read the manual pages for
<code>fai-class(1)</code>. The script <em>50-host-classes</em> (see below a stripped
version) is used to define classes depending on the host name.</p></div>
<div class="listingblock">
<div class="content">
<pre><code># use a list of classes for our demo machines
case $HOSTNAME in
    demohost)
        echo "FAIBASE GRUB DEMO" ;;
    xfcehost)
        echo "FAIBASE GRUB DEMO XORG XFCE LVM";;
    faiserver)
        echo "FAIBASE DEBIAN DEMO FAISERVER" ;;
    ubuntuhost)
        echo "FAIBASE DEBIAN DEMO UBUNTU JAMMY JAMMY64 XORG";;
    *)
        echo "FAIBASE DEBIAN DEMO" ;;
esac</code></pre>
</div></div>
<div class="paragraph"><p>Host names should rarely be used for the configuration files in the
configuration space. Instead, a class should be defined and then added
for a given host. This is because most of the time the configuration
data is not specific for one host, but can be shared among several
hosts.</p></div>
<div class="paragraph"><p>The order of the classes is important because it defines the priority
of the classes from low to high.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_classvariables_a_defining_variables"><a id="classvariables"></a>Defining variables</h3>
<div class="paragraph"><p>The task <em>defvar</em> defines the variables for the install
client. Variables are defined by scripts in <em>class/*.var</em>. All global
variables can be set in <em>DEFAULT.var</em>. For groups of hosts use
a class file. For a single host use the file <code>$HOSTNAME</code> <em>.var</em>. Also
here, it&#8217;s useful to study all the examples.</p></div>
<div class="paragraph"><p>The following variables are used in the examples and may also be
useful for your installation:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
FAI_ACTION
</dt>
<dd>
<p>
Set the action FAI should perform. Normally this is done by
<code>fai-chboot(8)</code>. If you can&#8217;t use this command, define this variable
i.e. in the script <em>LAST.var</em>.
</p>
</dd>
<dt class="hdlist1">
FAI_ALLOW_UNSIGNED
</dt>
<dd>
<p>
If set to 1, FAI allows the installation of packages from unsigned
repositories.
</p>
</dd>
<dt class="hdlist1">
CONSOLEFONT
</dt>
<dd>
<p>
Is the font which is loaded during installation by <code>setfont(8)</code>.
</p>
</dd>
<dt class="hdlist1">
KEYMAP
</dt>
<dd>
<p>
Defines the keyboard map files in <em>/usr/share/keymaps</em> and
<em>$FAI/files</em>. You don&#8217;t need to specify the full path, since this file
will be located automatically.
</p>
</dd>
<dt class="hdlist1">
ROOTPW
</dt>
<dd>
<p>
The encrypted root password for the new system. You can use
<code>crypt(3)</code>, md5 and other hash types for the password. Use
<code>mkpasswd(1)</code> for creating the hash for a certain password.
For example, to generate a md5 hash for the password use
</p>
</dd>
</dl></div>
<div class="listingblock">
<div class="content">
<pre><code>$ echo "yoursecrectpassword" | mkpasswd -m yescrypt -s</code></pre>
</div></div>
<div class="dlist"><dl>
<dt class="hdlist1">
UTC
</dt>
<dd>
<p>
Set hardware clock to UTC if <em>UTC=yes</em>. Otherwise set clock to local
time. See <code>clock(8)</code> for more information.
</p>
</dd>
<dt class="hdlist1">
TIMEZONE
</dt>
<dd>
<p>
Is the file relative to <em>/usr/share/zoneinfo/</em> which indicates your
time zone. E.g.: <em>TIMEZONE=Europe/Berlin</em>.
</p>
</dd>
<dt class="hdlist1">
MODULESLIST
</dt>
<dd>
<p>
A list of kernel modules which are loaded during boot of the new system (written to
/etc/modules).
</p>
</dd>
</dl></div>
</div>
<div class="sect2">
<h3 id="_a_id_diskconfig_a_hard_disk_configuration"><a id="diskconfig"></a>Hard disk configuration</h3>
<div class="paragraph"><p>The tool <code>setup-storage(8)</code> reads a file in <em>$FAI/disk_config</em> for the
disk configuration. This file describes how
all the local disks will be partitioned, which file system types should be
created (like ext3/4, xfs, btrfs), and where they are
mounted to. You can also create software RAID and LVM setups using this
config file. It&#8217;s also possible to preserve the disk layout or to
preserve the data on certain partitions.</p></div>
<div class="paragraph"><p>During the installation process all local file systems are mounted
relative to <em>/target</em>. For example if you specify the mount point
<em>/home</em> in a disk configuration file this will be the directory
<em>/target/home</em> during the installation process and will become <em>/home</em>
for the new installed system.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_extrbase_a_extract_base_file"><a id="extrbase"></a>Extract base file</h3>
<div class="paragraph"><p>A base file is only needed when installing a distribution which is
different from the one in the nfsroot.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_debconf_a_debconf_preseeding"><a id="debconf"></a>Debconf preseeding</h3>
<div class="paragraph"><p>You can use the format described in <code>debconf-set-selections(1)</code>.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_repository_a_access_to_the_package_repository"><a id="repository"></a>Access to the package repository</h3>
<div class="paragraph"><p>FAI supports http, https and NFS for accessing the package mirror. Set
the variable <em>$FAI_DEBMIRROR</em> for using NFS.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_packageconfig_a_software_package_configuration"><a id="packageconfig"></a>Software package configuration</h3>
<div class="paragraph"><p>Before installing packages, FAI will add the content of all files
named <em>package_config/class.gpg</em> to the list of apt keys. If your local
repository is signed by your keyid AB12CD34 you can easily add this key,
so FAI will use it during installation. Use this command for creating
the <em>CLASS.gpg</em> file:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>faiserver$ gpg --export AB12CD34 &gt; /srv/fai/config/package_config/MYCLASS.gpg</code></pre>
</div></div>
<div class="paragraph"><p>The script <code>install_packages(8)</code> installs the selected software
packages. It reads all configuration files in <em>$FAI/package_config</em>
whose file name matches a defined class. The syntax is very simple.</p></div>
<div class="listingblock">
<div class="content">
<pre><code># an example package class

PACKAGES taskinst
german

PACKAGES install-norec
adduser nmap
less zstd

PACKAGES remove
gpm xdm

PACKAGES install GRUB_PC
grub-pc</code></pre>
</div></div>
<div class="paragraph"><p>Comments are starting with a hash (#) and are ending at the end of the
line. Every package command begins with the word <em>PACKAGES</em> followed by a
command name, which maps to a different package tool like apt-get,
aptitude or dnf for e.g. The command defines which command will be used to
install the packages named after this command. The list of all
available commands can be listed using <em>install_packages -H</em>.
Supported package tools are: <em>apt, apt-get, aptitude, smart, yast,
dnf, rpm, zypper</em></p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
hold
</dt>
<dd>
<p>
Put a package on hold. This package will not be handled by dpkg, e.g
not upgraded.
</p>
</dd>
<dt class="hdlist1">
install
</dt>
<dd>
<p>
Install all packages (using <code>apt-get</code>) that are specified in the following lines. If a
hyphen is appended to the package name (with no intervening space),
the package will be removed, not installed. All package names are
checked for misspellings.  Any package which does not exist, will be
removed from the list of packages to install. So be careful not to
misspell any package names.
</p>
</dd>
<dt class="hdlist1">
install-norec
</dt>
<dd>
<p>
Like install but without installing the recommended packages.
</p>
</dd>
<dt class="hdlist1">
remove
</dt>
<dd>
<p>
Remove all packages that are specified in the following lines. Append
a + to the package name if the package should be installed.
</p>
</dd>
<dt class="hdlist1">
taskinst
</dt>
<dd>
<p>
Install all packages belonging to the tasks that are specified in the
following lines using <code>tasksel(1)</code>. You can also use <em>aptitude</em> for
installing tasks.
</p>
</dd>
<dt class="hdlist1">
aptitude
</dt>
<dd>
<p>
Install all packages with the command <code>aptitude</code>. This will be the
default in the future and may replace apt-get and taskinst. Aptitude
can also install task packages.
</p>
</dd>
<dt class="hdlist1">
aptitude-r
</dt>
<dd>
<p>
Same as aptitude with option <em>--with-recommends</em>.
</p>
</dd>
<dt class="hdlist1">
unpack
</dt>
<dd>
<p>
Download package and unpack only. Do not configure the package.
</p>
</dd>
<dt class="hdlist1">
dselect-upgrade
</dt>
<dd>
<p>
Set package selections using the following lines and install or remove
the packages specified. These lines are the output of the command
<em>dpkg --get-selections</em>. It&#8217;s not recommended to use this format,
since you are also specifying all packages which are only installed
because of a dependency or a recommends. It&#8217;s better just to specify
the pacakge you like to have, and to let FAI (and apt-get) resolve the
dependencies.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Multiple lines with lists of space separated names of packages follow
the PACKAGES lines. All dependencies are resolved. Packages with
suffix <em>-</em> (eg. <em>lilo-</em>) will be removed instead of installed. The
order of the packages doesn&#8217;t matter.  If you like to install
packages from another release than the default, you can append the
release name to the package name like in
<em>openoffice.org/etch-backports</em>. You can also specify a certain
version like <em>apt=0.3.1</em>. More information on these features are
described in <code>aptitude(8)</code>.</p></div>
<div class="paragraph"><p>You can specify additional parameters for the package manager adding
<em>key=value</em> after <em>PACKAGES &lt;command&gt;</em>. Currently we support
<em>release=&lt;name&gt;</em> which will add <em>-t &lt;name&gt;</em> when installing packages.</p></div>
<div class="paragraph"><p>Example:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>PACKAGES install-norec release=testing
nvidia-smi</code></pre>
</div></div>
<div class="paragraph"><p>This will install the nvidia-smi package from the testing release,
including the dependencies. Don&#8217;t forget to add an entry into
<em>sources.list</em>. You may also want to adjust the apt pinning (see
<em>apt_references(5)</em>).</p></div>
<div class="paragraph"><p>A line which contains the <em>PRELOADRM</em> commands, downloads a file using
<code>wget(1)</code> into a directory before installing the packages. Using the
<em>file:</em> URL, this file is copied from <code>$FAI_ROOT</code> to the download
directory.  For example the package <code>realplayer</code> needs an archive to
install the software, so this archive is downloaded to the directory
<em>/root</em>. After installing the packages this file will be removed. If
the file shouldn&#8217;t be removed, use the command <em>PRELOAD</em> instead.</p></div>
<div class="paragraph"><p>You can add an arbitrary boolean expression using FAI classes to
define when the list of packages should be installed. Here, the
packages are only installed if the class XORG is defined but the class
MINT is not defined.</p></div>
<div class="paragraph"><p>Example:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>PACKAGES install UBUNTU &amp;&amp; XORG &amp;&amp; ! MINT
ubuntu-standard
ubuntu-desktop</code></pre>
</div></div>
<div class="paragraph"><p>The old way of adding some logic in the PACKAGES lines is still supported:
It&#8217;s possible to append a list of class names after the command for
apt-get. So this <em>PACKAGES</em> command will only be executed when at least
one of the corresponding classes is defined (logical OR). So you can
combine many small files into the file DEFAULT.</p></div>
<div class="paragraph"><p>If you want to remove a package name from a certain class was part of
this class before, you should not remove the package name from the
class file, but instead append a dash (-) to it. This will make sure
that the package is removed during a softupdate on hosts which were
installed using the old class definition which included this package
name.</p></div>
<div class="paragraph"><p>If you specify a package that does not exist this package will be
removed automatically from the installation list only if the command <em>install</em> is used.</p></div>
<div class="paragraph"><p>The concept of classes priority allows a higher priority class (one
that comes later in the sequence of classes) to override the selection
of packages of a lower priority class.  For this to work correctly,
the higher priority class must use the same <em>PACKAGES</em> command (e.g.
<em>PACKAGES install-norec</em> instead of just <em>PACKAGES install</em>) as the one
used by the class it is trying to override.  This is useful to suppress
installation of a package, for example, to avoid installing the <em>linuxlogo</em>
package installed by class FAIBASE:</p></div>
<div class="listingblock">
<div class="content">
<pre><code># example of how to override:
#
# On FAIBASE we have:
#    PACKAGES install-norec
#    linuxlogo
#
# We want to _not_ install linuxlogo, and it is in a
# install-norec section, so we must also use install-norec.

PACKAGES install-norec
linuxlogo-</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_a_id_cscripts_a_customization_scripts"><a id="cscripts"></a> Customization scripts</h3>
<div class="paragraph"><p>The command <code>fai-do-scripts(1)</code> is called to execute all scripts in
this directory. If a directory with a class name exists, all scripts
matching <em>^[0-9][0-9]*</em> are executed in alphabetical order. So it&#8217;s
possible to use scripts of different languages (shell, cfengine,
Perl, Python, Ruby, expect,..) for one class.</p></div>
<div class="paragraph"><p>Thoses scripts write their output to sripts.log. The file status.log
contains the names of all scripts executed and their exit status.</p></div>
<div class="sect3">
<h4 id="_a_id_shell_a_shell_scripts"><a id="shell"></a>Shell scripts</h4>
<div class="paragraph"><p>Most scripts are Bourne shell scripts. Shell scripts are useful if the
configuration task only needs to call some shell commands or create a
file from scratch. In order not to write many short scripts, it&#8217;s
possible to use the <code>ifclass</code> command for testing if certain classes
are defined.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>ifclass -o A B C</code></pre>
</div></div>
<div class="paragraph"><p>checks if one of classes A, B or C are defined. Using -a (logical
AND) checks if all classes of a list are defined. The command <em>ifclass
C</em> checks if only class C is defined.</p></div>
<div class="paragraph"><p>For copying files with classes, use the command
<code>fcopy(8)</code>. If you want to extract an archive using classes, use
<code>ftar(8)</code>. For appending lines to a configuration file use <code>ainsl(1)</code>
instead of just <code>echo string &gt;&gt; filename</code>.</p></div>
<div class="paragraph"><p>FAI also supports <em>zsh(1)</em> scripts during the
customization task. Within scripts, the variable <code>$classes</code> holds a space
separated list with the names of all defined classes.</p></div>
</div>
<div class="sect3">
<h4 id="_a_id_cfengine_a_cfengine_scripts"><a id="cfengine"></a>Cfengine scripts</h4>
<div class="paragraph"><p>CFEngine has a rich set of functions to edit existing configuration
files, e.g <em>LocateLineMatching, ReplaceAll, InsertLine,
AppendIfNoSuchLine, HashCommentLinesContaining</em>. But it can&#8217;t handle
variables which are undefined. If a variable is undefined, the whole
cfengine script will abort.</p></div>
<div class="paragraph"><p>More information can be found in the manual page <code>cfengine(8)</code> or at
the cfengine homepage <a href="https://www.cfengine.com">https://www.cfengine.com</a>.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_a_id_hooks_a_hooks"><a id="hooks"></a>Hooks</h3>
<div class="paragraph"><p>Hooks let you specify functions or programs which are run at certain
steps of the installation process. Before a task is called,
FAI searches for existing hooks for this task and executes them. As
you might expect, classes are also used when calling hooks. Hooks are
executed for every defined class. You only have to create the hook
with the name for the desired class and it will be used.  If several
hooks for a task exists, they are called in the order defined by the
classes.  If <em>debug</em> is included in <code>$FAI_FLAG</code> the option <em>-d</em> is
passed to all hooks, so you can debug your own hooks.  If some default
tasks should be skipped, use the subroutine <em>skiptask</em> and a list of
default tasks as parameters. In the examples provided, the hooks of
the class CENTOS skips some Debian specific tasks.</p></div>
<div class="paragraph"><p>The directory <em>$FAI/hooks/</em> contains all hooks. A hook is an executable
file following the naming scheme <em>taskname.CLASSNAME[.sh]</em> (e.g.
<em>repository.CENTOS</em> or 'savelog.LAST.sh). The
task name specifies which task to precede executing this hook, if the
specified class is defined for the installing client.  See section
<a href="#tasks">[tasks]</a> for a complete list of default tasks that can be used.</p></div>
<div class="paragraph"><p>A hook of the form <em>hookprefix.classname</em> can&#8217;t define variables for
the installation script, because it&#8217;s a subprocess. But you can use
any binary executable or any script you wrote. Hooks that have the
suffix <em>.sh</em> (e.g. <em>partition.DEFAULT.sh</em>) must be Bourne
shell scripts and are sourced. So it&#8217;s possible to redefine variables
for the installation scripts.</p></div>
<div class="paragraph"><p>In the first part of FAI, all hooks with prefix <em>confdir</em> are called.
Those hooks can not be located in the config space, since it&#8217;s not yet
available. Therefore these hooks are the only hooks located in
<code>$nfsroot</code><em>/$FAI/hooks</em> on the install server. All other hooks are
found in <em>$FAI_CONFIGDIR/hooks</em> on the install server.</p></div>
<div class="paragraph"><p>All hooks that are called before classes are defined can only use the
following classes: <em>DEFAULT $HOSTNAME LAST</em>. If a hook for class
<em>DEFAULT</em> should only be called if no hook for class <code>$HOSTNAME</code> is
available, insert these lines to the default hook:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>hookexample.DEFAULT:

#! /bin/sh

# skip DEFAULT hook if a hook for $HOSTNAME exists
scriptname=$(basename $0 .DEFAULT)
[-f $FAI/hooks/$scriptname.$HOSTNAME ] &amp;&amp; exit
# here follows the actions for class DEFAULT
.
.</code></pre>
</div></div>
<div class="paragraph"><p>Some examples for what hooks could be used:</p></div>
<div class="ulist"><ul>
<li>
<p>
Load kernel modules before classes are defined in <em>$FAI/class</em>.
</p>
</li>
<li>
<p>
Send an email to the administrator if the installation is finished.
</p>
</li>
<li>
<p>
Install a diskless client and skip local disk partitioning.
</p>
</li>
<li>
<p>
Have a look at <code>hooks/debconf.IMAGE</code> for how to clone a machine using a file system image.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_a_id_faiflags_a_fai_flags"><a id="faiflags"></a>FAI flags</h3>
<div class="paragraph"><p>The variable <code>$FAI_FLAGS</code> contains a space separated list of
flags. Flags are normally defined in the pxelinux.cfg file which
should be created by <em>fai-chboot(1)</em>. The following flags are known:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
verbose
</dt>
<dd>
<p>
Create verbose output during installation. This should always be the
first flag, so consecutive definitions of flags will be verbosely
displayed.
</p>
</dd>
<dt class="hdlist1">
debug
</dt>
<dd>
<p>
Create debug output. No unattended installation is performed. During
package installation you have to answer all questions of the
postinstall scripts on the client&#8217;s console. A lot of debug
information will be printed out. This flag is only useful for FAI
developers.
</p>
</dd>
<dt class="hdlist1">
sshd
</dt>
<dd>
<p>
Start the ssh daemon to enable remote logins.
You can then log in as <em>root</em> to all install clients during the
installation. The default password is <em>fai</em> and can be changed by
setting <code>FAI_ROOTPW</code> in <code>nfsroot.conf(5)</code>. To log in from your server
to the install client (named demohost in this example) use:
</p>
</dd>
</dl></div>
<div class="listingblock">
<div class="content">
<pre><code>$ ssh root@demohost
Warning: Permanently added 'demohost,192.168.33.100' to the list of known hosts.
root@demohost's password:</code></pre>
</div></div>
<div class="paragraph"><p>This is only the root password during the
installation process, not for the new installed system. You can also
log in without a password when using <code>$SSH_IDENTITY</code>.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
createvt
</dt>
<dd>
<p>
Create two virtual terminals and execute a bash if <em>ctrl-c</em> is typed
in the console terminal. The additional terminals can be accessed by
typing <em>Alt-F2</em> or <em>Alt-F3</em>. Otherwise, no terminals are available and
typing <em>ctrl-c</em> will reboot the install client. Setting this flag is
useful for debugging. If you want an installation which should not be
interruptible, do not set this flag.
</p>
</dd>
<dt class="hdlist1">
menu
</dt>
<dd>
<p>
This enables a user menu for selecting a profile. All files
<code>class/*.profile</code> are read and a curses based menu will be created.
</p>
</dd>
<dt class="hdlist1">
screen
</dt>
<dd>
<p>
Run FAI inside a <code>screen(1)</code> session. The session is called FAI.
If you log in via ssh from remote you can attach to the session using:
</p>
</dd>
</dl></div>
<div class="listingblock">
<div class="content">
<pre><code>$ screen -x</code></pre>
</div></div>
<div class="dlist"><dl>
<dt class="hdlist1">
tmux
</dt>
<dd>
<p>
Run FAI inside a <code>tmux(1)</code> session. The session is called FAI.
If you log in via ssh from remote you can attach to the session using:
</p>
</dd>
</dl></div>
<div class="listingblock">
<div class="content">
<pre><code>$ tmux attach</code></pre>
</div></div>
<div class="dlist"><dl>
<dt class="hdlist1">
reboot
</dt>
<dd>
<p>
Reboot the install client after installation is finished without
typing RETURN on the console. If this flag is not set, and error.log
contains anything, the install client will stop and wait that you
press RETURN. If no errors occurred, the client will always reboot
automatically.
</p>
</dd>
<dt class="hdlist1">
halt
</dt>
<dd>
<p>
Halt the install client at the end of the installation, instead of
rebooting into the new system.
</p>
</dd>
<dt class="hdlist1">
initial
</dt>
<dd>
<p>
Used by <code>setup-storage(8)</code>. Partitions marked with <code>preserve_reinstall</code>
are preserved unless this flag is set. Often, this flag is set in a
file <em>class/*.var</em> by using setting <em>flag_initial=1</em>.
</p>
</dd>
</dl></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_id_install_a_fai_installs_your_plan"><a id="install"></a> FAI installs your plan</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_the_early_part_of_an_installation">The early part of an installation</h3>
<div class="paragraph"><p>After the kernel has booted, it mounts the root file system via NFS
from the install server and starts the script
<em>/usr/sbin/fai</em> <span class="footnote"><br />[Since the root file system on the clients is mounted via
NFS, <code>fai</code> is located in
<em>/srv/fai/nfsroot/usr/sbin</em> on the install
server.]<br /></span>. This script controls the sequence of the
installation. No other scripts in <em>/etc/init.d/</em> are used.</p></div>
<div class="paragraph"><p>The configuration space is made available via the configured method
(an NFS mount by default) from the install server to the path defined
in <em>$FAI</em> <span class="footnote"><br />[<em>$FAI</em> is an internal variable used by the FAI
scripts. By default the path is <em>/var/lib/fai/config</em>.]<br /></span></p></div>
</div>
<div class="sect2">
<h3 id="_a_id_bootmesg_a_boot_messages"><a id="bootmesg"></a>Boot messages</h3>
<div class="paragraph"><p>When booting the install client from network card with PXE you will see some
messages like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Managed PC Boot Agent (MBA) v4.00
Pre-boot eXecution Environment (PXE) v2.00
DHCP MAC ADDR: 00 A2 A3 04 05 06
DHCP.../

CLIENT MAC ADDR: 00 A2 A3 04 05 06  GUID: 3D6C4552
CLIENT IP: 192.168.33.100 MASK: 255.255.255.0  DHCP IP: 192.168.33.250
GATEWAY IP: 192.168.33.1

!PXE entry point found (we hope) at 9854:0106 via plan A
UNDI code segment at: 9854 len 5260
UNDI data segment at: 921D len 63A2
Getting cached packet  01 02 03
My Ip address seems to be C0A82164 192.168.33.100
ip=192.168.33.100:192.168.33.250:192.168.33.1:255.255.255.0
BOOTIF=01-00-A2-A3-04-05-06
SYSUUID=
TFTP prefix: fai/
Trying to load pxelinux.cfg/C0A82164

Loading vmlinuz-6.1.0-17-amd64..................
Loading initrd.img-6.1.0-17-amd64......................ready.</code></pre>
</div></div>
<div class="paragraph"><p>At this point the install client has successfully received the network
config via DHCP and the kernel and initrd via TFTP. It now boots the
Linux kernel and the initrd. If everything went right, the initrd
mounts the nfsroot <span class="footnote"><br />[<em>/srv/fai/nfsroot</em> from the install
server via NFS]<br /></span> and the FAI scripts are started. The first
thing you see is the red FAI copyright message.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>             -------------------------------------------------
                   Fully Automatic Installation  -  FAI

                   6.2           (c) 1999-2024
                   Thomas Lange  &lt;lange@cs.uni-koeln.de&gt;
             -------------------------------------------------

Calling task_confdir
Kernel currently running: Linux 6.1.0-17-amd64 x86_64 GNU/Linux
Kernel parameters: BOOT_IMAGE=vmlinuz-6.1.0-17-amd64 initrd=initrd.img-6.1.0-17-amd64 \
  ip=dhcp rw root=192.168.33.250:/srv/fai/nfsroot rootovl FAI_FLAGS=verbose,sshd,createvt
  FAI_ACTION=install FAI_CONFIG_SRC=nfs://faiserver/srv/fai/config
Reading /tmp/fai/boot.log
FAI_FLAGS: verbose sshd createvt
Monitoring to server faiserver enabled.
FAI_CONFIG_SRC is set to nfs://faiserver/srv/fai/config
Configuration space faiserver:/srv/fai/config mounted to /var/lib/fai/config
Source hook: setup.DEFAULT.sh
setup.DEFAULT.sh     OK.
Calling task_setup
FAI_FLAGS: verbose sshd createvt
Press ctrl-c to interrupt FAI and to get a shell
Starting FAI execution - 20240117_194012
Calling task_defclass
fai-class: Defining classes.
Executing /var/lib/fai/config/class/01-classes.
01-classes           OK.
Executing /var/lib/fai/config/class/10-base-classes.
10-base-classes      OK.
Executing /var/lib/fai/config/class/20-hwdetect.sh.
ens3             UP             52:54:00:11:23:01 &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;
ens3             UP             192.168.33.101/24 fe80::5054:ff:fe11:2301/64
New disklist: vda
20-hwdetect.sh       OK.
Executing /var/lib/fai/config/class/40-parse-profiles.sh.
40-parse-profiles.sh OK.
Executing /var/lib/fai/config/class/41-warning.sh.
41-warning.sh        OK.
Executing /var/lib/fai/config/class/50-host-classes.
50-host-classes      OK.
Executing /var/lib/fai/config/class/60-misc.
60-misc              OK.
Executing /var/lib/fai/config/class/85-efi-classes.
85-efi-classes       OK.
List of all classes:  DEFAULT LINUX AMD64 DHCPC FAIBASE DEBIAN DEMO GRUB_PC demohost2 LAST</code></pre>
</div></div>
<div class="paragraph"><p>You can also see the list of FAI classes, that are defined for this
host. This list is very important for the rest of the installation.</p></div>
<div class="paragraph"><p>The first task is called <em>confdir</em>, which is responsible for getting
access to the config space. Here, we use an NFS mount from the install
server as you can see on the console (and later in the logs).</p></div>
<div class="listingblock">
<div class="content">
<pre><code>FAI_CONFIG_SRC is set to nfs://faiserver/srv/fai/config
Configuration space faiserver:/srv/fai/config mounted to /var/lib/fai/config</code></pre>
</div></div>
<div class="paragraph"><p>Before the installation is started (<code>$FAI_ACTION=install</code>) the computer
beeps three times. So, be careful when you hear three beeps but you do
not want to perform an installation and let FAI erase all yout data on
the local disk!</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_reboot_a_rebooting_the_computer_into_the_new_system"><a id="reboot"></a>Rebooting the computer into the new system</h3>
<div class="paragraph"><p>For rebooting the computer during or at the end of the installation you
should use the command <code>faireboot</code> in favour of the normal reboot command.
Use <code>faireboot</code> also if logged in from remote. If the installation
hasn&#8217;t finished, use <em>faireboot -s</em>, so the log files are also copied
to the install server.</p></div>
<div class="paragraph"><p>If the installation has finished successfully, the computer should boot a
small Debian system. You can login as user <em>demo</em> or <em>root</em> with password <em>fai</em>.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_isetup_a_starting_fai_task_confdir"><a id="isetup"></a>Starting FAI (task confdir)</h3>
<div class="paragraph"><p>After the install client has booted only the script <em>/usr/sbin/fai</em> is
executed. It will do some minimal initialization. The variable
<code>$FAI_CONFIG_SRC</code> <span class="footnote"><br />[It is defined on the kernel command line]<br /></span>
is used to get access to the FAI configuration space which is then
available in the directory <code>$FAI</code> <span class="footnote"><br />[/var/lib/fai/config]<br /></span>. FAI
will not proceed without the config space.</p></div>
<div class="paragraph"><p>You can access the config space using different methods. Supported
methods are: nfs:, file:, cvs:, svn: git:, hg:, http: and detect:.
See <code>fai.conf(5)</code> for a detailed description of these methods.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_iclass_a_defining_classes_and_variables_tasks_defclass_and_defvar"><a id="iclass"></a>Defining classes and variables (tasks defclass and defvar)</h3>
<div class="paragraph"><p>The command <code>fai-class(1)</code> executes scripts in <em>$FAI/class</em> for defining
classes. If the scripts write a string to stdout, this will be defined
as a class. Read all the details in the man page of <code>fai-class(1)</code>.</p></div>
<div class="paragraph"><p>After defining the classes, every file matching <em>.var</em> with a prefix
which matches a defined class is sourced to define variables. It must
contain valid shell code.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_ipartition_a_partitioning_local_disks_creating_file_systems_task_partition"><a id="ipartition"></a>Partitioning local disks, creating file systems (task partition)</h3>
<div class="paragraph"><p>For the disk partitioning exactly one disk configuration file from
<em>$FAI/disk_config</em> is selected using classes.</p></div>
<div class="paragraph"><p>The format of the disk configuration is similar to a fstab file.</p></div>
<div class="paragraph"><p>The partitioning tool <code>setup-storage(8)</code> performs all commands
necessary for creating the disk partition layout, software RAID, LVM
and for creating the file systems. Disks and partitions may easily be
referenced by disk1.1, disk2.4 etc. Read the manual page of
<code>setup-storage(8)</code> for a detailed description and some examples of the
format.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_ipreseed_a_debconf_preseeding_task_debconf"><a id="ipreseed"></a>Debconf preseeding (task debconf)</h3>
<div class="paragraph"><p>Files in <em>$FAI/debconf</em> are used for the usual <code>debconf(7)</code> preseeding
if the file names match a class name.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_ipackages_a_installing_software_packages_task_instsoft"><a id="ipackages"></a>Installing software packages (task instsoft)</h3>
<div class="paragraph"><p>The command <code>install_packages(8)</code> reads the config files from
<em>$FAI/package_config</em> in a class based manner and installs software
packages on the new file system.</p></div>
<div class="paragraph"><p>It installs the packages using <code>apt-get(8)</code>, <code>aptitude(1)</code>, <code>yum</code> or other
package tools without any manual interaction needed. Package
dependecies are also resolved by the package tools.</p></div>
<div class="paragraph"><p>The format of the configuration files is described in <a href="#packageconfig">[packageconfig]</a>.</p></div>
<div class="paragraph"><p>Additionaly FAI will install packages (<em>.deb</em> or .rpm') from the
directories <em>$FAI/pkgs/&lt;CLASSNAME&gt;</em>.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_icscripts_a_site_specific_customization_task_configure"><a id="icscripts"></a>Site specific customization (task configure)</h3>
<div class="paragraph"><p>Often the default configurations of the software packages will not
meet your site-specific needs. You can call arbitrary scripts which
adjust the system configuration. Therefore the command
<code>fai-do-scripts(1)</code> executes scripts in <em>$FAI/scripts</em> in a class
based manner. It is possible to have several scripts of different
types (shell, cfengine, &#8230;) to be executed for one class.</p></div>
<div class="paragraph"><p>The default set of scripts in <em>$FAI/scripts</em> include examples for
installing Debian and Rocky Linux machines. They set the root password, add
a user account (set by '$username, default to demo), set the timezone, configure the network for DHCP
or using a fixed IP address, setup grub and more.
They should do a reasonable job for your installation. You can edit
them or add new scripts to match your local needs.</p></div>
<div class="paragraph"><p>More information about these scripts are described in <a href="#cscripts">[cscripts]</a>.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_isavelog_a_saving_log_files_task_savelog"><a id="isavelog"></a>Saving log files (task savelog)</h3>
<div class="paragraph"><p>When all tasks are finished, the log files are written to
<em>/var/log/fai/$HOSTNAME/install/</em>
<span class="footnote"><br />[<em>/var/log/fai/localhost/install/</em> is a link to this
directory.]<br /></span> on the new system and to the account on the install server
if <code>$LOGUSER</code> is defined (you have to enable this in
<em>/srv/fai/config/class/FAIBASE.var</em>). It is also possible to specify
another host as log saving destination through the variable
<code>$LOGSERVER</code>. If <code>$LOGSERVER</code> is not defined, FAI uses the variable
<code>$SERVER</code> which is only defined during an initial installation (by
get-boot-info).</p></div>
<div class="paragraph"><p>Additionally, two symlinks will be created to indicated the last
directory written to. The symlink <em>last</em> points to the log directory
of the last FAI action performed. The symlinks <em>last-install</em> and
<em>last-sysinfo</em> point to the directory of the last corresponding
action. By default log files will be copied to the log
server using scp. You can use the variable <code>$FAI_LOGPROTO</code> in file
<em>fai.conf(5)</em> to choose another method for saving logs to the remote
server. Here&#8217;s an example of the symlink structure:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>lrwxrwxrwx   1 fai fai   23 Dec  2  2013 last-sysinfo -&gt; sysinfo-20131202_161237
drwxr-xr-x   2 fai fai 4096 Dec  2  2013 sysinfo-20131202_161237
drwxr-xr-x   2 fai fai 4096 Feb 14  2014 install-20140214_142150
drwxr-xr-x   2 fai fai 4096 Dec  2 11:47 install-20141202_113918
lrwxrwxrwx   1 fai fai   23 Dec  4 13:22 last-install -&gt; install-20141204_131351
lrwxrwxrwx   1 fai fai   23 Dec  4 13:22 last -&gt; install-20141204_131351
drwxr-xr-x   2 fai fai 4096 Dec  4 13:22 install-20141204_131351</code></pre>
</div></div>
<div class="paragraph"><p>Examples of the log files can be found at <a href="https://fai-project.org/logs">https://fai-project.org/logs</a>.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_ireboot_a_reboot_the_new_installed_system"><a id="ireboot"></a>Reboot the new installed system</h3>
<div class="paragraph"><p>Before rebooting, the install client calls <code>fai-chboot -d &lt;hostname&gt;</code>
on the install server, to disable its own PXELINUX
configuration. Otherwise, it would restart the installation during the
next boot. Normally this should boot the new installed system from
its second boot device, the local hard disk.</p></div>
<div class="paragraph"><p>At the end, the system is automatically rebooted if "reboot" was added to
<code>$FAI_FLAGS</code>.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_id_advanced_a_advanced_fai_topics"><a id="advanced"></a>Advanced FAI topics</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_a_id_checkbootp_a_checking_parameters_received_from_dhcp_servers"><a id="checkbootp"></a>Checking parameters received from DHCP servers</h3>
<div class="paragraph"><p>If the install client boots you can check
if all information from the DHCP daemon are received
correctly. The received information is written to
<em>/tmp/fai/boot.log</em>. An example of the result of a DHCP request can be
found in the sample log files.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_fai_monitor_a_monitoring_multiple_client_installations"><a id="fai-monitor"></a>Monitoring multiple client installations</h3>
<div class="paragraph"><p>You can monitor the installation of all install clients with the
command <code>fai-monitor(8)</code>. All clients check if this daemon is running
on the install server (or the machine defined by the variable
<code>$monserver</code>). Each time a task starts or ends, a message is sent. The
FAI monitor daemon prints this messages to standard output. There&#8217;s
also a graphical frontend available, called <code>fai-monitor-gui(1)</code>.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$  fai-monitor | fai-monitor-gui - &amp;</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_a_id_mac_a_collecting_ethernet_addresses_for_multiple_hosts"><a id="mac"></a>Collecting Ethernet addresses for multiple hosts</h3>
<div class="paragraph"><p>You have to collect all Ethernet (MAC) addresses of the install
clients and assign a host name and IP address to each client. To
collect the MAC addresses, boot your install clients.
You can already do this before any DHCP daemon is running in your
subnet. They will fail to boot (because of the missing DHCP or missing TFTP),
but you can still collect the MAC addresses.</p></div>
<div class="paragraph"><p>While the install clients are booting, they send broadcast packets to the
LAN. You can log the MAC addresses of these hosts by running the
following command simultaneously on the server:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>faiserver# tcpdump -qtel broadcast and port bootpc &gt;/tmp/mac.list</code></pre>
</div></div>
<div class="paragraph"><p>After the hosts have been sent some broadcast packets abort <code>tcpdump</code>
by typing <em>ctrl-c</em>. You get a list of all
unique MAC addresses with these commands:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>faiserver$ perl -ane 'print "\U$F[0]\n"' /tmp/mac.list|sort|uniq</code></pre>
</div></div>
<div class="paragraph"><p>After that, you only have to assign these MAC addresses to host names
and IP addresses (<em>/etc/ethers</em> and <em>/etc/hosts</em> or corresponding NIS
maps). With this information you can configure your <code>DHCP</code>
daemon (see the section <a href="#bootdhcp">[bootdhcp]</a>). <span class="footnote"><br />[I recommend to write the MAC
addresses (last three bytes will suffice if you have network cards
from the same vendor) and the host name in the front of each chassis.]<br /></span></p></div>
<div class="sect3">
<h4 id="_debugging_the_network_traffic">Debugging the network traffic</h4>
<div class="paragraph"><p>If the client can&#8217;t successfully boot from the network card, use
<code>tcpdump(8)</code> to look for Ethernet packets between the install server
and the client. Search also for entries in several log files made by
<code>tftpd(8)</code> and <code>dhcpd(8)</code> :</p></div>
<div class="listingblock">
<div class="content">
<pre><code>faiserver$ egrep "tftpd|dhcpd" /var/log/*</code></pre>
</div></div>
</div>
</div>
<div class="sect2">
<h3 id="_a_id_pxeboot_a_details_of_pxe_booting"><a id="pxeboot"></a>Details of PXE booting</h3>
<div class="paragraph"><p>Here we describe the details of PXE booting, which are only needed if
you have problems when booting your install clients.</p></div>
<div class="paragraph"><p>Almost all modern bootable network cards support the PXE boot environment.
PXE is the Preboot Execution Environment.
This requires the PXELINUX bootloader and a special version of the <em>TFTP</em>
daemon, which is available in the Debian packages <code>pxelinux</code> and
<code>tftpd-hpa</code>. PXE booting also needs a DHCP server, so that the network
card can configure its IP parameters. This is the sequence of a PXE boot:</p></div>
<div class="ulist"><ul>
<li>
<p>
Network card of the client sends its MAC address
</p>
</li>
<li>
<p>
DHCP server replies with IP configuration for the client
</p>
</li>
<li>
<p>
Network card configures IP
</p>
</li>
<li>
<p>
Install client gets the pxelinux.0 binary via TFTP
</p>
</li>
<li>
<p>
Get the pxelinux.cfg/C0A8210C configuration file via TFTP
</p>
</li>
<li>
<p>
C0A8210C is the IP address of the client in hexadecimal
</p>
</li>
<li>
<p>
This configuration contains kernel, initrd and additional kernel
command line parameters, which was created by <code>fai-chboot</code>.
</p>
</li>
<li>
<p>
Get the kernel and initrd via TFTP.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Example of a pxelinux.cfg file:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>default fai-generated

label fai-generated
kernel vmlinuz-6.1.0-17-amd64
append initrd=initrd.img-6.1.0-17-amd64 ip=dhcp root=/srv/fai/nfsroot rootovl FAI_FLAGS=verbose,sshd,createvt FAI_CONFIG_SRC=nfs://faiserver/srv/fai/config FAI_ACTION=install</code></pre>
</div></div>
<div class="paragraph"><p>See <em>/usr/share/doc/syslinux/pxelinux.doc</em> for more detailed
information about PXELINUX. FAI uses the lpxelinux.0 binary which also
supports loading the kernel and initrd via FTP or HTTP. The command
<em>fai-chboot(8)</em> supports this with the option <em>-U</em>.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_customizing_your_install_server_setup_a_customizing_your_install_server_setup"><a id="Customizing your install server setup"></a>Customizing your install server setup</h3>
<div class="ulist"><ul>
<li>
<p>
local/faster package mirror
</p>
</li>
<li>
<p>
different loguser
</p>
</li>
<li>
<p>
local root pw inside nfsroot
</p>
</li>
</ul></div>
<div class="paragraph"><p>The configuration for the FAI package (not the configuration data for
the install clients) is defined in <em>fai.conf(5)</em>. Definitions that are
only used for creating the nfsroot are located in
<em>nfsroot.conf(5)</em>. Check these important variables in <em>nfsroot.conf</em>
before calling <em>fai-setup</em> or <em>fai-make-nfsroot</em>.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
FAI_DEBOOTSTRAP
</dt>
<dd>
<p>
Building the nfsroot uses the command <code>debootstrap(8)</code>. It needs the location of a Debian mirror and the
name of the distribution (like bullsseye, bookworm, sid) for which the basic Debian
system should be built. Do not use different distributions here and in
<em>/etc/fai/apt/sources.list</em>. This will create a broken nfsroot.
</p>
</dd>
<dt class="hdlist1">
NFSROOT_ETC_HOSTS
</dt>
<dd>
<p>
This variable is only needed if the clients do not have access to a DNS server.
This multiline variable is added to /etc/hosts inside the
nfsroot. Then the install clients can access those hosts by name
without using DNS.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>The content of <em>/etc/fai/apt/sources.list</em> is
used by the install server and also by the clients. If your install
server has multiple network cards and different host names for each
card (as for a Beowulf server), use the install server name which is
known by the install clients.</p></div>
<div class="paragraph"><p>If you have problems running <code>fai-setup</code>, they usually stem from
<code>fai-make-nfsroot(8)</code> which is called by former command. Adding <em>-v</em>
gives you a more verbose output which helps you pinpoint the
error. The output is written to
<em>/var/log/fai/fai-make-nfsroot.log</em>. <span class="footnote"><br />[For debugging purpose
it may help to enter the chroot environment manually using this
command.  <em>faiserver# chroot /srv/fai/nfsroot bash</em>]<br /></span></p></div>
<div class="paragraph"><p>The setup also creates the account <em>fai</em> (defined by <code>$LOGUSER</code>) if
not already available. So you can add a user before calling
<code>fai-setup(8)</code> using the command <code>adduser(8)</code> and use this as your
local account for saving log files. The log files of all install
clients are saved to the home directory of this account. You should
change the primary group of this
account, so this account has write permissions to <em>/srv/tftp/fai</em> in
order to call fai-chboot for creating the PXE configuration for the hosts.</p></div>
<div class="paragraph"><p>When you make changes to <em>fai.conf</em>, <em>nfsroot.conf</em> the
nfsroot has to be rebuilt by calling <code>fai-make-nfsroot(8)</code>. If you
only like to install a new kernel package to the nfsroot add the flags <em>-k</em> or
<em>-K</em> to <code>fai-make-nfsroot</code>. This will not recreate your nfsroot, but
only updates your kernel and kernel modules inside the nfsroot or add
additional packages into the nfsroot.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_cdboot_a_creating_a_fai_cd_or_and_usb_stick"><a id="cdboot"></a>Creating a FAI CD or and USB stick</h3>
<div class="paragraph"><p>You can easily create an installation CD (or USB stick) of your
network installation setup. This will perform the same installation
and configuration from CD without the need of the install server.
Therefore you need to create a partial mirror of all Debian packages
needed for your FAI classes (using <code>fai-mirror(1)</code>). Then the command
<code>fai-cd(8)</code> will put this mirror, the nfsroot and the config space
onto a bootable CD. That&#8217;s it!</p></div>
<div class="paragraph"><p>To easily create the installation CD, you can use the following command
(for more tuning details see <code>fai-cd(8)</code>):</p></div>
<div class="listingblock">
<div class="content">
<pre><code> faiserver# fai-cd -m &lt;partialMirrorDir&gt; fai-cd.iso</code></pre>
</div></div>
<div class="paragraph"><p>This installation CD contains all data needed for the
installation. The command <code>fai-cd(8)</code> puts the nfsroot, the
configuration space and a subset of the Debian mirror onto a
CD-ROM. A partial package mirror is created using the command
<code>fai-mirror(1)</code> which contains all packages that are used by the
classes used in your configuration space.  A sample ISO image is
available at <a href="https://fai-project.org/fai-cd">https://fai-project.org/fai-cd</a>.</p></div>
<div class="paragraph"><p>Using the command <code>dd(1)</code> you can also create a bootable USB
stick by just writing the content of the ISO file to your USB stick
(here the stick is <em>/dev/sdf</em>).</p></div>
<div class="listingblock">
<div class="content">
<pre><code> faiserver# dd if=fai-cd.iso of=/dev/sdf bs=1M</code></pre>
</div></div>
<div class="paragraph"><p><code>mk-data-partition</code> is a tool that extends an ISO (that will be copied
to an USB stick) or an USB stick containing an ISO with
an ext4 or exFAT partition and sets the file system label to MY-DATA.
This partition is automatically mounted to <em>/media/data</em> by FAI.
You can copy your own <em>.deb</em> packages into this data partition und the
subdiretories <em>pkgs/&lt;CLASSNAME&gt;</em>. FAI will then install these packages
if the equivalent class is defined.</p></div>
<div class="paragraph"><p>Example how to use <code>mk-data-partition</code>:</p></div>
<div class="listingblock">
<div class="content">
<pre><code># mk-data-partition -s 1G -c faicd-large.iso A B</code></pre>
</div></div>
<div class="paragraph"><p>The former command creates the data partition of size 1 Gbytes inside
the ISO file and copy directories A and B to it. You can then copy the modified ISO
onto an USB stick.</p></div>
<div class="paragraph"><p>If the ISO is already on the USB stick and if it&#8217;s available as
<em>dev/sdf</em>, you can add a data partition of type exFAT will will use
the whole remaining part of the USB stick by using this command:</p></div>
<div class="listingblock">
<div class="content">
<pre><code># mk-data-partition -F /dev/sdf</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_a_id_diskimage_a_creating_vm_disk_images_using_fai"><a id="diskimage"></a>Creating VM disk images using FAI</h3>
<div class="paragraph"><p>The command <code>fai-diskimage(8)</code> creates disk
images, which can be used with a virtual machine like KVM, VMware,
VirtualBox or a cloud service like OpenStack, GCE, EC2 and others. The
installation process performs the normal FAI tasks on a raw disk
image. After the installation you can boot the disk image and have a
running system. The disk image can also be converted to qcow2 format.
You do not need to setup the FAI nfsroot when only using
fai-diskimage. But you need a basefile in your configuration
space. Setting the variable <code>$FAI_BASEFILEURL</code> will automatically
download an appropriate base file into your config space.</p></div>
<div class="paragraph"><p>Here&#8217;s an example how to create a raw disk image for a host called
cloud3, with a small set of software packages:</p></div>
<div class="listingblock">
<div class="content">
<pre><code># export FAI_BASEFILEURL=https://fai-project.org/download/basefiles/
# fai-diskimage -vu cloud3 -S2G -cDEBIAN,BOOKWORM64,AMD64,FAIBASE,GRUB_PC,DHCPC,DEMO,CLOUD,LAST disk.raw</code></pre>
</div></div>
<div class="paragraph"><p>This command will create a disk image called ubuntu.qcow2 for a Ubuntu 16.04 desktop
with hostname set to foobar.</p></div>
<div class="listingblock">
<div class="content">
<pre><code># export FAI_BASEFILEURL=https://fai-project.org/download/basefiles/
# cl=DHCPC,UBUNTU,JAMMY,JAMMY64,AMD64,XORG,LAST
# fai-diskimage -Nvu foobar -S5G -c$cl ubuntu.qcow2</code></pre>
</div></div>
<div class="paragraph"><p>You can give disk images a try without installing FAI, if you visit
<a href="https://fai-project.org/FAIme/cloud">https://fai-project.org/FAIme/cloud</a></p></div>
</div>
<div class="sect2">
<h3 id="_a_id_live_image_a_creating_a_bootable_live_image"><a id="live-image"></a>Creating a bootable live image</h3>
<div class="paragraph"><p>Creating a bootable live ISO is easy with FAI. You only need two
steps. First, create your live environment using the command <em>fai
dirinstall</em>. Don&#8217;t forget to add the class <code>LIVEISO</code>.
Then create the live ISO using <em>fai-cd</em>:</p></div>
<div class="listingblock">
<div class="content">
<pre><code># cl="DEBIAN,BOOKWORM64,AMD64,FAIBASE,XFCE,XORG,DHCPC,DEMO,LIVEISO,LAST"
# LC_ALL=C fai -v dirinstall -u xfce33 -c $cl \
    -s file:///srv/fai/config /srv/xfce
# fai-cd -s500 -MH -d none -g /etc/fai/grub.cfg.live \
    -n /srv/xfce live.iso</code></pre>
</div></div>
<div class="paragraph"><p>The nfsroot is not needed for a live ISO.
Currently there&#8217;s no live ISO of the install server available.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_cross_arch_a_building_cross_architecture_disk_images"><a id="cross-arch"></a>Building cross-architecture disk images</h3>
<div class="paragraph"><p>Starting FAI 5.4 it&#8217;s now possible to build a disk image for
different architectures than the host is running. For example you can
build an image for 64-bit ARM architecture (aarch64) on a host running on amd64
architecture. Here are the steps do to:</p></div>
<div class="listingblock">
<div class="content">
<pre><code># apt install qemu-system-arm qemu-user-static fai-server fai-setup-storage fai-doc qemu-utils
# fai-mk-configspace

# export FAI_BASEFILEURL=https://fai-project.org/download/basefiles/
# fai-diskimage -vu armhost -S2G -cDEFAULT,DHCPC,DEBIAN,ARM64,BUSTER_ARM64,FAIBASE,DEMO,CLOUD,LAST arm64.raw
# chown your_user_id arm64.raw
# cp /var/log/fai/armhost/last/vmlinuz* vmlinuz
# cp /var/log/fai/armhost/last/initrd.img* initrd</code></pre>
</div></div>
<div class="paragraph"><p>Then you can run qemu as a normal user:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&gt; qemu-system-aarch64 -m 1000 -M virt,gic_version=3 -cpu cortex-a57 -drive file=arm64.raw,if=virtio,index=1 -no-reboot -nographic -name ARM64 -net nic,name=eth0,model=virtio -net user,name=eth0,-kernel vmlinuz -initrd initrd -append "console=ttyAMA0 rw ip=dhcp root=/dev/vda1 net.ifnames=0"</code></pre>
</div></div>
<div class="paragraph"><p>This works similar for other architectures.
Keep in mind, that qemu network setup will have poor performance if
not using the virtio driver as above or tap devices.</p></div>
<div class="paragraph"><p>You can find the base files for many architectures at
<a href="https://fai-project.org/download/basefiles/">https://fai-project.org/download/basefiles/</a>, or use <code>mk-basefile</code> to
create your own.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_sysinfo_a_fai_rescue_system"><a id="sysinfo"></a>FAI rescue system</h3>
<div class="paragraph"><p>If you set the variable <code>$FAI_ACTION</code> to <em>sysinfo</em> (for e.g. by using
<code>fai-chboot -S</code>), the client will not install a new system, but will
collect a lot of system information.
If you set <code>$FAI_ACTION</code> to <em>inventory</em> you will only get a few
hardware information.
Both actions can be used for FAI as a rescue system.</p></div>
<div class="paragraph"><p>Type <em>ctrl-c</em> to get a shell or use <em>Alt-F2</em> or <em>Alt-F3</em> and you will get
another console terminal, if you have added <em>createvt</em> to <code>$FAI_FLAGS</code>.</p></div>
<div class="paragraph"><p>You now have a running Linux system on the install client without
using the local hard disk. Use this as a rescue system if your local
disk is damaged or the computer can&#8217;t boot properly from hard
disk. You will get a shell and you can execute various commands
(<code>dmesg</code>, <code>lsmod</code>, <code>df</code>, <code>lspci</code>, &#8230;). Look at the log file in
<em>/tmp/fai</em>. There you can find much information about the boot
process.</p></div>
<div class="paragraph"><p>FAI mounts all file systems it finds on the local disks read only. It
also tells you on which partition a file <em>/etc/fstab</em> exists. When
only one file system table is found, the partitions are mounted
according to this information. Here&#8217;s an example:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>demohost:~# df -h

Filesystem                Size  Used Avail Use% Mounted on
devtmpfs                  4.0M     0  4.0M   0% /dev
tmpfs                     2.0G     0  2.0G   0% /dev/shm
tmpfs                     783M   18M  766M   3% /run
tmpfs                     5.0M     0  5.0M   0% /run/lock
LiveOS_rootfs             783M   18M  766M   3% /
192.168.33.250:/srv/fai/config   59G   23G   24G  49% /var/lib/fai/config
/dev/mapper/vg1-root      7.3G  1.8G  5.2G  26% /target
/dev/vda1                 459M   53M  378M  13% /target/boot
/dev/mapper/vg1-home      1.4G   72K  1.3G   1% /target/home</code></pre>
</div></div>
<div class="paragraph"><p><strong>This method can be used as a rescue environment!</strong> If you need a file
system with read-write access use the <code>rwmount</code> command:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>demohost# rwmount /target/home</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_a_id_nonfs_a_fai_without_nfs"><a id="nonfs"></a>FAI without NFS</h3>
<div class="paragraph"><p>To boot into FAI and begin the installation sequence
without using the NFS protocol, you boot the client machine using PXE as
usual and then retrieve an image containing the nfsroot via http.</p></div>
<div class="paragraph"><p>To create an image, use fai-cd&#8217;s -S argument and -M to avoid setting up
a partial mirror within the image.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>faiserver# fai-cd -M -S squash.img</code></pre>
</div></div>
<div class="paragraph"><p>Move this image to a directory from which it can be requested via http
(usually a directory served by the webserver)</p></div>
<div class="paragraph"><p>To now request the squashfs image, add the following to your kernel
command line, e.g. in your pxelinux configuration file for the client
with fai-chboot.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>root=live:http://faiserver/cskoeln/squash.img FAI_CONFIG_SRC=file:///var/lib/fai/config</code></pre>
</div></div>
<div class="paragraph"><p>Replace faiserver with the domain name or IP of the machine your
squash image is served from.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_otherdists_a_installing_other_distributions_using_a_debian_nfsroot"><a id="otherdists"></a>Installing other distributions using a Debian nfsroot</h3>
<div class="paragraph"><p>You can install all sorts of Linux distributions from a single Debian
nfsroot. Therefore you have to create a base.tar.xz of the distribution
you like to install and place it into the <code>basefiles</code> directory. Then
name it UBUNTU2204.tar.xz for example. An install client which belongs
to the class UBUNTU2204 then extracts this base file into its empty
file system. Additionally you have to adjust the <em>sources.list</em> or
similar configuration files which are needed for specifying the
location of the package repository.</p></div>
<div class="paragraph"><p>The tool <code>rinse(8)</code> is used for creating base files for distribution
like Rocky Linux, CentOS, openSUSE  or Fedora.
Some basefiles can be downloaded from
<a href="https://fai-project.org/download/basefiles/">https://fai-project.org/download/basefiles/</a>.</p></div>
<div class="paragraph"><p>The script <code>mk-basefile</code> in
<em>/usr/share/doc/fai-doc/examples/simple/basefiles/</em> helps creating
this base files.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_dirinstall_a_creating_chroot_and_virtualization_environments"><a id="dirinstall"></a>Creating chroot and virtualization environments</h3>
<div class="paragraph"><p>If you have to create some chroot environments, or a virtualization
environment where you neither can nor want to run a normal Debian
Installer in to get to a working system (for example, Xen guest
domains), there is the FAI action <em>dirinstall</em>.
By calling</p></div>
<div class="listingblock">
<div class="content">
<pre><code>faiserver# fai &lt;options&gt; dirinstall &lt;target-directory&gt;</code></pre>
</div></div>
<div class="paragraph"><p>and using either the option <em>-c &lt;classes&gt;</em> or <em>-N</em> you get a FAI
installation, without the partitioning action, right into the target
directory. The host name for the target installation can be specified
using <em>-u &lt;host-name&gt;</em></p></div>
<div class="paragraph"><p>This, for example, can be used to combine FAI with the tool
<em>xen-tools</em>, which helps you to build Xen guest domains. <em>xen-tools</em>
are very nice for generating configuration files and block devices for
new guests based on simple commands and/or configuration files, but
they can only assign one role per installation for customization.
FAI-users need and want more, as they are used to have the class
system.  They get them even in xen-tools installations, by using the
following code as a xen-tools role script:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>#!/bin/sh
TARGET=$1
CMD="fai -N  -v -u ${hostname} dirinstall $TARGET"
echo running $CMD
$CMD</code></pre>
</div></div>
<div class="paragraph"><p>Then, you should set the variable <em>install=0</em> in the config of
xen-tools for that host.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_softupdate_a_using_fai_for_updates"><a id="softupdate"></a>Using FAI for updates</h3>
<div class="paragraph"><p>FAI can also do updates of already running systems, without a
re-installation from scratch.
This is called softupdate. A FAI softupdate skips the tasks which are
not suitable for updating a running system, like partitioning the
hard disks and creating file systems. Instead, it only executes the
tasks for updating and installing software packages and calling the
customization scripts.</p></div>
<div class="paragraph"><p>To run a softupdate call:</p></div>
<div class="listingblock">
<div class="content">
<pre><code># fai -v -s nfs://faiserver/srv/fai/config softupdate</code></pre>
</div></div>
<div class="paragraph"><p>By default, a softupdate uses the list of classes defined during the
initial installation. Make sure to set the variable <code>$LOGSERVER</code> (done
in a <em>class/*.var</em> file) if FAI should save the log files to a remote
machine.</p></div>
<div class="paragraph"><p>It&#8217;s up to you, how to start a softupdate on a bigger number of hosts.
You may do the softupdate on a regular basis via cron or you can use tools
like <code>clusterssh(1)</code> to start a softupdate via a push on a list of
hosts.</p></div>
<div class="paragraph"><p>Keep in mind, that the customization scripts are run every time you do
a softupdate. That means, they have to be <strong>idempotent</strong> i.e. the result
of their operation should always produce the same result, even when
they run more than once.</p></div>
<div class="paragraph"><p>For example appending a line to a file must not done via this code:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ echo "some strings" &gt;&gt; /etc/fstab</code></pre>
</div></div>
<div class="paragraph"><p>Instead use the command <code>ainsl(1)</code> in a shell script or use cfengine&#8217;s
function <em>AppendIfNoSuchLine</em>.</p></div>
<div class="paragraph"><p>All commands in the customization script must be capable of modifying
the target file system wether it&#8217;s available in <em>/target</em> during the
initial installation or wether it&#8217;s the normal file system relative to
<em>/</em> during softupdate.</p></div>
<div class="paragraph"><p>Here are some variable that help writing these scripts:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<code>$target</code>
</dt>
<dd>
<p>
Points to the root directory of the client, which
is <em>/target</em> during installation and <em>/</em> during a softupdate.
</p>
</dd>
<dt class="hdlist1">
<code>$FAI_ROOT</code>
</dt>
<dd>
<p>
It&#8217;s the same value as <code>$target</code>. For historic reasons
we have both these variables in FAI.
</p>
</dd>
<dt class="hdlist1">
<code>$ROOTCMD</code>
</dt>
<dd>
<p>
In case of the installation this is an alias for <em>chroot $target</em> in case of
softupdate it&#8217;s just empty. You can prepend this to commands if you need to run a
command inside the clients target file system via chroot.
</p>
</dd>
<dt class="hdlist1">
<code>$FAI_ACTION</code>
</dt>
<dd>
<p>
If you need to call code depending on the FAI action performed, you
can use this variable. It contains the currently executed action:
<em>install</em>, <em>softupdate</em>, <em>dirinstall</em>, <em>sysinfo</em>, <em>inventory</em> or your
own defined action.
</p>
</dd>
</dl></div>
</div>
<div class="sect2">
<h3 id="_a_id_archcross_a_how_to_install_32_bit_os_from_a_64_bit_os"><a id="archcross"></a>How to install 32-bit OS from a 64-bit OS</h3>
<div class="paragraph"><p>To install a computer with a 32-bit OS, you need an i386 nfsroot.
Creating this 32-bit nfsroot on an install server running amd64 is
quite simple. Install and set up the FAI packages. Then copy your FAI
config files to a new subdirectory.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>faiserver# cp -a /etc/fai /etc/fai-i386</code></pre>
</div></div>
<div class="paragraph"><p>Edit the variable <code>$FAI_DEBOOTSTRAP_OPTS</code> in
<em>/etc/fai-i386/nfsroot.conf</em> and add the option <code>--arch
i386</code>. Also choose a different directory for your new nfsroot. Here
are the two lines after editing.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>NFSROOT=/srv/fai/nfsroot-i386
FAI_DEBOOTSTRAP_OPTS="--arch i386 --exclude=info --include=aptitude""</code></pre>
</div></div>
<div class="paragraph"><p>Now call fai-make-nfsroot which creates the 32-bit nfsroot in
<em>/srv/fai/nfsroot-i386</em></p></div>
<div class="listingblock">
<div class="content">
<pre><code>faiserver# fai-make-nfsroot -v -C/etc/fai-i386</code></pre>
</div></div>
<div class="paragraph"><p>Creating a partial mirror using <code>fai-mirror(1)</code> that is needed for
a bootable CD or USB stick is also possible on a different architecture.
You have to specify the architecture when calling fai-mirror.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ fai-mirror -m800 -B -a i386 -v -cDEFAULT,DEBIAN,FAIBASE,I386 /srv/mirror-i386</code></pre>
</div></div>
<div class="paragraph"><p>That&#8217;s all!</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_error_a_aborting_the_installation_when_an_error_occurs"><a id="error"></a>Aborting the installation when an error occurs</h3>
<div class="paragraph"><p>Every task and hook can call the function <code>task_error</code>
to send an error value to the installation. This error will appear in
the log file and can be shown in the <code>fai-monitor-gui(1)</code>.
The error value is also checked against the variable <code>$STOP_ON_ERROR</code>
which is set to 700 by default. If the error value
is greater than <code>$STOP_ON_ERROR</code>  the installation will stop
immediately. In a hook, just add a call like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>task_error &lt;value&gt;</code></pre>
</div></div>
<div class="paragraph"><p>It is comfortable to call task_error with $? as second parameter, for
e.g. if you want to set an error value of 123 use this</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;some command&gt;
task_error 123 $?</code></pre>
</div></div>
<div class="paragraph"><p>Then the task error is only set if the preceding command failed with
some error. The same syntax can be used by the scripts in the class
subdirectory ending in .sh.</p></div>
<div class="paragraph"><p>A special case are scripts inside the class/ subdirectory that does
not end in .sh. In those scripts you have to call task_error with 1 as
third parameter. As an example you can use those two variants for
setting the value to 123</p></div>
<div class="listingblock">
<div class="content">
<pre><code>task_error 123 $? 1</code></pre>
</div></div>
<div class="paragraph"><p>or</p></div>
<div class="listingblock">
<div class="content">
<pre><code>task_error 123 1 1</code></pre>
</div></div>
<div class="paragraph"><p>The latter command always sets the task error to 123 regardless of
the value of <code>$?</code>. If the error value is greater than <code>$STOP_ON_ERROR</code>,
the installation will abort immediately.</p></div>
<div class="paragraph"><p>The error values are grouped into four categories</p></div>
<div class="listingblock">
<div class="content">
<pre><code>normal or info messages:       1xx, 2xx
warnings:                      3xx, 4xx
minor errors:                  5xx, 6xx
errors:                        7xx, 8xx</code></pre>
</div></div>
<div class="paragraph"><p>The fai-monitor-gui has 4 different icons for these error categories.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_id_hints_a_various_hints_and_details"><a id="hints"></a>Various hints and details</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_a_id_tasks_a_the_list_of_tasks"><a id="tasks"></a>The list of tasks</h3>
<div class="paragraph"><p>Most tasks of the installation are defined as subroutines which are
defined in <em>/usr/lib/fai/subroutines</em> (e.g. <code>task_instsoft</code>).
Some are external shell scripts located in <em>/usr/lib/fai/</em>.
They are called via a superior subroutine called <em>task</em>.
This subroutine calls hooks if available and then calls the task (defined as
<em>task_&lt;name&gt;</em>). A task and its hooks can be
skipped on demand by using the command <em>skiptask()</em>.</p></div>
<div class="paragraph"><p>Now follows the description of all tasks, listed in the order
they are executed.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
confdir
</dt>
<dd>
<p>
The kernel appended parameters may define variables, the syslog daemon is
started. Network parameters are fetched from a DHCP
server and are stored in <code>boot.log</code>. The DNS resolver configuration file is created.
</p>
<div class="paragraph"><p>The location of the configuration space is defined by the variable
<code>$FAI_CONFIG_SRC</code>.</p></div>
<div class="paragraph"><p>After that, the file <em>$FAI/hooks/subroutines</em> is sourced if it
exists. Using this file, you can define your own subroutines or
override the definition of FAI&#8217;s subroutines.</p></div>
</dd>
<dt class="hdlist1">
setup
</dt>
<dd>
<p>
This task sets the system time, all <code>$FAI_FLAGS</code> are defined and two
additional virtual terminals are opened on demand. A secure shell
daemon is started on demand for remote logins.
</p>
</dd>
<dt class="hdlist1">
defclass
</dt>
<dd>
<p>
Calls <code>fai-class(1)</code> to define classes using scripts and files in
<em>$FAI/class</em> and classes from <em>/tmp/fai/additional-classes</em> and the
variable <code>$ADDCLASSES</code>. The list of all defined classes is stored in
the variable <code>$classes</code> and saved to <em>/tmp/fai/FAI_CLASSES</em>.
</p>
</dd>
<dt class="hdlist1">
defvar
</dt>
<dd>
<p>
Sources all files <em>$FAI/class/*.var</em> for every defined class. If a
hook has written some variable definitions to the file
<em>$LOGDIR/additional.var</em>, this file is also sourced.
</p>
</dd>
<dt class="hdlist1">
action
</dt>
<dd>
<p>
Depending on the value of <code>$FAI_ACTION</code> this subroutine decides which
action FAI should perform. The default available actions are:
<em>sysinfo</em>, <em>install</em>, <em>inventory</em>, <em>dirinstall</em> and <em>softupdate</em>.  If <code>$FAI_ACTION</code> has another
value, a user defined action is called if a file
<em>$FAI/hooks/$FAI_ACTION</em> exists. So you can easily define your own
actions.
</p>
</dd>
<dt class="hdlist1">
sysinfo
</dt>
<dd>
<p>
Called when no installation is performed but the action is
<em>sysinfo</em>. It shows information about the detected hardware and mounts
the local hard disks read only to <em>/target/<code>partitionname</code></em> or with
regard to a <em>fstab</em> file found inside a partition. Log files are
stored to the install server.
</p>
</dd>
<dt class="hdlist1">
inventory
</dt>
<dd>
<p>
A short list of system information is printed.
</p>
</dd>
<dt class="hdlist1">
install
</dt>
<dd>
<p>
This task controls the installation sequence. You will hear three
beeps before the installation starts. The major work is to call other
tasks and to save the output to <em>/tmp/fai/fai.log</em>. If you have any
problems during installation, look at all files in <em>/tmp/fai/</em>. You
can find examples of the log files
at <a href="https://fai-project.org/logs/">https://fai-project.org/logs/</a>.
</p>
</dd>
<dt class="hdlist1">
dirinstall
</dt>
<dd>
<p>
Install into a directory, not onto a local disk. Use this for creating
chroot environments.
</p>
</dd>
<dt class="hdlist1">
softupdate
</dt>
<dd>
<p>
This task, executed inside a running system via the <code>fai(8)</code> command
line interface, performs a softupdate.  See chapter <a href="#softupdate">[softupdate]</a> for
details.
</p>
</dd>
<dt class="hdlist1">
partition
</dt>
<dd>
<p>
Calls <code>setup-storage(8)</code> to partition the hard
disks and to create file systems. The task writes variable definitions
for the root and boot partition and device (<code>$ROOT_PARTITION,
$BOOT_PARTITION, $BOOT_DEVICE</code>) to <em>/tmp/fai/disk_var.sh</em> and creates
a <em>fstab</em> file for the new system.
</p>
</dd>
<dt class="hdlist1">
mountdisks
</dt>
<dd>
<p>
Mounts the created partitions according to the created
<em>/tmp/fai/fstab</em> file relative to <code>$FAI_ROOT</code>.
</p>
</dd>
<dt class="hdlist1">
extrbase
</dt>
<dd>
<p>
Extracts a minimal system after that a chroot can be made into it. By
default the base tar file <em>/var/tmp/base.tar.xz</em> will be
extracted. Also files matching a class name in <code>$FAI/basefiles/</code> are used for unpacking a
different tar file depending on classes defined. This can be used for
installing different Linux distributions than the one used for
creating the nfsroot. The default file <em>base.tar.xz</em> is a snapshot of a
basic Debian system created by <code>debootstrap(8)</code>.
This task uses the variable <code>FAI_BASEFILEURL</code> for fetching the base
file via FTP, HTTPS or HTTP if it&#8217;s defined.
</p>
</dd>
<dt class="hdlist1">
debconf
</dt>
<dd>
<p>
Calls <code>fai-debconf(1)</code> to set the values for the debconf preseeding database.
</p>
</dd>
<dt class="hdlist1">
repository
</dt>
<dd>
<p>
Prepare access to the package repository by preparing the apt
configuration. This can also add repository keys
in a class based manner from files like <em>CLASSNAME.gpg</em>
in the directory <em>package_config</em>.
</p>
</dd>
<dt class="hdlist1">
updatebase
</dt>
<dd>
<p>
Updates the base packages of the new system and updates the list of
available packages. It also fakes some commands (called diversions)
inside the new installed system using <code>dpkg-divert(8)</code>, so no daemons
will be started during the installation.
</p>
</dd>
<dt class="hdlist1">
instsoft
</dt>
<dd>
<p>
Installs the desired software packages using class files in
<em>$FAI/package_config/</em>.
</p>
</dd>
<dt class="hdlist1">
configure
</dt>
<dd>
<p>
Calls scripts in <em>$FAI/scripts/</em> and its subdirectories for every
defined class.
</p>
</dd>
<dt class="hdlist1">
tests
</dt>
<dd>
<p>
Calls test scripts in <em>$FAI/tests/</em> and its subdirectories for every
defined class.
</p>
</dd>
<dt class="hdlist1">
finish
</dt>
<dd>
<p>
Unmounts all file systems in the new installed system and removes
diversions of files using the command <code>fai-divert</code>.
</p>
</dd>
<dt class="hdlist1">
chboot
</dt>
<dd>
<p>
Changes the PXE configuration for a host on the install server which
indicates which PXELINUX configuration to load on the next boot from network
card via TFTP. Therefore the <code>fai-chboot(8)</code> command is executed
remotely on the install server.
</p>
</dd>
<dt class="hdlist1">
savelog
</dt>
<dd>
<p>
Saves log files to local disk and to the account <code>$LOGUSER</code> on
<code>$LOGSERVER</code> (defaults to the install server).
</p>
</dd>
<dt class="hdlist1">
faiend
</dt>
<dd>
<p>
Wait for background jobs to finish (e.g. emacs compiling lisp files)
and automatically reboots the install clients or waits for manual
input before reboot.
</p>
</dd>
</dl></div>
</div>
<div class="sect2">
<h3 id="_a_id_itests_a_automated_tests"><a id="itests"></a>Automated tests</h3>
<div class="paragraph"><p>After the customization scripts are executed, FAI will execute some
tests if available. Using these test, you can check for errors of the
installation. Test scripts are called via
<code>fai-do-scripts(1)</code> and should append its messages to
<em>$LOGDIR/test.log</em>. A Perl module including some useful subroutines
can be found in <em>Faitest.pm</em>. A test can also define a new class for
executing another tests during next boot via the variable
<code>$ADDCLASSES</code>.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_autodiscover_a_autodiscover"><a id="autodiscover"></a> Autodiscover</h3>
<div class="paragraph"><p>In FAI 5.0 we released a feature that allows clients to search for the
faiserver in their respective subnetwork. This lifts the necessity of
having to collect every client&#8217;s MAC address and configuring the DHCP
daemon.</p></div>
<div class="paragraph"><p>This is done by booting from a small FAI autodiscover bootmedium (CD,
USB, etc.), which can be created via the command:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>faiserver# fai-cd -A autodiscover.iso</code></pre>
</div></div>
<div class="paragraph"><p>The image is roughly 25MB in size and scans the  subnet  for
a  FAI server. By  default it shows a menu with all profiles available
in the configuration space in the same manner as the <em>menu</em> flag
does. From this menu, you can select the installation type you wish to
perform.</p></div>
<div class="paragraph"><p>For the clients to find the faiserver, the faiserver must run
fai-monitor.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_changeboot_a_changing_the_boot_device"><a id="changeboot"></a>Changing the boot device</h3>
<div class="paragraph"><p>Changing the boot sequence is normally done in the BIOS setup. But you
can&#8217;t change the BIOS from a running Linux system.</p></div>
<div class="paragraph"><p>So, the boot sequence of the BIOS will remain unchanged and
your computer should always boot first from its network card and the
second boot device should be the local disk. Then you can
change the boot device of the client by creating different PXELINUX
configurations. This will define if an installation
should be performed, or if the client should to boot from local
disk. This is done using <code>fai-chboot(8)</code>.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_debian_mirror_a_how_to_create_a_local_debian_mirror"><a id="debian-mirror"></a>How to create a local Debian mirror</h3>
<div class="paragraph"><p>The utility <code>mkdebmirror</code> <span class="footnote"><br />[You can find the script in
<em>/usr/share/doc/fai-doc/examples/utils/</em>]<br /></span> can be used for creating
your own local Debian mirror. This script uses <code>debmirror(1)</code>. A partial Debian mirror for amd64 architecture for
Debian 11 and 12 (aka bullseye and bookworm) without the source packages needs about
180GB of disk space.
Accessing the mirror via HTTP will be the
default way in most cases. To see more output from the script call
<code>mkdebmirror -v</code>. A root account is not necessary to create and
maintain the Debian mirror.</p></div>
<div class="paragraph"><p>To use HTTP access to the local Debian mirror, install a web server
and create a symlink to the local directory where your mirror is
located:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>faiserver# apt-get install apache2
faiserver# ln -s /files/scratch/debmirror /var/www/html/debmirror</code></pre>
</div></div>
<div class="paragraph"><p>Create a file <code>sources.list(5)</code> in <em>/etc/fai/apt</em> which gives access
to your Debian mirror. Also add the IP-address of the
HTTP server to the variable <code>$NFSROOT_ETC_HOSTS</code> in
<em>nfsroot.conf</em> if the install clients have no DNS resolving.</p></div>
</div>
<div class="sect2">
<h3 id="_small_hints">Small hints</h3>
<div class="ulist"><ul>
<li>
<p>
When using HTTP access to a Debian mirror, the local <em>/var</em> partition
on all install clients must be big enough to keep the downloaded
Debian packages. Do not try with less than 250 Mbytes unless you know
why. You can limit the number of packages installed at a time with the
variable <code>$MAXPACKAGES</code>.
</p>
</li>
<li>
<p>
You can remove the red logo on the install client by simply calling
<code>reset</code> once. If will also not appear if you create a file using this
command on the install server:
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content">
<pre><code>touch /srv/fai/nfsroot/.nocolorlogo</code></pre>
</div></div>
<div class="ulist"><ul>
<li>
<p>
A list of variables used by FAI can be found at
<a href="https://wiki.fai-project.org/index.php/Variables">https://wiki.fai-project.org/index.php/Variables</a>.
</p>
</li>
<li>
<p>
You can shorten some customization scripts by using one single fcopy
command <em>fcopy -r /</em>.
</p>
</li>
<li>
<p>
If you rebuild the nfsroot, you will create a new ssh host key inside
the nfsroot. Then logging in to an install client may fail, because
the host key changes. You can use this:
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content">
<pre><code>$ ssh -o StrictHostKeyChecking=no root@installclient</code></pre>
</div></div>
<div class="ulist"><ul>
<li>
<p>
You can also delete the host entry on your install client in your
<em>~/.ssh/known_hosts</em> file by using the <em>ssh-keygen -R</em> command.
</p>
</li>
<li>
<p>
In the tasks chboot and savelog, a connection using secure shell is
opened to the FAI server (see <a href="#isavelog">[isavelog]</a>). To ensure that this works
non-interactively, a proper entry in <em>NFSROOT/root/.ssh/known_hosts</em>
must be created. When using fai-setup, this is done automatically, but
it may require manual editing in case the name of your FAI server was
not determined correctly.  If you stumble over ssh connections that
require typing "yes" to accept the host key during installation,
please check the contents of your <em>NFSROOT/root/.ssh/known_hosts file</em>
</p>
</li>
<li>
<p>
A list of all local hard disks is
stored in <code>$disklist</code>. It&#8217;s defined after <code>set_disk_info</code> is called.
</p>
</li>
<li>
<p>
There are multiple functions for generating a customized disk
list. See <code>fai-disk-info</code> for an example.
</p>
<div class="ulist"><ul>
<li>
<p>
set_bootstick()
</p>
</li>
<li>
<p>
grepv_disks()
</p>
</li>
<li>
<p>
grep_disks()
</p>
</li>
<li>
<p>
notmatchdisks()
</p>
</li>
<li>
<p>
matchdisks()
</p>
</li>
<li>
<p>
smallestdisk()
</p>
</li>
<li>
<p>
largestdisk()
</p>
</li>
<li>
<p>
all_disks_by_size()
</p>
</li>
<li>
<p>
all_disks_and_size()
</p>
</li>
<li>
<p>
once_only()
</p>
</li>
<li>
<p>
checkdisk()
</p>
</li>
<li>
<p>
disks_by_id()
</p>
</li>
</ul></div>
</li>
<li>
<p>
Use <code>fai-divert -a</code> if a postinst script calls a configuration
program, e.g. the postinst script for package apache calls
apacheconfig, which needs manual input. You can fake the configuration
program so the installation can be fully automatic.
</p>
</li>
<li>
<p>
Sometimes the installation seems to stop, but often there&#8217;s only a
postinstall script of a software package that requires manual input
from the console. Change to another virtual terminal and look which
process is running with tools like <code>top(1)</code> and <code>pstree(1)</code>. You can
add <em>debug</em> to <em>FAI_FLAGS</em> to make the installation process show all
output from the postinst scripts on the console and get its input also
from the console.
</p>
</li>
<li>
<p>
How can I define classes on the kernel command line?
</p>
<div class="paragraph"><p>Read the man page of <code>fai-class(8)</code>. If you like to define some
additional classes (for e.g. A,B,C) on the kernel command line add this: <em>ADDCLASSES=A,B,C</em></p></div>
</li>
<li>
<p>
How to use a custom kernel inside the nfsroot?
</p>
<div class="paragraph"><p>Build your customized kernel by building a kernel package using
<code>make-kpkg(8)</code> and use the option <code>--initrd</code>. Copy this Debian package
to a local repository and add it to /etc/fai/sources.list. Add the
name of your package to /etc/fai/NFSROOT. Then call</p></div>
<div class="listingblock">
<div class="content">
<pre><code># fai-make-nfsroot -k</code></pre>
</div></div>
</li>
<li>
<p>
How to use the nfsroot as system for diskless clients?
</p>
<div class="paragraph"><p><a href="https://wiki.fai-project.org/index.php/Use_nfsroot_for_diskless_clients">https://wiki.fai-project.org/index.php/Use_nfsroot_for_diskless_clients</a></p></div>
</li>
<li>
<p>
How to serve multiple nfsroot directories on one FAI server?
</p>
<div class="paragraph"><p>If you want to serve multiple nfsroot directories,
you need to create specific config directories in <em>/etc</em> for FAI, like
<em>/etc/fai-buster</em> and <em>/etc/fai-bookworm</em>. Then you need to set the
<code>$NFSROOT</code> variables to different directories and run</p></div>
</li>
</ul></div>
<div class="listingblock">
<div class="content">
<pre><code>faiserver#fai-make-nfsroot -C /etc/fai-buster</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_flag_reboot_fai_flags">flag_reboot (FAI_FLAGS)</h3>
<div class="paragraph"><p>If flag_reboot is set, by adding "reboot" to <code>$FAI_FLAGS</code>, your client
machine will reboot after the task faiend has finished. This is true
for network as well as bootmedium installations.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_logfiles_a_log_files"><a id="logfiles"></a>Log files</h3>
<div class="paragraph"><p>FAI is creating several log files. During installation they are stored
in <em>/tmp/fai</em> on the install client itself. At the end of the
installation they will be copied to the install server (see
<a href="#isavelog">[isavelog]</a>). After the install client rebooted into his newly
installed system, you can find the FAI logs in <em>/var/log/fai</em>.
Log files are also created when doing the softupdate or dirinstall
action.</p></div>
<div class="paragraph"><p>On the faiserver, you can find the (remote) log files under the ~fai
directory.</p></div>
<div class="paragraph"><p>Sample log files from successfully installed computers are
available on <a href="https://fai-project.org/logs">https://fai-project.org/logs</a>.
These a some log files which are created by FAI.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
FAI_CLASSES
</dt>
<dd>
<p>
Contains a list of all classes defined.
</p>
</dd>
<dt class="hdlist1">
dmesg.log
</dt>
<dd>
<p>
Output of the <code>dmesg</code> command. Contains useful messages of the kernel
ring buffer.
</p>
</dd>
<dt class="hdlist1">
fai.log
</dt>
<dd>
<p>
The main log file. Contains all important information. You should
<strong>always</strong> read this file.
</p>
</dd>
<dt class="hdlist1">
boot.log
</dt>
<dd>
<p>
A list of variables of network parameters, mostly defined by the DHCP daemon.
</p>
</dd>
<dt class="hdlist1">
format.log
</dt>
<dd>
<p>
Output of the partition tool <code>setup-storage(8)</code>.
</p>
</dd>
<dt class="hdlist1">
scripts.log
</dt>
<dd>
<p>
Output of all scripts, that are used for customization.
</p>
</dd>
<dt class="hdlist1">
variables.log
</dt>
<dd>
<p>
A list of all shell variables which are available during an
installation.
</p>
</dd>
<dt class="hdlist1">
error.log
</dt>
<dd>
<p>
A summary of possible errors in all log files.
</p>
</dd>
<dt class="hdlist1">
disk_var.sh
</dt>
<dd>
<p>
A list of variables that contain information about devices and
partitions to boot from, the root partition and a list of swap
devices. These information is used by some customization scripts
(e.g. <em>GRUB_PC/10-setup</em>).
</p>
</dd>
</dl></div>
<div class="paragraph"><p>If the installation process finishes, the hook <em>savelog.LAST.sh</em>
searches all log files for common errors and writes them to the file
<em>error.log</em>. So, you should first look into this file for errors. Also
the file <em>status.log</em> give you the exit code of the last command
executed in a script. To be sure, you should look for more details in
all log files.</p></div>
</div>
<div class="sect2">
<h3 id="_how_to_use_http_for_pxe_boot">How to use HTTP for PXE boot</h3>
<div class="paragraph"><p>fai-make-nfsroot now uses the lpxelinux.0 binary which already
supports transfer of the kernel and initrd via http (additional to tftp).
You only have to enable HTTP access to the tftp directory:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>cd /var/www/html
ln -s /srv/tftp/fai</code></pre>
</div></div>
<div class="paragraph"><p>Add <em>-U URL</em> to the <em>fai-chboot</em> call. For example:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>fai-chboot -U http://faiserver/fai -IFv .......</code></pre>
</div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_id_troubleshoot_a_troubleshooting"><a id="troubleshoot"></a>Troubleshooting</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_a_id_booterror_a_boot_errors"><a id="booterror"></a>Boot errors</h3>
<div class="paragraph"><p>The following error message indicates that your install client doesn&#8217;t
get an answer from a DHCP server. Check your cables or start the
<code>dhcpd(8)</code> daemon with the debug flag enabled.</p></div>
<div class="quoteblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre><code>PXE-E51: No DHCP or BOOTP offers received
Network boot aborted</code></pre>
</div></div>
</div>
<div class="attribution">
</div></div>
<div class="paragraph"><p>If you do not see the following message, the install kernel could not
detect your network card, for example because of a missing driver:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Starting dhcp for interface eth0
dhcp: PREINIT eth0 up
dhcp: BOND setting eth</code></pre>
</div></div>
<div class="paragraph"><p>Check the initrd in the nfsroot (<code>lsinird</code>) if the kernel driver of your network
card is included there and check if you like to add the package
<em>firmware-linux-nonfree</em> in <code>/etc/fai/NFSROOT</code> and rebuild the initrd
by calling <code>fai-make-nfsroot -k</code>.
You may also add a driver to <code>/srv/fai/nfsroot/etc/dracut.conf</code> in
the line <code>add_drivers</code>+<code>=</code>.</p></div>
<div class="paragraph"><p>This is the error message you will see, when your network card is
working, but the install server does not export the nfsroot
directory to the install clients, This is often caused by missing
NFS permissions on the server side.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Starting dhcp for interface eth0
dhcp: PREINIT eth0 up
dhcp: BOND setting eth
mount.nfs: access denied by server while mounting 192.168.33.250:/srv/fai/nfsroot
.
.
dracut Warning: Could not boot
.
Dropping to debug shell
dracut:/#</code></pre>
</div></div>
<div class="paragraph"><p>Now, you are inside the emergency shell of the initrd which was created
by <em>dracut(8)</em>. You will get a shell prompt, and can look at the log files.
For more information about debugging the early boot process using
dracut see <code>dracut.cmdline(7)</code></p></div>
<div class="paragraph"><p>Use the following command on the install server to see which directories are exported
from the install server (named faiserver):</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ showmount -e faiserver</code></pre>
</div></div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Version 6.4<br />
Last updated
 2025-10-23 10:47:54 CEST
</div>
</div>
</body>
</html>
