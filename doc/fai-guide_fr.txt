////
  -*- Doc -*-
////

FAI Guide (Fully Automatic Installation)
========================================
Thomas Lange <lange@debian.org>
Mer. 10 Avr 2025
:Date: une date
:Revision: 6.4

:nfsrootsize: 1.1

////
<tt>  => _
path <file => ''
<var> => +
<prgn> =>` ` (comme manref)
<em>  => _
////

Une version plus ancienne de ce guide en français est disponible à
https://fai-project.org/fai-guide-fr.

Résumé
------
FAI est un système non-interactif pour installer, configurer et gérer des
systèmes Linux et les configurations de logiciels sur des ordinateurs comme sur des machines
virtuelles et des environnements chroot, depuis des petits réseaux jusqu'à de
grandes infrastructures et de grands clusters.

Ce manuel décrit le logiciel Fully Automatic Installation (installation entièrement automatique).
Cela inclut l’installation des paquets, la configuration du serveur, la
création de la configuration et la gestion des erreurs.


(c) 2000-2025 Thomas Lange


Ce manuel est un logiciel libre; Vous pouvez le redistribuer et / ou le
modifier selon les termes de la Licence Publique Générale GNU publiée
par la Free Software Foundation; Soit la version 2, soit (à votre choix)
toute version ultérieure.

Ceci est distribué dans l’espoir qu’il sera utile, mais sans aucune
garantie ; Sans même la garantie implicite de qualité marchande ou
d’adaptation à un usage particulier. Pour plus de détails, consultez la
License Générale Publique GNU.

Une copie de la Licence Générale Publique GNU est disponible sous la forme
/usr/share/common-licenses/GPL dans la distribution Debian GNU/Linux ou
sur le World Wide Web sur le site GNU Vous pouvez également l’obtenir en
écrivant à la Free Software Foundation , Inc., 59 Temple Place - Suite
330, Boston, MA 02111-1307, États-Unis.

<<<


== [[introduction]]Introduction

=== [[availability]]Disponibilité


Page d'accueil::
https://fai-project.org

Wiki FAI::
https://wiki.fai-project.org

Téléchargement::
https://fai-project.org/download

Entrée pour 'sources.list'::
`deb https://fai-project.org/download bookworm koeln`

Pages de manuel::
https://fai-project.org/doc/man/

Listes de diffusion::
https://lists.uni-koeln.de/mailman/listinfo/linux-fai

Retour d'information::
Envoyez vos réflexions et vos commentaires à mailto:fai@fai-project.org[] ou
à la liste de diffusion.

Boguess::
Utiliser le système de suivi des bogues Debian (BTS) https://bugs.debian.org/src:fai

Changements visibles par l’utilisateur::
http://fai-project.org/NEWS

Arbre source via git::
git clone git://github.com/faiproject/fai.git

Voir l’arbre source avec https::
  https://github.com/faiproject/fai


Les pages man incluent toujours des informations à jour et beaucoup de
détails sur toutes les commandes FAI. Alors, n’oubliez pas de les lire
attentivement. Lisez maintenant ce manuel, puis profitez de
l’installation entièrement automatique et de votre temps économisé.

=== [[motivation]]Motivation

Avez-vous déjà effectué des installations identiques d’un système
d’exploitation à plusieurs reprises? Souhaitez-vous être en mesure
d’installer un cluster Linux avec des dizaines de nœuds d'un seul coup?

Répéter la même tâche encore et encore est ennuyeux -- et conduira
certainement à des erreurs. Aussi beaucoup de temps pourrait être sauvé
si les installations étaient faites automatiquement. Un processus
d’installation avec interaction manuelle ne peut pas passer à l'échelle. Mais les
grappes (clusters) ont l’habitude de croître au fil des ans. Pensez à long terme
plutôt que de planifier seulement quelques mois dans l’avenir.

En 1999, j’ai dû effectuer une installation d’un cluster Linux avec un
serveur et 16 clients. Puisque j’ai eu beaucoup d’expérience en faisant
des installations automatiques des systèmes d’exploitation de Solaris
sur le matériel de SUN SPARC, l’idée de construire une installation
automatique pour Debian est née. Solaris dispose d’une fonctionnalité
d’installation automatique appelée JumpStart
footnote:[Solaris 8 Advanced Installation Guide at "https://docs.oracle.com/cd/E19455-01/806-0957/806-0957.pdf].
En conjonction avec les scripts d’auto-installation de Casper Dik
footnote:[http://www.science.uva.nl/pub/solaris/auto-install],
Je pouvais épargner beaucoup de temps non seulement pour chaque nouvel
ordinateur de SUN, mais aussi pour la réinstallation des postes de
travail existants. Par exemple, j’ai dû construire un LAN temporaire
avec quatre stations de travail SUN pour une conférence, qui a duré
seulement quelques jours. J’ai retiré ces postes de travail de notre
réseau de recherche habituel et mis en place une nouvelle installation
pour la conférence. Quand elle a été terminée, j’ai simplement réintégré les
postes de travail dans le réseau de recherche, redémarré une seule fois,
et après une demi-heure, tout était opérationnel comme avant. La
configuration de tous les postes de travail était exactement la même
qu’avant la conférence, car tout était effectué par le même processus
d’installation. J’ai également utilisé l’installation automatique pour
réinstaller un poste de travail après qu'un disque dur endommagé ait été
remplacé. Il m’a fallu deux semaines pour recevoir le nouveau disque
dur, mais seulement quelques minutes après l’installation du nouveau
disque, le poste de travail fonctionnait comme avant. Et c’est pourquoi
j’ai choisi d’adapter cette technique à un cluster de PC sous Linux.




=== [[work]]Comment fonctionne FAI

Le client d’installation qui sera installé à l’aide de FAI, est démarré
via une carte réseau ou à partir d’un CD ou d’une clé USB. Il obtient
une adresse IP et démarre un noyau Linux qui monte son système de
fichiers racine via NFS (nfsroot) du serveur d’installation. Une fois le
noyau démarré, le script de démarrage FAI exécute l’installation
automatique qui n’a pas besoin d’interaction. Tout d’abord, les disques
durs seront partitionnés, les systèmes de fichiers seront créés et des
paquets logiciels seront ensuite installés. Après cela, le nouveau système
d’exploitation installé est configuré selon vos besoins locaux en
utilisant quelques scripts. Enfin, le nouveau système d’exploitation
sera démarré à partir du disque local.

Les détails sur la façon d’installer l’ordinateur (la configuration)
sont stockés dans l’espace de configuration sur le serveur d’installation.
Les fichiers de configuration sont répartis entre des groupes
d’ordinateurs s’ils sont similaires, en utilisant le concept de classe.
Vous n’avez donc pas besoin de créer une configuration pour chaque
nouvel hôte. Ainsi, FAI est une méthode évolutive pour
installer un gros cluster avec un grand nombre de nœuds même si leur
configuration n’est pas identique.

FAI peut également être utilisé comme un système de sauvetage ou pour
l’inventaire matériel. Vous pouvez démarrer votre ordinateur, mais il
n’effectuera pas une installation. Au lieu de cela, il exécutera un
Debian GNU / Linux entièrement fonctionnel sans utiliser les disques
durs locaux. Ensuite, vous pouvez effectuer une connexion à distance et
sauvegarder ou restaurer une partition de disque, vérifier un système de
fichiers, inspecter le matériel ou effectuer toute autre tâche.


=== [[features]]Caractéristiques

* On peut faire une installation entièrement automatisée.
* Installation très rapide sans surveillance.
* Système flexible grâce à un concept de classe simple.
* Mise à jour des systèmes en cours d’exécution sans réinstallation.
* Images « Cloud » pour un environnement de virtualisation.
* Les hôtes peuvent démarrer à partir d’une carte réseau, d’un CD, d’une clé USB.
* Création simple d’une image ISO vive ou pour l'installation.
* Prise en charge  de PXE avec la méthode de démarrage DHCP.
* Support des systèmes de fichiers ReiserFS, ext3/ext4, btrfs et XFS.
* Support logiciel RAID et LVM. Support LUKS.
* Détection automatique du matériel.
* On peut déployer Debian, Ubuntu, Rocky Linux, CentOS, AlmaLinux, SuSE
* Possibilité de connexion à distance via ssh lors du processus d’installation.
* Toutes les configurations similaires sont partagées entre tous les les clients d’installation.
* Les fichiers journaux de toutes les installations sont enregistrés sur le serveur d’installation.
* Prise en charge des scripts Shell, Perl, Python, Ruby, expect et CFEngine lors de l'étape de personnalisation.
* Prise en charge de nombreux protocoles comme NFS, FTP, HTTP, git.
* Peut être utilisé comme un système de sauvetage et pour l’inventaire matériel.
* Prise en charge de clients sans disque.
* Prise en charge trans-architecture, par exemple pour des appareils embarqués (embedded devices).
* Ajoutez facilement vos propres fonctions via des hooks ou modifiez le comportement par défaut.
* Prise en charge du clonage de machines utilisant des images de disque.


=== La durée d'installation

La durée d’installation est déterminée par la quantité de logiciel et la
vitesse du disque dur. Voici quelques exemples de durée. Tous les
clients d’installation avaient une carte réseau 1Gbit installée.

[width="80%",cols="<4,^2,<3,>4,>2",options="header"]
|=================================================================
| CPU  |  RAM |   Disque    |   Logiciels installés  | durée
| i7-3770T 2.50GHz  |    8GB|    SSD    |   6 GB logiciel  | 8.5 min
| Core-i7 3.2GHz    |     6GB| SATA disk|   4.3GB logiciel |    7 min
| Core-i7 3.2GHz    |     6GB| SATA disk|  471 MB logiciel |    77sec
| Intel Core2 Duo   |     2GB| SATA disk|    3 GB logiciel |   14 min
|=================================================================




== [[impatient]]Quickstart - Pour l'utilisateur impatient

=== [[first]]Ma première installation

Sans plus tarder, cette section fournira une démonstration rapide et
facile d’une installation entièrement automatique à l’aide du CD FAI et
d’une machine virtuelle.

Il suffit de télécharger l' image ISO du CD à partir de
https://fai-project.org/fai-cd et de démarrer votre VM à l’aide de ce CD.
Vous verrez un menu grub où vous pouvez choisir parmi différents types
d’installation.

Cette installation s’exécutera sans serveur d’installation.
L’installation à partir du CD est identique à celle exécutée dans un
environnement réseau à l’aide du serveur d’installation FAI, et peut être aussi
effectuée à l'aide d'une clé USB sur un ordinateur physique.

On peut aussi créer soi-même une image FAI (installation entièrement automatique)
à la page web https://fai-project.org/FAIme sans avoir besoin d'installer
FAI sur son ordinateur.


=== [[cdserver]]Ma première installation à l'aide d'un serveur

Nous allons créer un réseau privé et lancer deux machines vituelles. L'une
deviendra votre propre serveur FAI, l'autre sera un client d'installation.

Si vous avez l’intention d’utiliser VMware ou VirtualBox, assurez-vous
que votre client utilise une connexion réseau pontée (bridged network).
On trouve une description détaillée dans le wiki FAI
footnote:[https://wiki.fai-project.org/index.php/VirtualBox_for_your_first_FAI_installation].
on ne peut pas utiliser des interfaces réseau pontées via le réseau sans
fil, car la plupart des cartes réseau WiFi ne prennent pas en charge
cette fonctionnalité.

Quand on utilise Qemu/KVM et le script `fai-kvm` on peut créer le réseau à l'aide de
la commande `fai-mk-network`. Il faut commencer par installer quelques paquets logiciels

----
# apt-get install qemu-system-gui qemu-kvm qemu-utils
----

La commande ci-dessous met en place un réseau privé avec un pont logiciel et plusieurs
TAPs réseau
footnote:[https://fr.wikipedia.org/wiki/TAP_r%C3%A9seau]
appartenant à l'utilisateur +<nom_d_utilisateur>+.
----
fai-mk-network <nom_d_utilisateur>
----

Après cela, vous pouvez utiliser fai-kvm (-h vous aidera) pour démarrer
des machines virtuelles en utilisant KVM qui sont connectés à ce réseau
privé. Faites attention. Par défaut, fai-kvm créera les images de disque
pour les machines virtuelles dans `+/tmp+`, qui est un disque RAM sur la plupart des
systèmes. Il n’y a aucun problème à créer une image de disque vide de
20G dans /tmp (même si cette partition est de 4 Go de taille), mais
alors que la VM écrit des données sur son disque, cela commencera à
consommer de l’espace dans `+/tmp+`.

Démarrez le premier hôte virtuel, qui deviendra le serveur FAI
footnote:[Cette installation utilisera environ 2GB d'espace dans +/tmp+.] :
----
fai-kvm -Vn -s20 -u 1 cd faicd64-small.iso
----

Dans le menu grub; sélectionnez +faiserver, using internal DHCP and a fixed IP+.
Cela va installer
un hôte appelé faiserver avec IP 192.168.33.250 qui contient tous les
logiciels nécessaires pour un serveur FAI. Il configurera également un
cache de paquets local (en utilisant apt-cacher-ng). Une fois
l’installation terminée, redémarrez la machine. Lors du premier
démarrage du nouveau système, il configurera automatiquement le nfsroot.
Cela peut prendre quelques minutes.

Après cela, vous pouvez démarrer des hôtes supplémentaires en utilisant
un démarrage réseau. Pour chaque nouvel hôte, vous devez utiliser une
valeur différente pour `+-u+`, qui sera utilisée pour générer des
adresses MAC différentes et utiliser des noms de fichier d’image de
disque différents.

----
fai-kvm -Vn -u 2 pxe
----

Ces clients d’installation vous montreront un menu, où vous pouvez
sélectionner le type d’installation que vous souhaitez effectuer. Si le
client d’installation ne trouve pas le serveur, c’est généralement parce
que fai-monitor n'y fonctionne plus. Cela peut se produire si vous
redémarrez le faiserver après l’installation. Pour remédier à cela,
exécutez simplement fai-monitor sur le faiserver et relancez le
démarrage du client.

Un autre client pourrait être lancé avec:
----
fai-kvm -Vn -u 3 pxe
----

Vous pouvez démarrer autant de machines dans le réseau que de TAPs réseau
disponibles. Toutes ces machines peuvent se
connecter à l’Internet extérieur, mais sont seulement accessibles à
partir de votre machine hôte.

== [[overview]]Vue d'ensemble et Concepts

FAI est un système non interactif permettant d’installer, de
personnaliser et de gérer les configurations de systèmes et de logiciels
Linux sur les ordinateurs ainsi que sur les machines virtuelles et les
environnements chroot, des petits réseaux aux grandes infrastructures et
clusters. Vous pouvez prendre un ou plusieurs PC vierges, mettre sous
tension et après quelques minutes, Linux est installé, configuré et
fonctionnel sur l’ensemble du cluster, sans aucune interaction nécessaire.
Ainsi, il s’agit d’une méthode évolutive pour installer et mettre à jour
un cluster sans surveillance impliquant peu d’efforts. FAI utilise
le système d’exploitation Linux et une collection de scripts shell et
Perl pour le processus d’installation. Les modifications apportées aux
fichiers de configuration du système d’exploitation peuvent être
effectuées par des scripts CFEngine, shell (bash et zsh), Perl, Python, Ruby et
expect.

Les personnes intéressées par FAI sont des administrateurs système qui doivent
installer Linux sur une ou même des centaines d’ordinateurs. Parce qu’il
s’agit d’un outil d’installation à usage général, il peut être utilisé
pour l’installation d’un cluster Beowulf, d’une ferme de rendu ou
d’un laboratoire Linux ou d’une salle de classe. De plus, des réseaux
Linux de grande envergure avec différents matériels ou différentes
exigences d’installation sont faciles à établir à l’aide de FAI. Mais
n’oubliez pas de planifier votre installation. Le chapitre
<<plan>> contient quelques conseils utiles à ce sujet.

=== [[terms]] Terminologie

Commençons par décrire quelques termes utilisés dans ce manuel.

Le serveur d'installation ::
Il fournit les services DHCP, TFTP et NFS ainsi que les données de
configuration pour tous les clients d’installation. Dans les exemples
de ce manuel, cet hôte s’appelle 'faiserver'. C'est l’hôte où le paquet
'faiserver' est installé.

Le client d'installation ::
Un hôte qui sera installé à l’aide de FAI et une configuration fournie
par le serveur d’installation. Aussi appelé client pour faire court. Dans
ce manuel, les hôtes d’exemple sont appelés demohost, xfcehost,
gnomehost … Cet ordinateur doit démarrer à partir de son interface
réseau à l’aide de PXE.

Espace de configuration::
Une structure de sous-répertoire contenant plusieurs fichiers. Ces
fichiers décrivent les détails de la manière dont l’installation des
clients sera effectuée. Toutes les données de configuration sont
stockées là. Il est également appelé _config space_ pour faire court. Il
comprend des informations sur :

* Organisation du disque dur dans un format similaire à fstab
* Systèmes de fichiers locaux, leurs types, points de montage et options de montage
* Paquets logiciels
* Disposition du clavier, fuseau horaire, configuration Xorg, systèmes de fichiers distants, comptes utilisateurs, imprimantes …

+
Le package _fai-doc_ inclut un exemple d’espace de configuration
incluant des exemples pour les hôtes utilisant l’environnement XFCE et
GNOME entre autres. En invoquant `fai-mk-configspace` on copie ces exemples vers
'/srv/fai/config'. Il est recommandé d'étudier ces fichiers de configuration et
ces scripts pour mieux comprendre comment FAI fonctionne.


nfsroot, NFS-Root ::
Un système de fichiers situé sur le serveur d’installation. Pendant le
processus d’installation, c’est le système de fichiers complet pour
les clients d’installation. Tous les clients partagent le même
nfsroot, qu’ils montent en lecture seule. Le nfsroot a besoin
d’environ {nfsrootsize}Go d’espace disque libre.

TFTP ::
Sert aux clients le fichier initrd et le noyau utilisés pour le processus
d’installation. Avec le système de fichiers servi par NFS, ces deux
composent un système d'exploitation temporaire dans lequel les installations sont
réalisées.

Classes FAI ::
Les classes sont des noms qui déterminent quel fichier de
configuration est sélectionné. Si un client appartient à la classe
WEBSERVER, il sera configuré en tant que serveur Web, la classe
DESKTOP pour, par exemple, déterminer les paquets logiciels qui seront
installés.

profil ::
Un profil FAI est juste une liste de classes FAI assignées à un nom de
profil, qui est étendu par une description de ce profil. C’est-à-dire
que l’on peut avoir deux profils "Webserver", l’un incluant la classe
APACHE, et un autre incluant la classe NGINX, pour ensuite installer la solution
de serveur web correspondante.

les tâches ::
L’installation d’un client se compose de plusieurs parties, appelées
tâches. Les tâches sont des sous-programmes prédéfinis qui effectuent
une certaine partie de la FAI. Les tâches FAI suivantes sont exécutées
au cours d’une installation sur les clients d’installation.

____
  confdir		# trouver l'espace de configuration
  setup			# quelques initialisations, lancement de sshd à la demande
  defclass		# définition des classes FAI
  defvar		# définition de variables
  action		# évaluer FAI_ACTION
  install		# Démarrer l'installation
  partition		# partitionner les disques durs, créer les systèmes de fichiers
  mountdisks		# monter les systèmes de fichiers
  extrbase		# extraire le fichier base.tar.xz
  debconf		# pré-ensemencer le deconf de Debian
  repository		# préparer l'accès aux dépôts de paquets
  updatebase		# mettre en place les outils de gestion de paquets et mettre les paquets à jour
  instsoft		# installer les paquets logiciels
  configure		# lancer les scripts de personnalisation
  finish		# faire un peu de ménage, afficher les statistiques d'installation
  tests			# appeler des tests s'il y en a
  chboot		# lancer fai-chboot sur le serveur d'installation
  savelog		# enregistrer les fichiers de journalisation localement et à distance
  faiend		# redémarrage de l'hôte, éjection du CD si nécessaire
____
____

Voilà des tâches qui sont exécutées seulement lorsqu’on fait une action différente

  dirinstall 	       # installer un environnement chroot
  softupdate	       # ne faire que la configuration du système
  sysinfo              # imprimer une information système détaillée
  inventory            # imprimer un inventaire court du matériel
____

Pour une description plus détaillée des _tâches_ , voir <<tasks>>.

Notez que vous n'êtes pas limité aux tâches FAI. Vous pouvez également
définir des programmes ou des scripts supplémentaires qui seront
exécutés à certaines occasions. On les appelle des _hooks_.

hooks::
Les Hooks sont des plugins, ils peuvent ajouter des fonctionnalités
supplémentaires au processus d’installation ou même remplacer des
tâches entières de FAI. Les Hooks sont expliqués en détail dans
<<hooks>>.

=== [[classc]]Le concept de classe

Les classes sont utilisées dans presque toutes les tâches de
l’installation. Les classes déterminent quels fichiers de configuration
choisir parmi une liste d’alternatives disponibles. Pour déterminer les
fichiers de configuration à utiliser, FAI recherche dans la liste des classes
définies et utilise tous les fichiers de configuration correspondant à
un nom de classe footnote:[on peut aussi seulement utiliser le fichier de configuration
qui a la priorité la plus élevée, comme l'ordre des classes définit une
priorité de la plus basse à la plus élevée dans la liste des classes.  ]. La boucle suivante
implémente cette fonction en pseudo-code shell :

----
for class in $all_classes; do
   if [ -r $config_dir/$class ]; then      # s'il exite un fichier nommé $class
      your_command $config_dir/$class      # invoquer une commande avec ce nom de fichier
      # sortir si on n'a besoin que du premier fichier qui convient
   fi
done
----

La beauté de ceci c'est qu'on peut ajouter
une nouvelle alternative de configuration et qu'elle sera automatiquement
utilisée par FAI sans modifier le code, si le fichier de configuration
utilise un nom de classe.

C’est parce que la boucle détecte automatiquement les nouveaux fichiers
de configuration qui doivent être utilisés. L’idée d’utiliser des
classes en général et d’utiliser certains fichiers correspondant à un
nom de classe pour une configuration est adoptée à partir des scripts
d’installation par Casper Dik pour Solaris. Cette technique s’est avérée
très utile et facile.

Vous pouvez regrouper plusieurs hôtes partageant les mêmes fichiers de
configuration en utilisant la même classe. Vous pouvez également diviser
l’ensemble des données de configuration pour tous les clients en
plusieurs classes et les utiliser comme des briques de lego et
construire la configuration entière pour un seul client en assemblant
les briques.


Si un client appartient à la classe _A_, on dit que la classe _A_
est définie pour ce client. Une classe n’a pas de valeur, elle est juste
définie ou indéfinie.

Les classes déterminent comment l’installation est effectuée. Par
exemple, un client d’installation peut être configuré pour obtenir le
bureau XFCE en y ajoutant simplement la classe _XFCE_ . Naturellement,
des configurations plus granulaires sont également possibles. Par
exemple, les classes peuvent décrire comment le disque dur doit être
partitionné, elles peuvent définir quels paquets logiciels seront
installés, ou quelles étapes de personnalisation seront exécutées.

Souvent, une configuration client est juste créée en modifiant ou en ajoutant
les classes auxquelles ce client appartient, ce qui rend
l’installation d’un nouveau client très facile. Ainsi, aucune
information supplémentaire ne doit être ajoutée à l’espace de
configuration si les classes existantes suffisent à vos besoins.

Comme vous pouvez le voir, les classes sont un pilier central de la
personnalisation de votre espace de configuration et de celui de
de votre client d'installation. Pour définir vos propres classes, reportez-vous à
<<defining classes>>.

== [[setup]]Configurer votre faiserver

Voici comment configurer le serveur d’installation en quelques minutes.
Les étapes suivantes sont nécessaires :

. Configurer le serveur d’installation
.. Installer les paquets de FAI
.. Créer le nfsroot
.. Copier les exemples dans l’espace de configuration
.. Configurer les démons réseau
.. Créer les configurations PXELINUX
. Démarrage et installation des clients


=== Installer les paquets FAI

* Installer la clé du dépôt de paquets du projet FAI.
* Ajouter l’URL du dépôt de paquets du projet FAI.
* Installer le paquet 'fai-quickstart' sur le serveur d'installation.

Utilisez ces commandes pour l'installation :

----
# wget -O /etc/apt/trusted.gpg.d/fai-project.gpg https://fai-project.org/download/2BF8D9FE074BCDE4.gpg
# echo "deb http://fai-project.org/download bookworm koeln" > /etc/apt/sources.list.d/fai.list
----

or

----
# apt install extrepo ; extrepo enable fai
----

et ensuite :
----
# apt-get update
# aptitude install fai-quickstart
----

Cela installera également les paquets pour les démons de serveur DHCP,
TFTP et NFS.

=== Créer le nfsroot

* Activez également le dépôt de paquets du projet FAI dans un
autre fichier _sources.list_ qui est utilisé lors de la construction du
nfsroot. Ensuite, activez l’utilisateur de journal pour FAI.
....
# sed -i -e 's/^#deb/deb/' /etc/fai/apt/sources.list
# sed -i -e 's/#LOGUSER/LOGUSER/' /etc/fai/fai.conf
....


* Par défaut, FAI utilise
http://httpredir.debian.org/ comme miroir
de paquets, qui va tenter de trouver un dépôt de paquets
rapide pour vous.
footnote:[Si vous voulez un miroir plus rapide, ajustez l'URL dans
_/etc/fai/apt/sources.list_ et +FAI_DEBOOTSTRAP+ dans
_/etc/fai/nfsroot.conf_ avant de lancer fai-setup.]
Ensuite, on peut lancer `fai-setup(8)`
footnote:[Cela invoque `fai-make-nfsroot(8)` en interne.]
Et vérifiez si tout s’est bien passé. Le fichier de journal est écrit dans
/var/log/fai/fai-setup.log.

----
# fai-setup -v
----


* Voilà quelques-unes des lignes que vous verrez à la fin de fai-setup.
Un exemple complet de 'fai-setup.log' est disponible sur la page web FAI
à  https://fai-project.org/logs/fai-setup.log.

----
FAI packages and related packages inside the nfsroot:
dracut             059-4
dracut-live        059-4
dracut-network     059-4
dracut-squash      059-4
fai-client         6.2
fai-nfsroot        6.2
fai-setup-storage  6.2
Waiting for background jobs to finish
fai-make-nfsroot finished properly.
Log file written to /var/log/fai/fai-make-nfsroot.log
Adding line to /etc/exports: /srv/fai/config 192.168.33.250/24(async,ro,no_subtree_check)
Adding line to /etc/exports: /srv/fai/nfsroot 192.168.33.250/24(async,ro,no_subtree_check,no_root_squash)
Reloading nfs-kernel-server configuration (via systemctl): nfs-kernel-server.service.

Your initial config space is now located in /srv/fai/config
Please don't forget to fill out the FAI questionnaire after you've finished your project with FAI.

FAI setup finished.
Log file written to /var/log/fai/fai-setup.log
----

* `fai-setup` a créé le LOGUSER, le nfsroot et a ajouté des lignes
supplémentaires à _/etc/exports_. Les sous-répertoires ajoutés à
_/etc/exports_ sont exportés via NFS v3, de sorte que tous les clients
d’installation dans le même sous-réseau peuvent les monter via NFS.


=== Création de l’espace de configuration

Installez les exemples simples dans l’espace de configuration
footnote:[Il n'est pas nécessaires que ces fichiers appartiennent au compte root.].

----
$ fai-mk-configspace
----

Ces exemples contiennent la configuration pour certains hôtes d’exemple.
Selon le nom d’hôte utilisé, votre ordinateur sera configuré comme suit :

demohost::
Une machine qui n’a besoin que d’un petit disque dur. Cette machine
est configurée avec le réseau en tant que client DHCP, et une démo de
compte est créée.

xfcehost::
Un bureau XFCE est installé, utilisant LVM, et la démo du compte est
créée.

gnomehost::
  Un bureau GNOME est installé et la démo du compte est créée.

ubuntuhost::\n"
Un bureau Ubuntu sera installé et la démo du compte est créée.

autres noms d'hôtes::
Les hôtes disposant d’un autre nom d’hôte utiliseront notamment les
classes FAIBASE, DHCPC et GRUB.

Tous les hôtes auront un compte appelé _demo_ avec mot de passe _fai_. Le
compte root a également le mot de passe _fai_.

Si l’indicateur FAI +menu+ est ajouté, au lieu d’utiliser le nom
d’hôte pour déterminer le type d’installation, un menu est présenté et
l’utilisateur peut choisir un profil pour l’installation.

=== Configurer les démons réseau

Pour démarrer le client d’installation via PXE, le serveur
d’installation a besoin d’un démon DHCP et d’un démon TFTP fonctionnels.
Le paquet _fai-quickstart_ a déjà installé les paquets logiciels
pour ces démons. En outre, le paquet du serveur NFS pour
l’exportation du nfsroot et de l’espace de configuration a été installé.


==== [[bootdhcp]]Configuration du démon DHCP

Idéalement, votre faiserver doit également être votre serveur DHCP. Si ce
n’est pas le cas, demandez à l’administrateur responsable du serveur
DHCP de le configurer conformément à cette section. Il est
possible d'éviter cela optionnellement en utilisant la fonctionnalité
<<autodiscover>> diffusée dans FAI 5.0.


Un exemple pour `dhcpd.conf(5)` est fourni avec le paquet _fai-doc_.
Commencez à utiliser cet exemple et regardez toutes les options qui y
sont utilisées.

----
# cp /usr/share/doc/fai-doc/examples/etc/dhcpd.conf /etc/dhcp/
----

Les seules informations spécifiques FAI contenues dans ce fichier de
configuration sont d'assigner +filename+ (DHCP option 67) à la valeur +fai/pxelinux.0+ et
d'assigner +next-server+ (DHCP option 66, also aussi nommée TFTP server name) et +server-name+
à la valeur du nom de votre serveur d’install . Toutes les autres informations sont uniquement des
données liées au réseau, qui sont utilisées dans presque toutes les
configurations DHCP. Ajustez ces paramètres de réseau à vos besoins locaux.

----
deny unknown-clients;
option dhcp-max-message-size 2048;
use-host-decl-names on;

subnet 192.168.33.0 netmask 255.255.255.0 {
   option routers 192.168.33.250;
   option domain-name "my.example";
   option domain-name-servers 192.168.33.250;
   option time-servers faiserver;
   option ntp-servers faiserver;
   server-name faiserver;
   next-server faiserver;
   filename "fai/pxelinux.0";
}
----

Si vous apportez des modifications à la configuration DHCP, vous devez
redémarrer le démon.

----
# invoke-rc.d isc-dhcp-server restart
----

Si vous disposez de plusieurs interfaces réseau, vous pouvez définir
l’interface que le serveur écoutera dans _/etc/default/isc-dhcp-server_.
Par défaut, le démon DHCP écrit ses messages de journalisation dans
_/var/log/daemon.log_.


==== Ajout d’une entrée d’hôte au DHCP

L’adresse MAC est donnée par le matériel de la carte réseau. Pour chaque
client d’installation, vous collectez son adresse MAC et l'associez à une
adresse IP et à un nom d’hôte. Tout d’abord, nous ajoutons l’adresse IP
et le nom d’hôte à _/etc/hosts_ footnote:[On peut aussi ajouter cela dans son serveur de noms de domaine (DNS)].
----
192.168.33.100    demohost
----

L'association de l’adresse MAC à l’adresse IP est effectuée dans le fichier
_dhcpd.conf_. Ici, nous ajoutons une entrée d’hôte en utilisant la
commande `+dhcp-edit(8)+` . Ici, vous devez remplacer 01:02:03:AB:CD:EF
avec l'adresse MAC que vous avez trouvé.
----
# dhcp-edit demohost 01:02:03:AB:CD:EF
----

Après l'invocation de cette commande, voici à quoi l'entrée d'hôte dans
_dhcpd.conf_ ressemblera :
----
host demohost {hardware ethernet 01:02:03:AB:CD:EF;fixed-address demohost;}
----


==== TFTP

Normalement, vous n’avez pas besoin d’apporter de modifications à la
configuration démon TFTP. Les fichiers fournis par TFTP sont situés
dans _/srv/tftp/fai_.


==== NFS

La commande `fai-setup` a déjà configuré le démon NFS et ajouté
quelques lignes au fichier de configuration _/etc/exports_. Il exporte
les répertoires en utilisant NFS v3.

=== Création de la configuration PXELINUX

La dernière étape avant de démarrer votre client pour la première fois
est de spécifier quelle configuration le client doit démarrer lors de
l’amorçage PXE. Nous utilisons la commande `fai-chboot(8)` pour
créer une configuration pxelinux pour chaque client d’installation. Cela
comprend des informations sur le noyau, le fichier initrd, l’espace de
configuration et certains paramètres d’amorçage. Vous devriez lire la
page de manuel, qui vous donne quelques bons exemples. Voici la commande
pour démarrer l’installation de l’hôte demohost.

----
$ fai-chboot -IFv -u nfs://faiserver/srv/fai/config demohost

Booting kernel vmlinuz-4.19.0-5-amd64
 append initrd=initrd.img-4.19.0-5-amd64 ip=dhcp
   FAI_FLAGS=verbose,sshd,createvt FAI_CONFIG_SRC=nfs://faiserver/srv/fai/config

demohost has 192.168.33.100 in hex C0A82164
Writing file /srv/tftp/fai/pxelinux.cfg/C0A82164 for demohost
----

À ce stade, vous devriez avoir une configuration faiserver de travail et
vos clients devraient démarrer dans FAI et être en mesure d’installer
l’un des exemples.

Dans la section suivante, vous pouvez lire la planification de votre
installation, adapter votre espace de configuration à vos besoins
particuliers et étendre FAI à l’aide de hooks.

=== [[custom server]]Serveur personnalisé

Le faiserver et sa configuration n’est nullement statique. Il est possible
de personnaliser et d'étendre votre serveur. Pour cela, reportez-vous à
la section<<Customizing your install server setup>> dans <<advanced>>."

== [[plan]]Planifiez votre installation

Avant de commencer votre installation, vous devriez investir beaucoup de
temps dans la planification de votre installation. Une fois que vous
êtes satisfait de votre concept d’installation, FAI peut faire toutes
les tâches ennuyeuses et répétitives pour transformer vos plans en
réalité. FAI ne peut pas faire de bonnes installations si votre concept
est imparfait ou qu'il y manque quelques détails importants. Commencez à
planifier l’installation en répondant aux questions suivantes :


* Est-ce que je vais créer un cluster Beowulf ou dois-je installer des machines de bureau ?
* À quoi ressemble ma topologie LAN ?
* Ai-je un matériel uniforme ? Le matériel sera-t-il uniforme à l’avenir ?
* Le matériel a-t-il besoin d’un noyau spécial ?
* Comment nommer les hôtes ?
* Comment les disques durs locaux doivent-ils être partitionnés ?
* Quelles applications seront lancées par les utilisateurs ?
* Les utilisateurs ont-ils besoin d’un système de mise en file d’attente ?
* Quels logiciels faut-il installer ?
* Quels démons devraient être lancés, et à quoi devrait ressembler leur configuration ?
* Quels systèmes de fichiers distants doivent être montés ?
* Comment effectuer les sauvegardes ?

Vous devez également penser à des comptes d’utilisateur, des
imprimantes, un système de courrier, des travaux de cron, des cartes
graphiques, au double amorçage, au NIS, au NTP, au fuseau horaire,
à la disposition de clavier, à l’exportation et au montage des annuaires via
NFS et à beaucoup d’autres choses. Donc, il ya beaucoup à faire avant de
commencer une installation. Et rappelez-vous que la connaissance est le
pouvoir, et c’est à vous de l’utiliser. L’installation et
l’administration sont un processus et non un produit. FAI ne peut pas
faire les choses que vous ne lui dites pas de faire.

Mais vous ne devez pas commencer à partir de zéro. Examinez les fichiers
et les scripts dans l’espace de configuration. Il ya beaucoup de choses
que vous pouvez utiliser pour votre propre installation. Un bon article
intitulé « Bootstrapping an Infrastructure » avec d’autres aspects de la
construction d’une infrastructure est disponible sur
http://www.infrastructures.org/papers/bootstrap/bootstrap.html

=== [[c3]]L’espace de configuration et ses sous-répertoires

The configuration space is the collection of information about how exactly
to install a client. The central configuration space for all install
clients is located on the install server in '/srv/fai/config' and its
subdirectories. This will be mounted by the install clients to
'/var/lib/fai/config'. The main installation command `fai(8)` uses all
these subdirectories in the order listed except for hooks.

_class/_::
Scripts et fichiers pour définir des classes et des variables.

_disk_config/_::
Fichiers de configuration pour le partitionnement de disque, RAID
logiciel, LVM et création de système de fichiers.

_basefiles/_::
Normalement , le fichier 'base.tar.xz' (situé à l'intérieur du
nfsroot) est extrait sur le client d’installation après la création
des nouveaux systèmes de fichiers et avant l’installation des paquets.
Il s’agit d’une image de base minimale, créée juste après avoir appelé
debootstrap lors de la création du nfsroot sur le serveur
d’installation. Si vous voulez installer une autre distribution que celle
du nfsroot, vous pouvez mettre un fichier tar dans le sous-répertoire
'basefiles/' et le nommer selon une classe. Ensuite, la commande
`ftar(8)` est utilisée pour extraire le fichier tar en fonction des
classes définies. Ainsi, le fichier doit être nommé 'CLASS.tar.xz'
et non 'CLASS.base.tar.xz'. Cela se fait dans la tâche _extrbase_.
Utilisez cette option si vous souhaitez installer une autre
distribution ou une version différente de celle exécutée pendant
l’installation.
+
Ce fichier de base peut également être reçu en fonction des classes
FAI via HTTP/HTTPS ou FTP en définissant la variable +FAI_BASEFILEURL+. FAI
téléchargera un fichier CLASSNAME.tar.xz (ou tgz, ou tar.gz, …) à
partir de cette URL, si +CLASSNAME+ correspond à une classe FAI.
+
Exemple :
----
FAI_BASEFILEURL=https://fai-project.org/download/basefiles/
----
Le dossier doit prendre en charge la liste des répertoires. FAI ne
recherchera pas de fichiers potentiellement correspondants.

Voir le chapitre <<otherdists>> pour savoir comment
installer différentes distributions.

_debconf/_::
Ce répertoire contient toutes les données `debconf(7)`. Le format
est le même que celui utilisé par `debconf-set-selections(1)`.

_package_config/_::
Les fichiers avec des noms de classe contiennent des listes de
paquets à installer ou à désinstaller par
`install_packages(8)`. Les fichiers nommés '<CLASS>.gpg' sont ajoutés à la liste des clés utilisées par apt
pour les dépôts de paquets approuvés.

_pkgs/_::
Ce répertoire peut avoir des sous-répertoires nommés selon des classes. Vous pouvez
mettre des fichiers '.deb' ou '.rpm' dans ces sous-répertoires. FAI installera
ces paquets sans qu'il soit besoin de créer les métadonnées d'un dépôt de paquets.

_scripts/_::
Scripts pour la personnalisation de votre site local. Utilisé par
`fai-do-scripts(1)`.

_files/_::
Les Fichiers utilisés par les scripts de personnalisation. La plupart
des fichiers se trouvent dans un sous-répertoire qui
reflète l’arborescence de répertoires ordinaire. Par exemple, les
modèles de `_nsswitch.conf_` se trouvent dans
'$FAI/files/etc/nsswitch.conf' et sont nommés en fonction des classes
auxquelles ils doivent correspondre :
'$FAI/files/etc/nsswitch.conf/NIS' est la version de
'/etc/nsswitch.conf' à utiliser pour la classe NIS. Notez que le
contenu du répertoire n’est pas automatiquement copié sur la machine
cible, mais qu’il doit être explicitement copié par des scripts de
personnalisation à l’aide de la commande `fcopy(8)`.

_hooks/_::
Les hooks sont des programmes ou des scripts définis par
l’utilisateur, qui sont lancés pendant le processus d’installation.
Ils peuvent étendre ou remplacer les tâches par défaut. Le nom du
fichier doit être de format 'taskname.CLASSNAME[.sh]'. Un hook appelé
+updatebase.DEBIAN+ est exécuté avant la tâche
`updatebase` et seulement si l’installation du client fait partie de
la classe DEBIAN.


=== [[defining classes]]Définition des classes

Il existe différentes possibilités pour définir des classes :

. Certaines classes par défaut sont définies pour chaque hôte : DEFAULT, LAST et son nom d’hôte.
. Les classes peuvent être répertoriées dans un fichier (par défaut dans 'class/<hostname>').
. Les classes peuvent être dynamiquement définies par des scripts.

La dernière option est une fonctionnalité très intéressante, puisque ces
scripts définiront des classes d'une façon très souple. Par exemple,
plusieurs classes peuvent être définies uniquement si certains matériels
sont identifiés ou si une classe est définie en fonction des
informations du sous-réseau.

Tous les noms de classes, sauf le nom d’hôte, sont écrits en
majuscules. Ils ne doivent pas contenir de trait d’union, de dièse, de
point-virgule ni de point, mais peuvent contenir des caractères de
soulignement et des chiffres.

La tâche _defclass_ appelle la commande `fai-class(1)` pour définir
les classes. Tous les scripts correspondant à l'expression _^[0-9][0-9]*_ (qui
commencent avec deux chiffres) Dans le sous-repertoire _$FAI/class_ sont
exécutés afin de définir les classes. Tout ce qui is affiché sur STDOUT
est automatiquement defini comme une classe. Pour plus d’informations
sur Les définitions de classe , lire les pages de manuel de
`fai-class(1)`. Le script _50-host-classes_ (voir ci - dessous la
version allégée) est utilisé pour les définir des classes en fonction du
nom d’hôte.

----
# use a list of classes for our demo machines
case $HOSTNAME in
    demohost)
        echo "FAIBASE GRUB DEMO" ;;
    xfcehost)
        echo "FAIBASE GRUB DEMO XORG XFCE LVM";;
    faiserver)
        echo "FAIBASE DEBIAN DEMO FAISERVER" ;;
    ubuntuhost)
        echo "FAIBASE DEBIAN DEMO UBUNTU JAMMY JAMMY64 XORG";;
    *)
        echo "FAIBASE DEBIAN DEMO" ;;
esac
----

Les noms d’hôtes doivent rarement être utilisé pour les fichiers de
configuration dans l’espace de configuration. Au lieu de ça, une classe doit
être définie et ensuite ajoutée pour un hôte donné. En effet, la plupart
du temps les données de configuration ne sont pas spécifiques à un nom
d'hôte, mais peuvent être partagées entre différents hôtes.

L’ordre des classes est important car celui-ci définit la priorité des
classes de faible à élevée.

=== [[classvariables]]Définition des Variables

La tâche _defvar_ definit les variables pour le client d'installation.
Les variables sont définies par les scripts dans _class/*.var_.
Toutes les variables globales peuvent être définies dans 'DEFAULT.var'.
Pour un groupe d’hôtes utiliser un fichier de classe. Pour un
hôte seul, utiliser le Fichier +$HOSTNAME+ _.var_. Ici aussi, il est
utile d'étudier tous les exemples.

Les variables suivantes sont utilisées dans les exemples et peuvent aussi être
utiles pour votre installation :

FAI_ACTION::
Set the action FAI should perform. Normally this is done by
`fai-chboot(8)`. If you can't use this command, define this variable
i.e. in the script 'LAST.var'.

FAI_ALLOW_UNSIGNED::
Si cette variable vaut 1, FAI permet l’installation de paquets à partir de
dépôts non signés.

CONSOLEFONT::
La police de caractères qui est chargée lors de l’installation par
`setfont(8)`.

KEYMAP::
Définit les fichiers de disposition du clavier dans '/usr/share/keymaps'
et '$FAI/files'. Vous n'avez pas besoin de spécifier le chemin complet,
car ce fichier sera localisé automatiquement.

ROOTPW::
Le mot de passe root chiffré pour le nouveau système. Vous pouvez
utiliser
`crypt(3)`, md5 et d’autres types de hachage pour le mot de passe. Utilisez 'mkpasswd(1)+`
pour créer le hachage d’un mot de passe donné. Par exemple, pour
générer le hachage MD5 un mot de passe, utilisez :
....
$ echo "votre_mot_secret" | mkpasswd -m yescrypt -s
....


UTC::
Règle l’horloge matérielle à UTC si _UTC=yes_. Sinon, règle
l’horloge à l’heure locale. Voir `clock(8)` pour plus
d’informations.

TIMEZONE::
C'est le fichier sous '/usr/share/zoneinfo/' qui indique votre
fuseau horaire. Par exemple : _TIMEZONE=Europe/Berlin_.


MODULESLIST::
Une liste des modules du noyau qui sont chargés pendant le démarrage
du nouveau système (écrits dans /etc/modules).


=== [[diskconfig]]Configuration du disque dur

L’outil `setup-storage(8)` lit un fichier dans '$FAI/disk_config' pour
la configuration du disque. Ce fichier décrit comment tous les disques
Locaux seront partitionnés, quels types de systèmes de fichiers
doivent etre créés (comme ext3/4, xfs, btrfs), et où ils seront montés.
Vous pouvez aussi créer des configurations RAID logiciel et LVM en
utilisant ce fichier de configuration. Il est aussi possible de préserver
le partitionnement du disque ou de préserver les
données sur certaines partitions.

Pendant le processus d’installation, tous les systèmes de fichiers
locaux sont montés sous le répertoire '/target'. Par exemple, si vous
spécifiez le point de montage '/home' dans un fichier de configuration
de disque, ce sera le répertoire '/target/home' pendant le processus
d’installation et ça deviendra '/home' pour le nouveau système installé.

=== [[extrbase]]Extraction du fichier de base

Un fichier de base n'est nécessaire que si on installe une distribution qui est
défférente de celle dans le nfsroot.

=== [[debconf]]Pré-ensemencement Debconf

On peut utiliser le fomat décrit dans `debconf-set-selections(1)`.

=== [[repository]]Accès au dépôt de paquets

FAI supporte http, https, et NFS pour l'accès au miroir de paquets. Réglez
la variable '$FAI_DEBMIRROR' pour l'utilisation de NFS.


=== [[packageconfig]]Configuration des paquets logiciels

Avant l’installation de paquets, FAI va ajouter le contenu de tous
les fichiers nommés _package_config/class.gpg_ à la liste des clés apt.
Si votre dépôt local est signé par votre keyid AB12CD34 vous pouvez
facilement ajouter cette clé, ainsi FAI l’utilisera pendant
l’installation. Utilisez cette commande pour créer le fichier
'CLASS.gpg' :

----
faiserver$ gpg --export AB12CD34 > /srv/fai/config/package_config/MYCLASS.gpg
----


Le script `install_packages(8)` installe les logiciels sélectionnés.
Il lira tous les fichiers de configuration Dans '$FAI/package_config'
dont le nom correspond à une classe définie. La syntaxe est très simple.

----
# an example package class

PACKAGES taskinst
german

PACKAGES install-norec
adduser nmap
less zstd

PACKAGES remove
gpm xdm

PACKAGES install GRUB_PC
grub-pc
----

Les commentaires commencent par une dièse (#) et se terminent à la fin de la
ligne. Chaque commande de paquet commence par le mot _PACKAGES_ suivi
par un nom de commande, qui correspond à gestionnaire de paquets
distinct comme apt-get, aptitude ou dnf par exemple. la commande définit quelle
commande sera utilisé pour installer les paquets nommés après
cette commande. La liste de toutes les commandes disponibles peut
être listée en utilisant _install_packages -H_. Les gestionnaires de paquets pris
en charges sont _aptitude, apt-get, smart, yast, dnf, rpm, zypper_

hold::
Mettre un paquet en attente. Ce paquet ne sera pas pris en charge par
dpkg, pas exemple il ne sera pas mis à niveau.

install::
Pour installer tous les paquets (en utilisant `apt-get`) qui sont précisés
dans les lignes suivantes. Si un tiret est ajouté au nom du paquet
(sans espace intermédiaire), le paquet sera supprimé, pas installé.
Tous les noms de paquets sont vérifiées pour les fautes de frappe.
Tout paquet qui n’existe pas, sera retiré de la liste des paquets à
installer. Soyez donc attentif à ne pas mal orthographier les
noms de paquets.

install-norec::
Comme install, mais sans installer les paquets recommandés.

remove::
Supprimer tous les paquets qui sont pécisés dans les lignes suivantes.
Si on ajoute un + au nom du paquet, le paquet doit être installé.

taskinst::
Installer tous les paquets appartenant aux tâches qui sont spécifiées
dans les lignes suivantes à l’aide de `tasksel(1)`. Vous pouvez
aussi utiliser _aptitude_ pour installer les tâches.

aptitude::
Installer tous les paquets avec la commande `aptitude`. Ce sera la
valeur par défaut à l’avenir et pourra remplacer apt-get et taskinst.
Aptitude peut aussi installer les tâches de paquets.

aptitude-r::
Idem aptitude avec l’option _--with-recommends_.

unpack::
Télécharger les paquets et les décompresser seulement. Ne pas configurer les
paquets.

dselect-upgrade::
Definir des sélections des paquets en utilisant les lignes suivantes puis
installer ou supprimer les paquets précisés. Ces lignes sont le résultat
de la commande _dpkg --get-selections_. Il est recommandé de ne pas
utiliser ce format, puisque cela spécifie aussi tous les
paquets qui sont installés seulement en raison d’une dépendance ou
d'une recommandation. Il vaut mieux juste spécifier le paquet que vous
voulez avoir, et de laisser FAI (et apt-get) résoudre les dépendances.


Plusieurs lignes avec des listes de noms de paquets séparés par des
espaces suivent les directive PACKAGES. Toutes les dépendances sont
résolues. Les paquets avec suffixe _-_ (par exemple, _lilo-_) seront
supprimés au lieu d'être installés. L’ordre des paquet n’a pas
d’importance. Si vous souhaitez installer des paquets d’une autre
version que la valeur par défaut, vous pouvez ajouter le nom de la
version au nom du paquet comme dans _openoffice.org/etch-backports_.
Vous pouvez également spécifier une certaine version comme _apt=0.3.1_.
Plus d’informations sur ces fonctionnalités sont décrites dans
`aptitude(8)`.

On peut spécifier des paramètres supplémentaires pour le gestionnaire de paquets
en ajoutant des paires _cle=valeur_ après _PACKAGES <commande>_. les paires clé, valeur
actuellement supportées sont _release=<nom>_ qui ajoute _-t <nom>_ durant
l'installation des paquets.

Exemple:
----
PACKAGES install-norec release=testing
nvidia-smi
----

Cela installerait le paquet nvidia-smi  de la distribution testing,
en incluant les dépendances. N'oubliez pas d'ajouter une entrée dans
'sources.list'. Vous pouvez aussi vouloir ajuste l'épinglage apt (apt pinning)
(voir 'apt_references(5)')


Une ligne qui contient la commande _PRELOADRM_, télécharge un fichier à
l’aide de `wget(1)` dans un répertoire avant d’installer les paquets.
À l’aide d'une URL de type _file:_, ce fichier est copié de +$FAI_ROOT+ vers le
répertoire de téléchargement. Par exemple, le paquet `realplayer` a
besoin d’une archive pour installer le logiciel, donc cette archive est
téléchargée dans le répertoire '/root'. Après l’installation des
paquets, ce fichier sera supprimé. Si le fichier ne doit pas être
supprimé, utilisez plutôt la commande _PRELOAD_.


On peut ajouter une expression booléenne arbitraire qui utilise des classes FAI pour
définir quand la liste des paquets devrait être installée. Ici, les
paquets seront installés seulement si la classe XORG est définie mais la classe
MINT n'est pas définie.

Exemple:
----
PACKAGES install UBUNTU && XORG && ! MINT
ubuntu-standard
ubuntu-desktop
----

L'ancienne façon d'ajouter des expressions logiques dans les lignes PACKAGES est encore valable :
Il est possible d'ajouter une liste de noms de classes après la commande pour
apt-get. Ainsi une telle commande _PACKAGES_ sera exécutée seulement au moins
une des classes correspondantes est définie (OU logique). On peut donc combiner
plusieurs petits fichiers dans le fichier DEFAULT.



Si vous souhaitez supprimer un nom de paquet d’une certaine classe
faisait partie de cette classe précédemment, vous ne devez pas supprimer le
nom du paquet classe, mais plutôt de lui ajouter un tiret (-). Cela
garantira que le paquet soit enlevé pendant une mise a jour sur des hôtes
qui étaient installés en utilisant l’ancienne définition de classe qui
comprenait ce nom de paquet.

Si vous spécifiez un paquet qui n’existe pas, ce paquet sera supprimé
automatiquement de la liste d’installation uniquement si la commande
_install_ est utilisée.

Le concept de priorité des classes permet à une classe de priorité plus élevée (qui
arrive plus tard dans la séquence des classes) d'écraser les sélections des
paquets de priorité plus basse. Pour que cela fonctionne correctement,
les classes de priorité plus élevée doivent utiliser les mêmes commandes _PACKAGES_ (par exemple
_PACKAGES install-norec_ au lieu de seulement _PACKAGES install_) que celles qu'utilisent
la classe qu'on essaie d'écraser. Cela est utile pour supprimer
l'installation d'un paquet, par exemple, pour éviter d'installer le paquet
'linuxlogo' installé par la classe FAIBASE :

----
# exemple montrant comment écraser :
#
# Dans FAIBASE il y a :
#    PACKAGES install-norec
#    linuxlogo
#
# On veut _ne pas_ installer linuxlogo, et il se trouve dans
# une section install-norec, donc il faut aussi utiliser install-norec.

PACKAGES install-norec
linuxlogo-
----

=== [[cscripts]]Scripts de personnalisation

La commande `fai-do-scripts(1)` est lancée pour exécuter tous les
scripts dans ce répertoire. Si un répertoire avec un nom de classe
existe, tous les scripts correspondant à l'expression _^[0-9][0-9]*_ sont exécutés
par ordre alphabétique. Il est donc possible d’utiliser des scripts de
différentes langages (shell, cfengine, Perl, Python, Ruby, expect,..)
pour une classe.

Ces scripts écrivent leur sortie standard dans scripts.log. Le fichier status.log
contient les noms de tous les scripts exécutés et leur statut de terminaison.

==== [[shell]]Scripts shell

La plupart des scripts sont des scripts Bourne shell. Les scripts shell
sont utiles si la tâche de configuration n'a besoin d'appeler que
quelques commandes shell ou créer un fichier à partir de zéro. Afin d'éviter
d'écrire beaucoup de scripts courts, il est possible d’utiliser la
commande `ifclass` pour tester si certaines classes sont définies.

----
ifclass -o A B C
----

Vérifie si l’une des classes A, B ou C est définie. L’utilisation de -a
(ET, AND logique) vérifie si toutes les classes d’une liste sont définies.
La commande 'ifclass C' vérifie si seule la classe C est définie.

Pour copier des fichiers avec des classes, utilisez la commande
`fcopy(8)`. Si vous voulez extraire une archive à l’aide de classes,
utilisez `ftar(8)`. Pour ajouter des lignes à un fichier de
configuration, utilisez `ainsl(1)` au lieu de simplement
+echo string >> filename+.


FAI prend également en charge les scripts 'zsh(1)' pendant la tâche de
personnalisation. Dans les scripts, la variable +$classes+ contient
une liste séparée par des espaces avec les noms de toutes les classes
définies.

==== [[cfengine]]Scripts cfengine

CFEngine dispose d’un riche ensemble de fonctions pour modifier les
fichiers de configuration existants, par exemple _LocateLineMatching,
ReplaceAll, InsertLine, AppendIfNoSuchLine, HashCommentLinesContaining_.
Mais il ne peut pas traiter les variables qui sont indéfinies. Si une
variable n’est pas définie, l’ensemble du script cfengine s’arrêtera.

On peut trouver plus d’informations dans la page de manuel
`cfengine(8)` ou sur la page d’accueil de cfengine
https://www.cfengine.com.


=== [[hooks]]Les hooks, les « crochets »

Les crochets (hooks) vous permettent de spécifier des fonctions ou des programmes
qui sont exécutés à certaines étapes du processus d’installation. Avant
qu’une tâche soit appelée, FAI recherche les crochets existants pour cette
tâche et les exécute. Comme on peut s’y attendre, les classes sont
également utilisées lors de l’appel de hooks. Les hooks sont exécutés
pour chaque classe définie. Il vous suffit de créer le hook avec le nom
de la classe désirée et il sera utilisé. Si plusieurs hooks pour une
tâche existent, ils sont appelés dans l’ordre défini par les classes. Si
_debug_ est inclus dans +$FAI_FLAG+ l’option _-d_ est passée à tous
les hooks, donc vous pouvez déboguer vos propres hooks. Si certaines
tâches par défaut doivent être ignorées, utilisez la sous-routine
_skiptask_ et une liste de tâches par défaut comme paramètres. Dans les
exemples fournis, les hooks de la classe CENTOS ignorent certaines
tâches spécifiques de Debian.

Le répertoire '$FAI/hooks/' contient tous les hooks. Un hook est un
fichier exécutable qui est nommé selon la tâche : 'taskname.CLASSNAME[.sh]'
(par exemple, 'repository.CENTOS' ou 'savelog.LAST.sh'). Le nom de tâche
spécifie quelle tâche précède l'exécution de ce hook, si la
classe spécifiée est définie pour le client d’installation.
Voir la section <<tasks>> pour une liste complète des tâches
par défaut qu'on peut utiliser.

Un hook du formulaire _hookprefix.classname_ ne peut pas définir de
variables pour le script d’installation, car il s’agit d’un
sous-processus. Mais vous pouvez utiliser n’importe quel exécutable
binaire ou n’importe quel script que vous avez écrit. Les hooks qui ont
le suffixe _.sh_ (par exemple, 'partition.DEFAULT.sh') doivent être des
scripts Bourne shell et sont sourcé. Il est donc possible de redéfinir
des variables pour les scripts d’installation.

Dans la première partie de FAI, tous les hooks avec le préfixe _confdir_
sont appelés. Ces hooks ne peuvent pas être localisés dans l’espace de
configuration, car il n’est pas encore disponible. Par conséquent, ces
hooks sont les seuls hooks situés dans +$nfsroot+'/$FAI/hooks' sur le
serveur d’installation. Tous les autres hooks se trouvent dans
'$FAI_CONFIGDIR/hooks' sur le serveur d’installation.


Tous les hooks appelés avant la définition des classes peuvent
utiliser uniquement les classes suivantes: _DEFAULT $HOSTNAME LAST_. Si un hook
pour la classe _DEFAULT_ doit être appelé uniquement dans le cas où aucun hook pour
la classe +$HOSTNAME+ n’est disponible, insérez ces lignes dans le hook
par défaut :

----
hookexample.DEFAULT:

#! /bin/sh

# sauter le hook DEFAULT s'il existe un hook pour $HOSTNAME
scriptname=$(basename $0 .DEFAULT)
[-f $FAI/hooks/$scriptname.$HOSTNAME ] && exit
# suivent alors les actions pour la classe DEFAULT
.
.
----

Quelques exemples de ce à quoi les hooks pourraient être utiles :

- Charger les modules du noyau avant que les classes soient définies dans '$FAI/class'.

- Envoyer un courriel à l’administrateur si l’installation est terminée.

- Installer un client sans disque et sautez le partitionnement de disque local.

- Jeter un œil à +hooks/debconf.IMAGE+ pour savoir comment cloner une machine en utilisant une image de système de fichiers.

=== [[faiflags]]Options (flags) de FAI

La variable +$FAI_FLAGS+ contient une liste d'options séparées par des
espaces. Les options sont normalement définies dans le fichier pxelinux.cfg qui
est censément créé par 'fai-chboot(1)'. Les options suivantes sont connues :

verbose::
Rend l'installation verbeuse. Cela doit toujours
être la première option (le premier flag), de sorte que les définitions suivantes des
options soient affichées verbeusement.

debug::
Afficher des informations de débogage. Aucune installation sans assistance
n’est effectuée. Pendant l’installation du paquet, vous devez répondre
à toutes les questions des scripts postinstall sur la console du
client. Beaucoup d’informations de débogage seront affichées. Cette option
n’est utile que pour les développeurs FAI.

sshd::
Démarrer le démon ssh pour activer les connexions à distance. Vous
pouvez ensuite vous connecter en tant que _root_ à tous les clients
d’installation pendant l’installation. Le mot de passe par défaut est
_fai_ et peut être modifié en définissant `FAI_ROOTPW` dans
`nfsroot.conf(5)`. Pour vous connecter à partir de votre serveur vers le
client d’installation (nommé demohost dans cet exemple), utilisez :

----
$ ssh root@demohost
Warning: Permanently added 'demohost,192.168.33.100' to the list of known hosts.
root@demohost's password:
----

Ce n’est le mot de passe root que pendant le processus d’installation,
pas pour le nouveau système installé. Vous pouvez également vous
connecter sans mot de passe lorsque vous utilisez +$SSH_IDENTITY+.


createvt::
Créez deux terminaux virtuels et exécutez un bash si _ctrl-c_ est tapé
dans le terminal de console. Vous pouvez accéder aux terminaux
supplémentaires en tapant _Alt-F2_ ou _Alt-F3_. Sinon, aucun terminal
n’est disponible et la saisie _ctrl-c_ va redémarrer le client
d’installation. La définition de cette option est utile pour le débogage.
Si vous voulez une installation qui ne soit pas interruptible,
ne définissez pas cette option.

menu::
Cela active un menu utilisateur pour sélectionner un profil. Tous les
fichiers +class/*.profile+ sont lus et un menu basé sur curses
sera créé.

screen::
Lancer FAI dans une session `screen(1)`. La session est nommée FAI.
Si on se connecte via ssh à distance on peut se rattacher à la session en utilisant :
----
$ screen -x
----

tmux::
Lancer FAI dans une session `tmux(1)`. La session est nommée FAI.
Si on se connecte via ssh à distance on peut se rattacher à la session en utilisant :
----
$ tmux attach
----

reboot::
Redémarrer le client d’installation une fois l’installation terminée
sans taper Entrée sur la console. Si cette option n’est pas définie, et
que error.log contient quelque chose, le client d’installation
s’arrêtera et attendra que vous appuyez sur Entrée. Si aucune erreur
ne s’est produite, le client redémarrera toujours
automatiquement.

halt::
Arrêter le client d’installation à la fin de l’installation, au lieu
de redémarrer dans le nouveau système.

initial::
Utilisé par `setup-storage(8)`. Les partitions marquées avec
+preserve_reinstall+ sont préservées à moins que cette option ne soit
définie. Souvent, cette option est définie dans un fichier 'class/*.var' en
utilisant le paramètre 'flag_initial=1'.

== [[install]] FAI installs your plan

=== The early part of an installation

After the kernel has booted, it mounts the root file system via NFS
from the install server and starts the script
'/usr/sbin/fai' footnote:[Since the root file system on the clients is mounted via
NFS, `fai` is located in
'/srv/fai/nfsroot/usr/sbin' on the install
server.]. This script controls the sequence of the
installation. No other scripts in '/etc/init.d/' are used.

The configuration space is made available via the configured method
(an NFS mount by default) from the install server to the path defined
in '$FAI' footnote:['$FAI' is an internal variable used by the FAI
scripts. By default the path is _/var/lib/fai/config_.]


=== [[bootmesg]]Boot messages

When booting the install client from network card with PXE you will see some
messages like this:
include::includes/bootexample.txt[]

At this point the install client has successfully received the network
config via DHCP and the kernel and initrd via TFTP. It now boots the
Linux kernel and the initrd. If everything went right, the initrd
mounts the nfsroot footnote:['/srv/fai/nfsroot' from the install
server via NFS] and the FAI scripts are started. The first
thing you see is the red FAI copyright message.

include::includes/fai-1st-part.txt[]

You can also see the list of FAI classes, that are defined for this
host. This list is very important for the rest of the installation.

The first task is called _confdir_, which is responsible for getting
access to the config space. Here, we use an NFS mount from the install
server as you can see on the console (and later in the logs).

----
FAI_CONFIG_SRC is set to nfs://faiserver/srv/fai/config
Configuration space faiserver:/srv/fai/config mounted to /var/lib/fai/config
----

Before the installation is started (+$FAI_ACTION=install+) the computer
beeps three times. So, be careful when you hear three beeps but you do
not want to perform an installation and let FAI erase all yout data on
the local disk!


=== [[reboot]]Rebooting the computer into the new system

For rebooting the computer during or at the end of the installation you
should use the command `faireboot` in favour of the normal reboot command.
Use `faireboot` also if logged in from remote. If the installation
hasn't finished, use _faireboot -s_, so the log files are also copied
to the install server.

If the installation has finished successfully, the computer should boot a
small Debian system. You can login as user _demo_ or _root_ with password _fai_.

=== [[isetup]]Starting FAI (task confdir)

After the install client has booted only the script '/usr/sbin/fai' is
executed. It will do some minimal initialization. The variable
+$FAI_CONFIG_SRC+ footnote:[It is defined on the kernel command line]
is used to get access to the FAI configuration space which is then
available in the directory +$FAI+ footnote:[/var/lib/fai/config]. FAI
will not proceed without the config space.

You can access the config space using different methods. Supported
methods are: nfs:, file:, cvs:, svn: git:, hg:, http: and detect:.
See `fai.conf(5)` for a detailed description of these methods.


=== [[iclass]]Defining classes and variables (tasks defclass and defvar)

The command `fai-class(1)` executes scripts in '$FAI/class' for defining
classes. If the scripts write a string to stdout, this will be defined
as a class. Read all the details in the man page of `fai-class(1)`.


After defining the classes, every file matching _.var_ with a prefix
which matches a defined class is sourced to define variables. It must
contain valid shell code.

=== [[ipartition]]Partitioning local disks, creating file systems (task partition)

For the disk partitioning exactly one disk configuration file from
'$FAI/disk_config' is selected using classes.

The format of the disk configuration is similar to a fstab file.

The partitioning tool `setup-storage(8)` performs all commands
necessary for creating the disk partition layout, software RAID, LVM
and for creating the file systems. Disks and partitions may easily be
referenced by disk1.1, disk2.4 etc. Read the manual page of
`setup-storage(8)` for a detailed description and some examples of the
format.


=== [[ipreseed]]Debconf preseeding (task debconf)
Files in '$FAI/debconf' are used for the usual `debconf(7)` preseeding
if the file names match a class name.

=== [[ipackages]]Installing software packages (task instsoft)

The command `install_packages(8)` reads the config files from
'$FAI/package_config' in a class based manner and installs software
packages on the new file system.

It installs the packages using `apt-get(8)`, `aptitude(1)`, `yum` or other
package tools without any manual interaction needed. Package
dependecies are also resolved by the package tools.

The format of the configuration files is described in <<packageconfig>>.

Additionaly FAI will install packages ('.deb' or .rpm') from the
directories '$FAI/pkgs/<CLASSNAME>'.


=== [[icscripts]]Site specific customization (task configure)

Often the default configurations of the software packages will not
meet your site-specific needs. You can call arbitrary scripts which
adjust the system configuration. Therefore the command
`fai-do-scripts(1)` executes scripts in '$FAI/scripts' in a class
based manner. It is possible to have several scripts of different
types (shell, cfengine, ...) to be executed for one class.

The default set of scripts in '$FAI/scripts' include examples for
installing Debian and Rocky Linux machines. They set the root password, add
a user account (set by '$username, default to demo), set the timezone, configure the network for DHCP
or using a fixed IP address, setup grub and more.
They should do a reasonable job for your installation. You can edit
them or add new scripts to match your local needs.

More information about these scripts are described in <<cscripts>>.


=== [[isavelog]]Saving log files (task savelog)

When all tasks are finished, the log files are written to
_/var/log/fai/$HOSTNAME/install/_
footnote:['/var/log/fai/localhost/install/' is a link to this
directory.] on the new system and to the account on the install server
if +$LOGUSER+ is defined (you have to enable this in
'/srv/fai/config/class/FAIBASE.var'). It is also possible to specify
another host as log saving destination through the variable
+$LOGSERVER+. If +$LOGSERVER+ is not defined, FAI uses the variable
+$SERVER+ which is only defined during an initial installation (by
get-boot-info).

Additionally, two symlinks will be created to indicated the last
directory written to. The symlink 'last' points to the log directory
of the last FAI action performed. The symlinks 'last-install' and
'last-sysinfo' point to the directory of the last corresponding
action. By default log files will be copied to the log
server using scp. You can use the variable +$FAI_LOGPROTO+ in file
'fai.conf(5)' to choose another method for saving logs to the remote
server. Here's an example of the symlink structure:

----
lrwxrwxrwx   1 fai fai   23 Dec  2  2013 last-sysinfo -> sysinfo-20131202_161237
drwxr-xr-x   2 fai fai 4096 Dec  2  2013 sysinfo-20131202_161237
drwxr-xr-x   2 fai fai 4096 Feb 14  2014 install-20140214_142150
drwxr-xr-x   2 fai fai 4096 Dec  2 11:47 install-20141202_113918
lrwxrwxrwx   1 fai fai   23 Dec  4 13:22 last-install -> install-20141204_131351
lrwxrwxrwx   1 fai fai   23 Dec  4 13:22 last -> install-20141204_131351
drwxr-xr-x   2 fai fai 4096 Dec  4 13:22 install-20141204_131351
----

Examples of the log files can be found at https://fai-project.org/logs.


=== [[ireboot]]Reboot the new installed system

Before rebooting, the install client calls `fai-chboot -d <hostname>`
on the install server, to disable its own PXELINUX
configuration. Otherwise, it would restart the installation during the
next boot. Normally this should boot the new installed system from
its second boot device, the local hard disk.

At the end, the system is automatically rebooted if "reboot" was added to
+$FAI_FLAGS+.



== [[advanced]]Advanced FAI topics


=== [[checkbootp]]Checking parameters received from DHCP servers

If the install client boots you can check
if all information from the DHCP daemon are received
correctly. The received information is written to
'/tmp/fai/boot.log'. An example of the result of a DHCP request can be
found in the sample log files.




=== [[fai-monitor]]Monitoring multiple client installations

You can monitor the installation of all install clients with the
command `fai-monitor(8)`. All clients check if this daemon is running
on the install server (or the machine defined by the variable
+$monserver+). Each time a task starts or ends, a message is sent. The
FAI monitor daemon prints this messages to standard output. There's
also a graphical frontend available, called `fai-monitor-gui(1)`.

----
$  fai-monitor | fai-monitor-gui - &
----


=== [[mac]]Collecting Ethernet addresses for multiple hosts

You have to collect all Ethernet (MAC) addresses of the install
clients and assign a host name and IP address to each client. To
collect the MAC addresses, boot your install clients.
You can already do this before any DHCP daemon is running in your
subnet. They will fail to boot (because of the missing DHCP or missing TFTP),
but you can still collect the MAC addresses.

While the install clients are booting, they send broadcast packets to the
LAN. You can log the MAC addresses of these hosts by running the
following command simultaneously on the server:

----
faiserver# tcpdump -qtel broadcast and port bootpc >/tmp/mac.list
----

After the hosts have been sent some broadcast packets abort `tcpdump`
by typing _ctrl-c_. You get a list of all
unique MAC addresses with these commands:

----
faiserver$ perl -ane 'print "\U$F[0]\n"' /tmp/mac.list|sort|uniq
----

After that, you only have to assign these MAC addresses to host names
and IP addresses ('/etc/ethers' and '/etc/hosts' or corresponding NIS
maps). With this information you can configure your `DHCP`
daemon (see the section <<bootdhcp>>). footnote:[I recommend to write the MAC
addresses (last three bytes will suffice if you have network cards
from the same vendor) and the host name in the front of each chassis.]


==== Debugging the network traffic

If the client can't successfully boot from the network card, use
`tcpdump(8)` to look for Ethernet packets between the install server
and the client. Search also for entries in several log files made by
`tftpd(8)` and `dhcpd(8)` :

----
faiserver$ egrep "tftpd|dhcpd" /var/log/*
----


=== [[pxeboot]]Details of PXE booting

Here we describe the details of PXE booting, which are only needed if
you have problems when booting your install clients.

Almost all modern bootable network cards support the PXE boot environment.
PXE is the Preboot Execution Environment.
This requires the PXELINUX bootloader and a special version of the _TFTP_
daemon, which is available in the Debian packages +pxelinux+ and
+tftpd-hpa+. PXE booting also needs a DHCP server, so that the network
card can configure its IP parameters. This is the sequence of a PXE boot:

* Network card of the client sends its MAC address
* DHCP server replies with IP configuration for the client
* Network card configures IP
* Install client gets the pxelinux.0 binary via TFTP
* Get the pxelinux.cfg/C0A8210C configuration file via TFTP
* C0A8210C is the IP address of the client in hexadecimal
* This configuration contains kernel, initrd and additional kernel
command line parameters, which was created by `fai-chboot`.
* Get the kernel and initrd via TFTP.


Example of a pxelinux.cfg file:
----
default fai-generated

label fai-generated
kernel vmlinuz-6.1.0-17-amd64
append initrd=initrd.img-6.1.0-17-amd64 ip=dhcp root=/srv/fai/nfsroot rootovl FAI_FLAGS=verbose,sshd,createvt FAI_CONFIG_SRC=nfs://faiserver/srv/fai/config FAI_ACTION=install
----

See '/usr/share/doc/syslinux/pxelinux.doc' for more detailed
information about PXELINUX. FAI uses the lpxelinux.0 binary which also
supports loading the kernel and initrd via FTP or HTTP. The command
'fai-chboot(8)' supports this with the option '-U'.


=== [[Customizing your install server setup]]Customizing your install server setup

- local/faster package mirror
- different loguser
- local root pw inside nfsroot

The configuration for the FAI package (not the configuration data for
the install clients) is defined in 'fai.conf(5)'. Definitions that are
only used for creating the nfsroot are located in
'nfsroot.conf(5)'. Check these important variables in 'nfsroot.conf'
before calling 'fai-setup' or 'fai-make-nfsroot'.

FAI_DEBOOTSTRAP::
Building the nfsroot uses the command `debootstrap(8)`. It needs the location of a Debian mirror and the
name of the distribution (like bullsseye, bookworm, sid) for which the basic Debian
system should be built. Do not use different distributions here and in
'/etc/fai/apt/sources.list'. This will create a broken nfsroot.

NFSROOT_ETC_HOSTS::
This variable is only needed if the clients do not have access to a DNS server.
This multiline variable is added to /etc/hosts inside the
nfsroot. Then the install clients can access those hosts by name
without using DNS.


The content of '/etc/fai/apt/sources.list' is
used by the install server and also by the clients. If your install
server has multiple network cards and different host names for each
card (as for a Beowulf server), use the install server name which is
known by the install clients.


If you have problems running `fai-setup`, they usually stem from
`fai-make-nfsroot(8)` which is called by former command. Adding '-v'
gives you a more verbose output which helps you pinpoint the
error. The output is written to
'/var/log/fai/fai-make-nfsroot.log'. footnote:[For debugging purpose
it may help to enter the chroot environment manually using this
command.  'faiserver# chroot /srv/fai/nfsroot bash']


The setup also creates the account _fai_ (defined by +$LOGUSER+) if
not already available. So you can add a user before calling
`fai-setup(8)` using the command `adduser(8)` and use this as your
local account for saving log files. The log files of all install
clients are saved to the home directory of this account. You should
change the primary group of this
account, so this account has write permissions to '/srv/tftp/fai' in
order to call fai-chboot for creating the PXE configuration for the hosts.


When you make changes to 'fai.conf', 'nfsroot.conf' the
nfsroot has to be rebuilt by calling `fai-make-nfsroot(8)`. If you
only like to install a new kernel package to the nfsroot add the flags _-k_ or
_-K_ to +fai-make-nfsroot+. This will not recreate your nfsroot, but
only updates your kernel and kernel modules inside the nfsroot or add
additional packages into the nfsroot.


=== [[cdboot]]Creating a FAI CD or and USB stick

You can easily create an installation CD (or USB stick) of your
network installation setup. This will perform the same installation
and configuration from CD without the need of the install server.
Therefore you need to create a partial mirror of all Debian packages
needed for your FAI classes (using `fai-mirror(1)`). Then the command
`fai-cd(8)` will put this mirror, the nfsroot and the config space
onto a bootable CD. That's it!

To easily create the installation CD, you can use the following command
(for more tuning details see `fai-cd(8)`):

----
 faiserver# fai-cd -m <partialMirrorDir> fai-cd.iso
----

This installation CD contains all data needed for the
installation. The command `fai-cd(8)` puts the nfsroot, the
configuration space and a subset of the Debian mirror onto a
CD-ROM. A partial package mirror is created using the command
`fai-mirror(1)` which contains all packages that are used by the
classes used in your configuration space.  A sample ISO image is
available at https://fai-project.org/fai-cd.

Using the command `dd(1)` you can also create a bootable USB
stick by just writing the content of the ISO file to your USB stick
(here the stick is _/dev/sdf_).

----
 faiserver# dd if=fai-cd.iso of=/dev/sdf bs=1M
----


`mk-data-partition` is a tool that extends an ISO (that will be copied
to an USB stick) or an USB stick containing an ISO with
an ext4 or exFAT partition and sets the file system label to MY-DATA.
This partition is automatically mounted to '/media/data' by FAI.
You can copy your own _.deb_ packages into this data partition und the
subdiretories 'pkgs/<CLASSNAME>'. FAI will then install these packages
if the equivalent class is defined.

Example how to use `mk-data-partition`:

----
# mk-data-partition -s 1G -c faicd-large.iso A B
----
The former command creates the data partition of size 1 Gbytes inside
the ISO file and copy directories A and B to it. You can then copy the modified ISO
onto an USB stick.


If the ISO is already on the USB stick and if it's available as
_dev/sdf_, you can add a data partition of type exFAT will will use
the whole remaining part of the USB stick by using this command:
----
# mk-data-partition -F /dev/sdf
----


=== [[diskimage]]Creating VM disk images using FAI

The command `fai-diskimage(8)` creates disk
images, which can be used with a virtual machine like KVM, VMware,
VirtualBox or a cloud service like OpenStack, GCE, EC2 and others. The
installation process performs the normal FAI tasks on a raw disk
image. After the installation you can boot the disk image and have a
running system. The disk image can also be converted to qcow2 format.
You do not need to setup the FAI nfsroot when only using
fai-diskimage. But you need a basefile in your configuration
space. Setting the variable +$FAI_BASEFILEURL+ will automatically
download an appropriate base file into your config space.


Here's an example how to create a raw disk image for a host called
cloud3, with a small set of software packages:
----
# export FAI_BASEFILEURL=https://fai-project.org/download/basefiles/
# fai-diskimage -vu cloud3 -S2G -cDEBIAN,BOOKWORM64,AMD64,FAIBASE,GRUB_PC,DHCPC,DEMO,CLOUD,LAST disk.raw
----

This command will create a disk image called ubuntu.qcow2 for a Ubuntu 16.04 desktop
with hostname set to foobar.
----
# export FAI_BASEFILEURL=https://fai-project.org/download/basefiles/
# cl=DHCPC,UBUNTU,JAMMY,JAMMY64,AMD64,XORG,LAST
# fai-diskimage -Nvu foobar -S5G -c$cl ubuntu.qcow2
----

You can give disk images a try without installing FAI, if you visit
https://fai-project.org/FAIme/cloud


=== [[live-image]]Creating a bootable live image

Creating a bootable live ISO is easy with FAI. You only need two
steps. First, create your live environment using the command 'fai
dirinstall'. Don't forget to add the class +LIVEISO+.
Then create the live ISO using 'fai-cd':

----
# cl="DEBIAN,BOOKWORM64,AMD64,FAIBASE,XFCE,XORG,DHCPC,DEMO,LIVEISO,LAST"
# LC_ALL=C fai -v dirinstall -u xfce33 -c $cl \
    -s file:///srv/fai/config /srv/xfce
# fai-cd -s500 -MH -d none -g /etc/fai/grub.cfg.live \
    -n /srv/xfce live.iso
----

The nfsroot is not needed for a live ISO.
Currently there's no live ISO of the install server available.


=== [[cross-arch]]Building cross-architecture disk images

Starting FAI 5.4 it's now possible to build a disk image for
different architectures than the host is running. For example you can
build an image for 64-bit ARM architecture (aarch64) on a host running on amd64
architecture. Here are the steps do to:

----
# apt install qemu-system-arm qemu-user-static fai-server fai-setup-storage fai-doc qemu-utils
# fai-mk-configspace

# export FAI_BASEFILEURL=https://fai-project.org/download/basefiles/
# fai-diskimage -vu armhost -S2G -cDEFAULT,DHCPC,DEBIAN,ARM64,BUSTER_ARM64,FAIBASE,DEMO,CLOUD,LAST arm64.raw
# chown your_user_id arm64.raw
# cp /var/log/fai/armhost/last/vmlinuz* vmlinuz
# cp /var/log/fai/armhost/last/initrd.img* initrd
----

Then you can run qemu as a normal user:
----
> qemu-system-aarch64 -m 1000 -M virt,gic_version=3 -cpu cortex-a57 -drive file=arm64.raw,if=virtio,index=1 -no-reboot -nographic -name ARM64 -net nic,name=eth0,model=virtio -net user,name=eth0,-kernel vmlinuz -initrd initrd -append "console=ttyAMA0 rw ip=dhcp root=/dev/vda1 net.ifnames=0"
----

This works similar for other architectures.
Keep in mind, that qemu network setup will have poor performance if
not using the virtio driver as above or tap devices.



You can find the base files for many architectures at
https://fai-project.org/download/basefiles/, or use `mk-basefile` to
create your own.


=== [[sysinfo]]FAI rescue system

If you set the variable +$FAI_ACTION+ to _sysinfo_ (for e.g. by using
+fai-chboot -S+), the client will not install a new system, but will
collect a lot of system information.
If you set +$FAI_ACTION+ to _inventory_ you will only get a few
hardware information.
Both actions can be used for FAI as a rescue system.

Type _ctrl-c_ to get a shell or use _Alt-F2_ or _Alt-F3_ and you will get
another console terminal, if you have added _createvt_ to +$FAI_FLAGS+.

You now have a running Linux system on the install client without
using the local hard disk. Use this as a rescue system if your local
disk is damaged or the computer can't boot properly from hard
disk. You will get a shell and you can execute various commands
(`dmesg`, `lsmod`, `df`, `lspci`, ...). Look at the log file in
'/tmp/fai'. There you can find much information about the boot
process.



FAI mounts all file systems it finds on the local disks read only. It
also tells you on which partition a file '/etc/fstab' exists. When
only one file system table is found, the partitions are mounted
according to this information. Here's an example:

----
demohost:~# df -h

Filesystem                Size  Used Avail Use% Mounted on
devtmpfs                  4.0M     0  4.0M   0% /dev
tmpfs                     2.0G     0  2.0G   0% /dev/shm
tmpfs                     783M   18M  766M   3% /run
tmpfs                     5.0M     0  5.0M   0% /run/lock
LiveOS_rootfs             783M   18M  766M   3% /
192.168.33.250:/srv/fai/config   59G   23G   24G  49% /var/lib/fai/config
/dev/mapper/vg1-root      7.3G  1.8G  5.2G  26% /target
/dev/vda1                 459M   53M  378M  13% /target/boot
/dev/mapper/vg1-home      1.4G   72K  1.3G   1% /target/home
----

*This method can be used as a rescue environment!* If you need a file
system with read-write access use the `rwmount` command:

----
demohost# rwmount /target/home
----

=== [[nonfs]]FAI without NFS

To boot into FAI and begin the installation sequence
without using the NFS protocol, you boot the client machine using PXE as
usual and then retrieve an image containing the nfsroot via http.

To create an image, use fai-cd's -S argument and -M to avoid setting up
a partial mirror within the image.

----
faiserver# fai-cd -M -S squash.img
----

Move this image to a directory from which it can be requested via http
(usually a directory served by the webserver)

To now request the squashfs image, add the following to your kernel
command line, e.g. in your pxelinux configuration file for the client
with fai-chboot.

----
root=live:http://faiserver/cskoeln/squash.img FAI_CONFIG_SRC=file:///var/lib/fai/config
----

Replace faiserver with the domain name or IP of the machine your
squash image is served from.


=== [[otherdists]]Installing other distributions using a Debian nfsroot

You can install all sorts of Linux distributions from a single Debian
nfsroot. Therefore you have to create a base.tar.xz of the distribution
you like to install and place it into the `basefiles` directory. Then
name it UBUNTU2204.tar.xz for example. An install client which belongs
to the class UBUNTU2204 then extracts this base file into its empty
file system. Additionally you have to adjust the 'sources.list' or
similar configuration files which are needed for specifying the
location of the package repository.

The tool `rinse(8)` is used for creating base files for distribution
like Rocky Linux, CentOS, openSUSE  or Fedora.
Some basefiles can be downloaded from
https://fai-project.org/download/basefiles/.

The script +mk-basefile+ in
'/usr/share/doc/fai-doc/examples/simple/basefiles/' helps creating
this base files.

=== [[dirinstall]]Creating chroot and virtualization environments

If you have to create some chroot environments, or a virtualization
environment where you neither can nor want to run a normal Debian
Installer in to get to a working system (for example, Xen guest
domains), there is the FAI action _dirinstall_.
By calling

----
faiserver# fai <options> dirinstall <target-directory>
----

and using either the option _-c <classes>_ or _-N_ you get a FAI
installation, without the partitioning action, right into the target
directory. The host name for the target installation can be specified
using _-u <host-name>_

This, for example, can be used to combine FAI with the tool
_xen-tools_, which helps you to build Xen guest domains. _xen-tools_
are very nice for generating configuration files and block devices for
new guests based on simple commands and/or configuration files, but
they can only assign one role per installation for customization.
FAI-users need and want more, as they are used to have the class
system.  They get them even in xen-tools installations, by using the
following code as a xen-tools role script:

----
#!/bin/sh
TARGET=$1
CMD="fai -N  -v -u ${hostname} dirinstall $TARGET"
echo running $CMD
$CMD
----

Then, you should set the variable _install=0_ in the config of
xen-tools for that host.

=== [[softupdate]]Using FAI for updates
FAI can also do updates of already running systems, without a
re-installation from scratch.
This is called softupdate. A FAI softupdate skips the tasks which are
not suitable for updating a running system, like partitioning the
hard disks and creating file systems. Instead, it only executes the
tasks for updating and installing software packages and calling the
customization scripts.

To run a softupdate call:
----
# fai -v -s nfs://faiserver/srv/fai/config softupdate
----

By default, a softupdate uses the list of classes defined during the
initial installation. Make sure to set the variable +$LOGSERVER+ (done
in a _class/*.var_ file) if FAI should save the log files to a remote
machine.


It's up to you, how to start a softupdate on a bigger number of hosts.
You may do the softupdate on a regular basis via cron or you can use tools
like `clusterssh(1)` to start a softupdate via a push on a list of
hosts.


Keep in mind, that the customization scripts are run every time you do
a softupdate. That means, they have to be *idempotent* i.e. the result
of their operation should always produce the same result, even when
they run more than once.

For example appending a line to a file must not done via this code:

----
$ echo "some strings" >> /etc/fstab
----
Instead use the command `ainsl(1)` in a shell script or use cfengine's
function _AppendIfNoSuchLine_.


All commands in the customization script must be capable of modifying
the target file system wether it's available in _/target_ during the
initial installation or wether it's the normal file system relative to
_/_ during softupdate.

Here are some variable that help writing these scripts:

+$target+:: Points to the root directory of the client, which
is _/target_ during installation and _/_ during a softupdate.

+$FAI_ROOT+:: It's the same value as +$target+. For historic reasons
we have both these variables in FAI.

+$ROOTCMD+::
In case of the installation this is an alias for 'chroot $target' in case of
softupdate it's just empty. You can prepend this to commands if you need to run a
command inside the clients target file system via chroot.


+$FAI_ACTION+::
If you need to call code depending on the FAI action performed, you
can use this variable. It contains the currently executed action:
_install_, _softupdate_, _dirinstall_, _sysinfo_, _inventory_ or your
own defined action.

=== [[archcross]]How to install 32-bit OS from a 64-bit OS

To install a computer with a 32-bit OS, you need an i386 nfsroot.
Creating this 32-bit nfsroot on an install server running amd64 is
quite simple. Install and set up the FAI packages. Then copy your FAI
config files to a new subdirectory.

----
faiserver# cp -a /etc/fai /etc/fai-i386
----

Edit the variable +$FAI_DEBOOTSTRAP_OPTS+ in
'/etc/fai-i386/nfsroot.conf' and add the option +--arch
i386+. Also choose a different directory for your new nfsroot. Here
are the two lines after editing.

----
NFSROOT=/srv/fai/nfsroot-i386
FAI_DEBOOTSTRAP_OPTS="--arch i386 --exclude=info --include=aptitude""
----

Now call fai-make-nfsroot which creates the 32-bit nfsroot in
'/srv/fai/nfsroot-i386'

----
faiserver# fai-make-nfsroot -v -C/etc/fai-i386
----

Creating a partial mirror using `fai-mirror(1)` that is needed for
a bootable CD or USB stick is also possible on a different architecture.
You have to specify the architecture when calling fai-mirror.

----
$ fai-mirror -m800 -B -a i386 -v -cDEFAULT,DEBIAN,FAIBASE,I386 /srv/mirror-i386
----

That's all!


=== [[error]]Aborting the installation when an error occurs

Every task and hook can call the function +task_error+
to send an error value to the installation. This error will appear in
the log file and can be shown in the `fai-monitor-gui(1)`.
The error value is also checked against the variable +$STOP_ON_ERROR+
which is set to 700 by default. If the error value
is greater than +$STOP_ON_ERROR+  the installation will stop
immediately. In a hook, just add a call like this:

----
task_error <value>
----

It is comfortable to call task_error with $? as second parameter, for
e.g. if you want to set an error value of 123 use this

----
<some command>
task_error 123 $?
----

Then the task error is only set if the preceding command failed with
some error. The same syntax can be used by the scripts in the class
subdirectory ending in .sh.

A special case are scripts inside the class/ subdirectory that does
not end in .sh. In those scripts you have to call task_error with 1 as
third parameter. As an example you can use those two variants for
setting the value to 123

----
task_error 123 $? 1
----

or

----
task_error 123 1 1
----

The latter command always sets the task error to 123 regardless of
the value of +$?+. If the error value is greater than +$STOP_ON_ERROR+,
the installation will abort immediately.

The error values are grouped into four categories

----
normal or info messages:       1xx, 2xx
warnings:                      3xx, 4xx
minor errors:                  5xx, 6xx
errors:                        7xx, 8xx
----

The fai-monitor-gui has 4 different icons for these error categories.


== [[hints]]Various hints and details


=== [[tasks]]The list of tasks

Most tasks of the installation are defined as subroutines which are
defined in '/usr/lib/fai/subroutines' (e.g. +task_instsoft+).
Some are external shell scripts located in '/usr/lib/fai/'.
They are called via a superior subroutine called _task_.
This subroutine calls hooks if available and then calls the task (defined as
__task_<name>__). A task and its hooks can be
skipped on demand by using the command _skiptask()_.

Now follows the description of all tasks, listed in the order
they are executed.


confdir::
The kernel appended parameters may define variables, the syslog daemon is
started. Network parameters are fetched from a DHCP
server and are stored in +boot.log+. The DNS resolver configuration file is created.
+
The location of the configuration space is defined by the variable
+$FAI_CONFIG_SRC+.
+
After that, the file '$FAI/hooks/subroutines' is sourced if it
exists. Using this file, you can define your own subroutines or
override the definition of FAI's subroutines.


setup::
This task sets the system time, all +$FAI_FLAGS+ are defined and two
additional virtual terminals are opened on demand. A secure shell
daemon is started on demand for remote logins.

defclass::
Calls `fai-class(1)` to define classes using scripts and files in
'$FAI/class' and classes from '/tmp/fai/additional-classes' and the
variable +$ADDCLASSES+. The list of all defined classes is stored in
the variable +$classes+ and saved to '/tmp/fai/FAI_CLASSES'.

defvar::
Sources all files '$FAI/class/*.var' for every defined class. If a
hook has written some variable definitions to the file
'$LOGDIR/additional.var', this file is also sourced.

action::
Depending on the value of +$FAI_ACTION+ this subroutine decides which
action FAI should perform. The default available actions are:
_sysinfo_, _install_, _inventory_, _dirinstall_ and _softupdate_.  If +$FAI_ACTION+ has another
value, a user defined action is called if a file
'$FAI/hooks/$FAI_ACTION' exists. So you can easily define your own
actions.

sysinfo::
Called when no installation is performed but the action is
_sysinfo_. It shows information about the detected hardware and mounts
the local hard disks read only to '/target/+partitionname+' or with
regard to a 'fstab' file found inside a partition. Log files are
stored to the install server.

inventory::
A short list of system information is printed.

install::
This task controls the installation sequence. You will hear three
beeps before the installation starts. The major work is to call other
tasks and to save the output to '/tmp/fai/fai.log'. If you have any
problems during installation, look at all files in '/tmp/fai/'. You
can find examples of the log files
at https://fai-project.org/logs/.

dirinstall::
Install into a directory, not onto a local disk. Use this for creating
chroot environments.

softupdate::
This task, executed inside a running system via the `fai(8)` command
line interface, performs a softupdate.  See chapter <<softupdate>> for
details.

partition::
Calls `setup-storage(8)` to partition the hard
disks and to create file systems. The task writes variable definitions
for the root and boot partition and device (+$ROOT_PARTITION,
$BOOT_PARTITION, $BOOT_DEVICE+) to '/tmp/fai/disk_var.sh' and creates
a 'fstab' file for the new system.

mountdisks::
Mounts the created partitions according to the created
'/tmp/fai/fstab' file relative to +$FAI_ROOT+.

extrbase::
Extracts a minimal system after that a chroot can be made into it. By
default the base tar file '/var/tmp/base.tar.xz' will be
extracted. Also files matching a class name in `$FAI/basefiles/` are used for unpacking a
different tar file depending on classes defined. This can be used for
installing different Linux distributions than the one used for
creating the nfsroot. The default file 'base.tar.xz' is a snapshot of a
basic Debian system created by `debootstrap(8)`.
This task uses the variable +FAI_BASEFILEURL+ for fetching the base
file via FTP, HTTPS or HTTP if it's defined.

debconf::
Calls `fai-debconf(1)` to set the values for the debconf preseeding database.

repository::
Prepare access to the package repository by preparing the apt
configuration. This can also add repository keys
in a class based manner from files like _CLASSNAME.gpg_
in the directory _package_config_.


updatebase::
Updates the base packages of the new system and updates the list of
available packages. It also fakes some commands (called diversions)
inside the new installed system using `dpkg-divert(8)`, so no daemons
will be started during the installation.

instsoft::
Installs the desired software packages using class files in
'$FAI/package_config/'.

configure::
Calls scripts in '$FAI/scripts/' and its subdirectories for every
defined class.

tests::
Calls test scripts in '$FAI/tests/' and its subdirectories for every
defined class.

finish::
Unmounts all file systems in the new installed system and removes
diversions of files using the command `fai-divert`.

chboot::
Changes the PXE configuration for a host on the install server which
indicates which PXELINUX configuration to load on the next boot from network
card via TFTP. Therefore the `fai-chboot(8)` command is executed
remotely on the install server.

savelog::
Saves log files to local disk and to the account +$LOGUSER+ on
+$LOGSERVER+ (defaults to the install server).

faiend::
Wait for background jobs to finish (e.g. emacs compiling lisp files)
and automatically reboots the install clients or waits for manual
input before reboot.


=== [[itests]]Automated tests

After the customization scripts are executed, FAI will execute some
tests if available. Using these test, you can check for errors of the
installation. Test scripts are called via
`fai-do-scripts(1)` and should append its messages to
_$LOGDIR/test.log_. A Perl module including some useful subroutines
can be found in _Faitest.pm_. A test can also define a new class for
executing another tests during next boot via the variable
+$ADDCLASSES+.


=== [[autodiscover]] Autodiscover

In FAI 5.0 we released a feature that allows clients to search for the
faiserver in their respective subnetwork. This lifts the necessity of
having to collect every client's MAC address and configuring the DHCP
daemon.

This is done by booting from a small FAI autodiscover bootmedium (CD,
USB, etc.), which can be created via the command:

----
faiserver# fai-cd -A autodiscover.iso
----

The image is roughly 25MB in size and scans the  subnet  for
a  FAI server. By  default it shows a menu with all profiles available
in the configuration space in the same manner as the 'menu' flag
does. From this menu, you can select the installation type you wish to
perform.

For the clients to find the faiserver, the faiserver must run
fai-monitor.

=== [[changeboot]]Changing the boot device

Changing the boot sequence is normally done in the BIOS setup. But you
can't change the BIOS from a running Linux system.

So, the boot sequence of the BIOS will remain unchanged and
your computer should always boot first from its network card and the
second boot device should be the local disk. Then you can
change the boot device of the client by creating different PXELINUX
configurations. This will define if an installation
should be performed, or if the client should to boot from local
disk. This is done using `fai-chboot(8)`.


=== [[debian-mirror]]How to create a local Debian mirror

The utility `mkdebmirror` footnote:[You can find the script in
'/usr/share/doc/fai-doc/examples/utils/'] can be used for creating
your own local Debian mirror. This script uses `debmirror(1)`. A partial Debian mirror for amd64 architecture for
Debian 11 and 12 (aka bullseye and bookworm) without the source packages needs about
180GB of disk space.
Accessing the mirror via HTTP will be the
default way in most cases. To see more output from the script call
+mkdebmirror -v+. A root account is not necessary to create and
maintain the Debian mirror.

To use HTTP access to the local Debian mirror, install a web server
and create a symlink to the local directory where your mirror is
located:

----
faiserver# apt-get install apache2
faiserver# ln -s /files/scratch/debmirror /var/www/html/debmirror
----

Create a file `sources.list(5)` in '/etc/fai/apt' which gives access
to your Debian mirror. Also add the IP-address of the
HTTP server to the variable +$NFSROOT_ETC_HOSTS+ in
'nfsroot.conf' if the install clients have no DNS resolving.


=== Small hints


- When using HTTP access to a Debian mirror, the local _/var_ partition
on all install clients must be big enough to keep the downloaded
Debian packages. Do not try with less than 250 Mbytes unless you know
why. You can limit the number of packages installed at a time with the
variable +$MAXPACKAGES+.

- You can remove the red logo on the install client by simply calling
`reset` once. If will also not appear if you create a file using this
command on the install server:

----
touch /srv/fai/nfsroot/.nocolorlogo
----

- A list of variables used by FAI can be found at
https://wiki.fai-project.org/index.php/Variables.

- You can shorten some customization scripts by using one single fcopy
command _fcopy -r /_.

- If you rebuild the nfsroot, you will create a new ssh host key inside
the nfsroot. Then logging in to an install client may fail, because
the host key changes. You can use this:

----
$ ssh -o StrictHostKeyChecking=no root@installclient
----

- You can also delete the host entry on your install client in your
_~/.ssh/known_hosts_ file by using the _ssh-keygen -R_ command.

- In the tasks chboot and savelog, a connection using secure shell is
opened to the FAI server (see <<isavelog>>). To ensure that this works
non-interactively, a proper entry in 'NFSROOT/root/.ssh/known_hosts'
must be created. When using fai-setup, this is done automatically, but
it may require manual editing in case the name of your FAI server was
not determined correctly.  If you stumble over ssh connections that
require typing "yes" to accept the host key during installation,
please check the contents of your 'NFSROOT/root/.ssh/known_hosts file'

- A list of all local hard disks is
stored in +$disklist+. It's defined after `set_disk_info` is called.

-  There are multiple functions for generating a customized disk
list. See `fai-disk-info` for an example.
    * set_bootstick()
    * grepv_disks()
    * grep_disks()
    * notmatchdisks()
    * matchdisks()
    * smallestdisk()
    * largestdisk()
    * all_disks_by_size()
    * all_disks_and_size()
    * once_only()
    * checkdisk()
    * disks_by_id()

- Use `fai-divert -a` if a postinst script calls a configuration
program, e.g. the postinst script for package apache calls
apacheconfig, which needs manual input. You can fake the configuration
program so the installation can be fully automatic.

- Sometimes the installation seems to stop, but often there's only a
postinstall script of a software package that requires manual input
from the console. Change to another virtual terminal and look which
process is running with tools like `top(1)` and `pstree(1)`. You can
add _debug_ to _FAI_FLAGS_ to make the installation process show all
output from the postinst scripts on the console and get its input also
from the console.


- How can I define classes on the kernel command line?
+
Read the man page of `fai-class(8)`. If you like to define some
additional classes (for e.g. A,B,C) on the kernel command line add this: _ADDCLASSES=A,B,C_


- How to use a custom kernel inside the nfsroot?
+
Build your customized kernel by building a kernel package using
`make-kpkg(8)` and use the option `--initrd`. Copy this Debian package
to a local repository and add it to /etc/fai/sources.list. Add the
name of your package to /etc/fai/NFSROOT. Then call
+
----
# fai-make-nfsroot -k
----


- How to use the nfsroot as system for diskless clients?
+
https://wiki.fai-project.org/index.php/Use_nfsroot_for_diskless_clients


- How to serve multiple nfsroot directories on one FAI server?
+
If you want to serve multiple nfsroot directories,
you need to create specific config directories in '/etc' for FAI, like
'/etc/fai-buster' and '/etc/fai-bookworm'. Then you need to set the
+$NFSROOT+ variables to different directories and run

----
faiserver#fai-make-nfsroot -C /etc/fai-buster
----


=== flag_reboot (FAI_FLAGS)

If flag_reboot is set, by adding "reboot" to +$FAI_FLAGS+, your client
machine will reboot after the task faiend has finished. This is true
for network as well as bootmedium installations.


=== [[logfiles]]Log files

FAI is creating several log files. During installation they are stored
in '/tmp/fai' on the install client itself. At the end of the
installation they will be copied to the install server (see
<<isavelog>>). After the install client rebooted into his newly
installed system, you can find the FAI logs in '/var/log/fai'.
Log files are also created when doing the softupdate or dirinstall
action.

On the faiserver, you can find the (remote) log files under the ~fai
directory.

Sample log files from successfully installed computers are
available on https://fai-project.org/logs.
These a some log files which are created by FAI.

FAI_CLASSES::
Contains a list of all classes defined.

dmesg.log::
Output of the `dmesg` command. Contains useful messages of the kernel
ring buffer.

fai.log::
The main log file. Contains all important information. You should
*always* read this file.

boot.log::
A list of variables of network parameters, mostly defined by the DHCP daemon.

format.log::
Output of the partition tool `setup-storage(8)`.

scripts.log::
Output of all scripts, that are used for customization.

variables.log::
A list of all shell variables which are available during an
installation.

error.log::
A summary of possible errors in all log files.

disk_var.sh::
A list of variables that contain information about devices and
partitions to boot from, the root partition and a list of swap
devices. These information is used by some customization scripts
(e.g. _GRUB_PC/10-setup_).




If the installation process finishes, the hook 'savelog.LAST.sh'
searches all log files for common errors and writes them to the file
'error.log'. So, you should first look into this file for errors. Also
the file 'status.log' give you the exit code of the last command
executed in a script. To be sure, you should look for more details in
all log files.


=== How to use HTTP for PXE boot

fai-make-nfsroot now uses the lpxelinux.0 binary which already
supports transfer of the kernel and initrd via http (additional to tftp).
You only have to enable HTTP access to the tftp directory:

----
cd /var/www/html
ln -s /srv/tftp/fai
----

Add '-U URL' to the 'fai-chboot' call. For example:

----
fai-chboot -U http://faiserver/fai -IFv .......
----

== [[troubleshoot]]Troubleshooting

=== [[booterror]]Boot errors

The following error message indicates that your install client doesn't
get an answer from a DHCP server. Check your cables or start the
`dhcpd(8)` daemon with the debug flag enabled.

____
  PXE-E51: No DHCP or BOOTP offers received
  Network boot aborted
____

If you do not see the following message, the install kernel could not
detect your network card, for example because of a missing driver:

----
Starting dhcp for interface eth0
dhcp: PREINIT eth0 up
dhcp: BOND setting eth
----

Check the initrd in the nfsroot (`lsinird`) if the kernel driver of your network
card is included there and check if you like to add the package
'firmware-linux-nonfree' in +/etc/fai/NFSROOT+ and rebuild the initrd
by calling `fai-make-nfsroot -k`.
You may also add a driver to +/srv/fai/nfsroot/etc/dracut.conf+ in
the line +add_drivers+++=+.


This is the error message you will see, when your network card is
working, but the install server does not export the nfsroot
directory to the install clients, This is often caused by missing
NFS permissions on the server side.

----
Starting dhcp for interface eth0
dhcp: PREINIT eth0 up
dhcp: BOND setting eth
mount.nfs: access denied by server while mounting 192.168.33.250:/srv/fai/nfsroot
.
.
dracut Warning: Could not boot
.
Dropping to debug shell
dracut:/#
----

Now, you are inside the emergency shell of the initrd which was created
by 'dracut(8)'. You will get a shell prompt, and can look at the log files.
For more information about debugging the early boot process using
dracut see `dracut.cmdline(7)`

Use the following command on the install server to see which directories are exported
from the install server (named faiserver):

----
$ showmount -e faiserver
----
